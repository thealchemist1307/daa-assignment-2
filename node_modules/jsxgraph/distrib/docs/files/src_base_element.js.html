<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src/base/element.js - JSXGraph</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="../assets/js/jsxgraphcore.js"></script>
    <link rel="stylesheet" href="../assets/css/jsxgraph.css">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../assets/css/logo_blue.png" title="JSXGraph" width="117" height="52"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.99.4</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/Angle.html">Angle</a> </li>
                                <li><a href="../classes/Arc.html">Arc</a> </li>
                                <li><a href="../classes/Arrow.html">Arrow</a> </li>
                                <li><a href="../classes/Arrowparallel.html">Arrowparallel</a> </li>
                                <li><a href="../classes/Axis.html">Axis</a> </li>
                                <li><a href="../classes/Bisector.html">Bisector</a> </li>
                                <li><a href="../classes/Bisectorlines.html">Bisectorlines</a> </li>
                                <li><a href="../classes/Button.html">Button</a> </li>
                                <li><a href="../classes/Checkbox.html">Checkbox</a> </li>
                                <li><a href="../classes/Circle.html">Circle</a> </li>
                                <li><a href="../classes/Circumcenter.html">Circumcenter</a> </li>
                                <li><a href="../classes/Circumcircle.html">Circumcircle</a> </li>
                                <li><a href="../classes/CircumcircleArc.html">CircumcircleArc</a> </li>
                                <li><a href="../classes/CircumcircleSector.html">CircumcircleSector</a> </li>
                                <li><a href="../classes/Conic.html">Conic</a> </li>
                                <li><a href="../classes/Curve.html">Curve</a> </li>
                                <li><a href="../classes/Ellipse.html">Ellipse</a> </li>
                                <li><a href="../classes/EventEmitter.html">EventEmitter</a> </li>
                                <li><a href="../classes/Functiongraph.html">Functiongraph</a> </li>
                                <li><a href="../classes/Glider.html">Glider</a> </li>
                                <li><a href="../classes/Grid.html">Grid</a> </li>
                                <li><a href="../classes/Group.html">Group</a> </li>
                                <li><a href="../classes/Hatch.html">Hatch</a> </li>
                                <li><a href="../classes/Hyperbola.html">Hyperbola</a> </li>
                                <li><a href="../classes/Image.html">Image</a> </li>
                                <li><a href="../classes/Incenter.html">Incenter</a> </li>
                                <li><a href="../classes/Incircle.html">Incircle</a> </li>
                                <li><a href="../classes/Inequality.html">Inequality</a> </li>
                                <li><a href="../classes/Input.html">Input</a> </li>
                                <li><a href="../classes/Integral.html">Integral</a> </li>
                                <li><a href="../classes/Intersection.html">Intersection</a> </li>
                                <li><a href="../classes/JXG.html">JXG</a> </li>
                                <li><a href="../classes/JXG.AbstractRenderer.html">JXG.AbstractRenderer</a> </li>
                                <li><a href="../classes/JXG.Board.html">JXG.Board</a> </li>
                                <li><a href="../classes/JXG.C.html">JXG.C</a> </li>
                                <li><a href="../classes/JXG.CanvasRenderer.html">JXG.CanvasRenderer</a> </li>
                                <li><a href="../classes/JXG.Chart.html">JXG.Chart</a> </li>
                                <li><a href="../classes/JXG.Circle.html">JXG.Circle</a> </li>
                                <li><a href="../classes/JXG.Complex.html">JXG.Complex</a> </li>
                                <li><a href="../classes/JXG.Composition.html">JXG.Composition</a> </li>
                                <li><a href="../classes/JXG.Coords.html">JXG.Coords</a> </li>
                                <li><a href="../classes/JXG.CoordsElement.html">JXG.CoordsElement</a> </li>
                                <li><a href="../classes/JXG.Curve.html">JXG.Curve</a> </li>
                                <li><a href="../classes/JXG.GeometryElement.html">JXG.GeometryElement</a> </li>
                                <li><a href="../classes/JXG.Group.html">JXG.Group</a> </li>
                                <li><a href="../classes/JXG.Image.html">JXG.Image</a> </li>
                                <li><a href="../classes/JXG.JSXGraph.html">JXG.JSXGraph</a> </li>
                                <li><a href="../classes/JXG.Line.html">JXG.Line</a> </li>
                                <li><a href="../classes/JXG.Math.html">JXG.Math</a> </li>
                                <li><a href="../classes/JXG.Math.Geometry.html">JXG.Math.Geometry</a> </li>
                                <li><a href="../classes/JXG.Math.Numerics.html">JXG.Math.Numerics</a> </li>
                                <li><a href="../classes/JXG.Math.Poly.html">JXG.Math.Poly</a> </li>
                                <li><a href="../classes/JXG.Math.Poly.Monomial.html">JXG.Math.Poly.Monomial</a> </li>
                                <li><a href="../classes/JXG.Math.Poly.Polynomial.html">JXG.Math.Poly.Polynomial</a> </li>
                                <li><a href="../classes/JXG.Math.Poly.Ring.html">JXG.Math.Poly.Ring</a> </li>
                                <li><a href="../classes/JXG.Math.Quadtree.html">JXG.Math.Quadtree</a> </li>
                                <li><a href="../classes/JXG.Math.Statistics.html">JXG.Math.Statistics</a> </li>
                                <li><a href="../classes/JXG.Math.Symbolic.html">JXG.Math.Symbolic</a> </li>
                                <li><a href="../classes/JXG.NoRenderer.html">JXG.NoRenderer</a> </li>
                                <li><a href="../classes/JXG.Options.html">JXG.Options</a> </li>
                                <li><a href="../classes/JXG.Point.html">JXG.Point</a> </li>
                                <li><a href="../classes/JXG.Polygon.html">JXG.Polygon</a> </li>
                                <li><a href="../classes/JXG.SVGRenderer.html">JXG.SVGRenderer</a> </li>
                                <li><a href="../classes/JXG.Text.html">JXG.Text</a> </li>
                                <li><a href="../classes/JXG.Ticks.html">JXG.Ticks</a> </li>
                                <li><a href="../classes/JXG.Transformation.html">JXG.Transformation</a> </li>
                                <li><a href="../classes/JXG.Turtle.html">JXG.Turtle</a> </li>
                                <li><a href="../classes/JXG.Util.Base64.html">JXG.Util.Base64</a> </li>
                                <li><a href="../classes/JXG.Util.Unzip.html">JXG.Util.Unzip</a> </li>
                                <li><a href="../classes/JXG.VMLRenderer.html">JXG.VMLRenderer</a> </li>
                                <li><a href="../classes/Line.html">Line</a> </li>
                                <li><a href="../classes/Locus.html">Locus</a> </li>
                                <li><a href="../classes/MajorArc.html">MajorArc</a> </li>
                                <li><a href="../classes/Midpoint.html">Midpoint</a> </li>
                                <li><a href="../classes/MinorArc.html">MinorArc</a> </li>
                                <li><a href="../classes/MinorSector.html">MinorSector</a> </li>
                                <li><a href="../classes/Mirrorpoint.html">Mirrorpoint</a> </li>
                                <li><a href="../classes/NonReflexAngle.html">NonReflexAngle</a> </li>
                                <li><a href="../classes/Normal.html">Normal</a> </li>
                                <li><a href="../classes/Orthogonalprojection.html">Orthogonalprojection</a> </li>
                                <li><a href="../classes/OtherIntersection.html">OtherIntersection</a> </li>
                                <li><a href="../classes/Parabola.html">Parabola</a> </li>
                                <li><a href="../classes/Parallel.html">Parallel</a> </li>
                                <li><a href="../classes/Parallelpoint.html">Parallelpoint</a> </li>
                                <li><a href="../classes/Perpendicular.html">Perpendicular</a> </li>
                                <li><a href="../classes/PerpendicularPoint.html">PerpendicularPoint</a> </li>
                                <li><a href="../classes/PerpendicularSegment.html">PerpendicularSegment</a> </li>
                                <li><a href="../classes/Point.html">Point</a> </li>
                                <li><a href="../classes/PolarLine.html">PolarLine</a> </li>
                                <li><a href="../classes/PolePoint.html">PolePoint</a> </li>
                                <li><a href="../classes/Polygon.html">Polygon</a> </li>
                                <li><a href="../classes/RadicalAxis.html">RadicalAxis</a> </li>
                                <li><a href="../classes/Reflection.html">Reflection</a> </li>
                                <li><a href="../classes/ReflexAngle.html">ReflexAngle</a> </li>
                                <li><a href="../classes/registerReader.html">registerReader</a> </li>
                                <li><a href="../classes/RegularPolygon.html">RegularPolygon</a> </li>
                                <li><a href="../classes/Riemannsum.html">Riemannsum</a> </li>
                                <li><a href="../classes/Sector.html">Sector</a> </li>
                                <li><a href="../classes/Segment.html">Segment</a> </li>
                                <li><a href="../classes/Semicircle.html">Semicircle</a> </li>
                                <li><a href="../classes/Slider.html">Slider</a> </li>
                                <li><a href="../classes/Slopetriangle.html">Slopetriangle</a> </li>
                                <li><a href="../classes/Spline.html">Spline</a> </li>
                                <li><a href="../classes/Stepfunction.html">Stepfunction</a> </li>
                                <li><a href="../classes/Tangent.html">Tangent</a> </li>
                                <li><a href="../classes/Tapemeasure.html">Tapemeasure</a> </li>
                                <li><a href="../classes/Text.html">Text</a> </li>
                                <li><a href="../classes/Ticks.html">Ticks</a> </li>
                                <li><a href="../classes/Tracecurve.html">Tracecurve</a> </li>
                                <li><a href="../classes/Transformation.html">Transformation</a> </li>
                                <li><a href="../classes/Turtle.html">Turtle</a> </li>
                            </ul>
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="../modules/JXG.html">JXG</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: src/base/element.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/*
    Copyright 2008-2015
        Matthias Ehmann,
        Michael Gerhaeuser,
        Carsten Miller,
        Bianca Valentin,
        Alfred Wassermann,
        Peter Wilfahrt

    This file is part of JSXGraph.

    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.

    You can redistribute it and/or modify it under the terms of the

      * GNU Lesser General Public License as published by
        the Free Software Foundation, either version 3 of the License, or
        (at your option) any later version
      OR
      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT

    JSXGraph is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License and
    the MIT License along with JSXGraph. If not, see &lt;http://www.gnu.org/licenses/&gt;
    and &lt;http://opensource.org/licenses/MIT/&gt;.
 */


/*global JXG: true, define: true*/
/*jslint nomen: true, plusplus: true*/

/* depends:
 jxg
 base/constants
 base/coords
 math/math
 options
 parser/geonext
 utils/event
 utils/color
 utils/type
 */

define([
    &#x27;jxg&#x27;, &#x27;base/constants&#x27;, &#x27;base/coords&#x27;, &#x27;math/math&#x27;, &#x27;math/statistics&#x27;, &#x27;options&#x27;, &#x27;parser/geonext&#x27;, &#x27;utils/event&#x27;, &#x27;utils/color&#x27;, &#x27;utils/type&#x27;
], function (JXG, Const, Coords, Mat, Statistics, Options, GeonextParser, EventEmitter, Color, Type) {

    &quot;use strict&quot;;

    /**
     * Constructs a new GeometryElement object.
     * This is the basic class for geometry elements like points, circles and lines.
     *
     * @class JXG.GeometryElement
     * @constructor
     * @param {JXG.Board} board Reference to the board the element is constructed on.
     * @param {Object} attributes Hash of attributes and their values.
     * @param {Number} type Element type (a &lt;tt&gt;JXG.OBJECT_TYPE_&lt;/tt&gt; value).
     * @param {Number} oclass The element&#x27;s class (a &lt;tt&gt;JXG.OBJECT_CLASS_&lt;/tt&gt; value).
     *
     * @borrows JXG.EventEmitter#on as this.on
     * @borrows JXG.EventEmitter#off as this.off
     * @borrows JXG.EventEmitter#triggerEventHandlers as this.triggerEventHandlers
     * @borrows JXG.EventEmitter#eventHandlers as this.eventHandlers
     */
    JXG.GeometryElement = function (board, attributes, type, oclass) {
        var name, key, attr;

        /**
         * Controls if updates are necessary
         *
         * @property needsUpdate
         * @type Boolean
         * @default true
         */
        this.needsUpdate = true;

        /**
         * Controls if this element can be dragged. In GEONExT only
         * free points and gliders can be dragged.
         *
         * @property isDraggable
         * @type Boolean
         * @default false
         */
        this.isDraggable = false;

        /**
         * If element is in two dimensional real space this is true, else false.
         *
         * @property isReal
         * @type Boolean
         * @default true
         */
        this.isReal = true;

        /**
         * Stores all dependent objects to be updated when this point is moved.
         *
         * @property childElements
         * @type Object
         */
        this.childElements = {};

        /**
         * If element has a label subelement then this property will be set to true.
         *
         * @property hasLabel
         * @type Boolean
         * @default false
         */
        this.hasLabel = false;

        /**
         * True, if the element is currently highlighted.
         *
         * @property highlighted
         * @type Boolean
         * @default false
         */
        this.highlighted = false;

        /**
         * Stores all Intersection Objects which in this moment are not real and
         * so hide this element.
         *
         * @property notExistingParents
         * @type Object
         */
        this.notExistingParents = {};

        /**
         * Keeps track of all objects drawn as part of the trace of the element.
         *
         * @see JXG.GeometryElement#traced
         * @see JXG.GeometryElement#clearTrace
         * @see JXG.GeometryElement#numTraces
         *
         * @property traces
         * @type Object
         */
        this.traces = {};

        /**
         * Counts the number of objects drawn as part of the trace of the element.
         * @see JXG.GeometryElement#traced
         * @see JXG.GeometryElement#clearTrace
         * @see JXG.GeometryElement#traces
         *
         * @property numTraces
         * @type Number
         */
        this.numTraces = 0;

        /**
         * Stores the  transformations which are applied during update in an array
         *
         * @property transformations
         * @type Array
         * @see JXG.Transformation
         */
        this.transformations = [];

        /**
         *
         * @property baseElement
         * @type JXG.GeometryElement
         * @default null
         * @private
         */
        this.baseElement = null;

        /**
         * Elements depending on this element are stored here.
         *
         * @property descendants
         * @type Object
         */
        this.descendants = {};

        /**
         * Elements on which this element depends on are stored here.
         *
         * @property ancestors
         * @type Object
         */
        this.ancestors = {};

        /**
         * Ids of elements on which this element depends directly are stored here.
         *
         * @property parents
         * @type Object
         */
        this.parents = [];

        /**
         * Stores variables for symbolic computations
         *
         * @property symbolic
         * @type Object
         */
        this.symbolic = {};

        /**
         * Stores the rendering node for the element.
         *
         * @property rendNode
         * @type Object
         */
        this.rendNode = null;

        /**
         * The string used with {@link JXG.Board#create}
         *
         * @property elType
         * @type String
         */
        this.elType = &#x27;&#x27;;

        /**
         * The element is saved with an explicit entry in the file (&lt;tt&gt;true&lt;/tt&gt;) or implicitly
         * via a composition.
         *
         * @property dump
         * @type Boolean
         * @default true
         */
        this.dump = true;

        /**
         * Subs contains the subelements, created during the create method.
         *
         * @property subs
         * @type Object
         */
        this.subs = {};

        /**
         * The position of this element inside the {@link JXG.Board#objectsList}.
         *
         * @property _pos
         * @type {Number}
         * @default -1
         * @private
         */
        this._pos = -1;

        /**
         * [c,b0,b1,a,k,r,q0,q1]
         *
         * See
         * A.E. Middleditch, T.W. Stacey, and S.B. Tor:
         * &quot;Intersection Algorithms for Lines and Circles&quot;,
         * ACM Transactions on Graphics, Vol. 8, 1, 1989, pp 25-40.
         *
         * The meaning of the parameters is:
         * Circle: points p=[p0,p1] on the circle fulfill
         *  a&amp;lt;p,p&amp;gt; + &amp;lt;b,p&amp;gt; + c = 0
         * For convenience we also store
         *  r: radius
         *  k: discriminant = sqrt(&amp;lt;b,b&amp;gt;-4ac)
         *  q=[q0,q1] center
         *
         * Points have radius = 0.
         * Lines have radius = infinity.
         * b: normalized vector, representing the direction of the line.
         *
         * Should be put into Coords, when all elements possess Coords.
         *
         * @property stdform
         * @type Array
         * @default [1, 0, 0, 0, 1, 1, 0, 0]
         */
        this.stdform = [1, 0, 0, 0, 1, 1, 0, 0];

        /**
         * The methodMap determines which methods can be called from within JessieCode and under which name it
         * can be used. The map is saved in an object, the name of a property is the name of the method used in JessieCode,
         * the value of a property is the name of the method in JavaScript.
         *
         * @property methodMap
         * @type Object
         */
        this.methodMap = {
            setLabel: &#x27;setLabel&#x27;,
            label: &#x27;label&#x27;,
            setName: &#x27;setName&#x27;,
            getName: &#x27;getName&#x27;,
            addTransform: &#x27;addTransform&#x27;,
            setProperty: &#x27;setAttribute&#x27;,
            setAttribute: &#x27;setAttribute&#x27;,
            addChild: &#x27;addChild&#x27;,
            animate: &#x27;animate&#x27;,
            on: &#x27;on&#x27;,
            off: &#x27;off&#x27;,
            trigger: &#x27;trigger&#x27;
        };

        /**
         * Quadratic form representation of circles (and conics)
         *
         * @property quadraticform
         * @type Array
         * @default [[1,0,0],[0,1,0],[0,0,1]]
         */
        this.quadraticform = [[1, 0, 0], [0, 1, 0], [0, 0, 1]];

        /**
         * An associative array containing all visual properties.
         *
         * @property visProp
         * @type Object
         * @default empty object
         */
        this.visProp = {};

        EventEmitter.eventify(this);

        /**
         * Is the mouse over this element?
         *
         * @property mouseover
         * @type Boolean
         * @default false
         */
        this.mouseover = false;

        /**
         * Time stamp containing the last time this element has been dragged.
         *
         * @property lastDragTime
         * @type Date
         * @default creation time
         */
        this.lastDragTime = new Date();

        if (arguments.length &gt; 0) {
            /**
             * Reference to the board associated with the element.
             *
             * @property board
             * @type JXG.Board
             */
            this.board = board;

            /**
             * Type of the element.
             *
             * @property type
             * @final
             * @type number
             */
            this.type = type;

            /**
             * Original type of the element at construction time. Used for removing glider property.
             *
             * @property _org_type
             * @final
             * @type number
             */
            this._org_type = type;

            /**
             * The element&#x27;s class.
             *
             * @property elementClass
             * @final
             * @type number
             */
            this.elementClass = oclass || Const.OBJECT_CLASS_OTHER;

            /**
             * Unique identifier for the element. Equivalent to id-attribute of renderer element.
             *
             * @property id
             * @type String
             */
            this.id = attributes.id;

            name = attributes.name;
            /* If name is not set or null or even undefined, generate an unique name for this object */
            if (!Type.exists(name)) {
                name = this.board.generateName(this);
            }

            if (name !== &#x27;&#x27;) {
                this.board.elementsByName[name] = this;
            }

            /**
             * Not necessarily unique name for the element.
             *
             * @property name
             * @type String
             * @default Name generated by {@link JXG.Board#generateName}.
             * @see JXG.Board#generateName
             */
            this.name = name;

            this.needsRegularUpdate = attributes.needsregularupdate;

            // create this.visPropOld and set default values
            Type.clearVisPropOld(this);

            attr = this.resolveShortcuts(attributes);
            for (key in attr) {
                if (attr.hasOwnProperty(key)) {
                    this._set(key, attr[key]);
                }
            }

            this.visProp.draft = attr.draft &amp;&amp; attr.draft.draft;
            this.visProp.gradientangle = &#x27;270&#x27;;
            this.visProp.gradientsecondopacity = this.visProp.fillopacity;
            this.visProp.gradientpositionx = 0.5;
            this.visProp.gradientpositiony = 0.5;
        }
    };

    JXG.extend(JXG.GeometryElement.prototype, /** @lends JXG.GeometryElement.prototype */ {
        /**
         * Add an element as a child to the current element. Can be used to model dependencies between geometry elements.
         *
         * @method addChild
         * @param {JXG.GeometryElement} obj The dependent object.
         * @chainable
         */
        addChild: function (obj) {
            var el, el2;

            this.childElements[obj.id] = obj;
            this.addDescendants(obj);
            obj.ancestors[this.id] = this;

            for (el in this.descendants) {
                if (this.descendants.hasOwnProperty(el)) {
                    this.descendants[el].ancestors[this.id] = this;

                    for (el2 in this.ancestors) {
                        if (this.ancestors.hasOwnProperty(el2)) {
                            this.descendants[el].ancestors[this.ancestors[el2].id] = this.ancestors[el2];
                        }
                    }
                }
            }

            for (el in this.ancestors) {
                if (this.ancestors.hasOwnProperty(el)) {
                    for (el2 in this.descendants) {
                        if (this.descendants.hasOwnProperty(el2)) {
                            this.ancestors[el].descendants[this.descendants[el2].id] = this.descendants[el2];
                        }
                    }
                }
            }
            return this;
        },

        /**
         * Adds the given object to the descendants list of this object and all its child objects.
         * @method addDescendants
         * @param {JXG.GeometryElement} obj The element that is to be added to the descendants list.
         * @private
         * @chainable
         */
        addDescendants: function (obj) {
            var el;

            this.descendants[obj.id] = obj;
            for (el in obj.childElements) {
                if (obj.childElements.hasOwnProperty(el)) {
                    this.addDescendants(obj.childElements[el]);
                }
            }
            return this;
        },

        /**
         * Adds ids of elements to the array this.parents. This method needs to be called if some dependencies
         * can not be detected automatically by JSXGraph. For example if a function graph is given by a function
         * which referes to coordinates of a point, calling addParents() is necessary.
         *
         * @method addParents
         * @param {Array} parents Array of elements or ids of elements.
         * Alternatively, one can give a list of objects as parameters.
         * @return {JXG.Object} reference to the object itself.
         * @chainable
         *
         * @example
         *     // Movable function graph
         *     var A = board.create(&#x27;point&#x27;, [1, 0], {name:&#x27;A&#x27;}),
         *         B = board.create(&#x27;point&#x27;, [3, 1], {name:&#x27;B&#x27;}),
         *         f = board.create(&#x27;functiongraph&#x27;, function(x) {
         *                  var ax = A.X(),
         *                      ay = A.Y(),
         *                      bx = B.X(),
         *                      by = B.Y(),
         *                     a = (by - ay) / ( (bx - ax) * (bx - ax) );
         *                  return a * (x - ax) * (x - ax) + ay;
         *              }, {fixed: false});
         *     f.addParents([A, B]);
         * &lt;div id=&quot;7c91d4d2-986c-4378-8135-24505027f251&quot; style=&quot;width: 400px; height: 400px;&quot;&gt;&lt;/div&gt;
         * &lt;script type=&quot;text/javascript&quot;&gt;
         * (function() {
         *   var board = JXG.JSXGraph.initBoard(&#x27;7c91d4d2-986c-4378-8135-24505027f251&#x27;, {boundingbox: [-1, 9, 9, -1], axis: true, showcopyright: false, shownavigation: false});
         *   var A = board.create(&#x27;point&#x27;, [1, 0], {name:&#x27;A&#x27;}),
         *       B = board.create(&#x27;point&#x27;, [3, 1], {name:&#x27;B&#x27;}),
         *       f = board.create(&#x27;functiongraph&#x27;, function(x) {
         *            var ax = A.X(),
         *                ay = A.Y(),
         *                bx = B.X(),
         *                by = B.Y(),
         *                a = (by - ay) / ( (bx - ax) * (bx - ax) );
         *             return a * (x - ax) * (x - ax) + ay;
         *        }, {fixed: false});
         *   f.addParents([A, B]);
         * })();
         * &lt;/script&gt;
         *
         **/
        addParents: function (parents) {
            var i, len, par;

            if (Type.isArray(parents)) {
                par = parents;
            } else {
                par = arguments;
            }

            len = par.length;
            for (i = 0; i &lt; len; ++i) {
                if (Type.isId(this.board, par[i])) {
                    this.parents.push(par[i]);
                } else if (Type.exists(par[i].id)) {
                    this.parents.push(par[i].id);
                }
            }
            this.parents = Type.uniqueArray(this.parents);

            return this;
        },

        /**
         * Sets ids of elements to the array this.parents.
         * First, this.parents is cleared. See {@link Element#addParents}.
         *
         * @method setParents
         * @param {Array} parents Array of elements or ids of elements.
         * Alternatively, one can give a list of objects as parameters.
         * @return {JXG.Object} reference to the object itself.
         * @chainable
         **/
        setParents: function(parents) {
            this.parents = [];
            return this.addParents(parents);
        },

        /**
         * Remove an element as a child from the current element.
         *
         * @method removeChild
         * @param {JXG.GeometryElement} obj The dependent object.
         * @chainable
         */
        removeChild: function (obj) {
            var el, el2;

            delete this.childElements[obj.id];
            this.removeDescendants(obj);
            delete obj.ancestors[this.id];

            /*
             // I do not know if these addDescendants stuff has to be adapted to removeChild. A.W.
            for (el in this.descendants) {
                if (this.descendants.hasOwnProperty(el)) {
                    delete this.descendants[el].ancestors[this.id];

                    for (el2 in this.ancestors) {
                        if (this.ancestors.hasOwnProperty(el2)) {
                            this.descendants[el].ancestors[this.ancestors[el2].id] = this.ancestors[el2];
                        }
                    }
                }
            }

            for (el in this.ancestors) {
                if (this.ancestors.hasOwnProperty(el)) {
                    for (el2 in this.descendants) {
                        if (this.descendants.hasOwnProperty(el2)) {
                            this.ancestors[el].descendants[this.descendants[el2].id] = this.descendants[el2];
                        }
                    }
                }
            }
            */
            return this;
        },

        /**
         * Removes the given object from the descendants list of this object and all its child objects.
         *
         * @method removeDescendants
         * @param {JXG.GeometryElement} obj The element that is to be removed from the descendants list.
         * @private
         * @chainable
         */
        removeDescendants: function (obj) {
            var el;

            delete this.descendants[obj.id];
            for (el in obj.childElements) {
                if (obj.childElements.hasOwnProperty(el)) {
                    this.removeDescendants(obj.childElements[el]);
                }
            }
            return this;
        },

        /**
         * Counts the direct children of an object without counting labels.
         *
         * @method countChildren
         * @private
         * @return {number} Number of children
         */
        countChildren: function () {
            var prop, d,
                s = 0;

            d = this.childElements;
            for (prop in d) {
                if (d.hasOwnProperty(prop) &amp;&amp; prop.indexOf(&#x27;Label&#x27;) &lt; 0) {
                    s++;
                }
            }
            return s;
        },

        /**
         * Returns the elements name, used in JessieCode.
         *
         * @method getName
         * @return {String}
         */
        getName: function () {
            return this.name;
        },

        /**
         * Add transformations to this element.
         *
         * @method addTransform
         * @param {JXG.Transformation|Array} transform Either one {@link JXG.Transformation}
         *   or an array of {@link JXG.Transformation}s.
         * @return {JXG.GeometryElement} Reference to the element.
         * @chainable
         */
        addTransform: function (transform) {
            return this;
        },

        /**
         * Decides whether an element can be dragged. This is used in {@link JXG.GeometryElement#setPositionDirectly} methods
         * where all parent elements are checked if they may be dragged, too.
         *
         * @method draggable
         * @private
         * @return {boolean}
         */
        draggable: function () {
            return this.isDraggable &amp;&amp; !this.visProp.fixed &amp;&amp;
                /*!this.visProp.frozen &amp;&amp;*/ this.type !== Const.OBJECT_TYPE_GLIDER;
        },

        /**
         * Translates the object by &lt;tt&gt;(x, y)&lt;/tt&gt;. In case the element is defined by points, the defining points are
         * translated, e.g. a circle constructed by a center point and a point on the circle line.
         *
         * @method setPosition
         * @param {Number} method The type of coordinates used here.
         * Possible values are {@link JXG.COORDS_BY_USER} and {@link JXG.COORDS_BY_SCREEN}.
         * @param {Array} coords array of translation vector.
         * @return {JXG.GeometryElement} Reference to the element object.
         * @chainable
         */
        setPosition: function (method, coords) {
            var parents = [], el, i, len, t;

            if (!JXG.exists(this.parents)) {
                return this;
            }

            len = this.parents.length;
            for (i = 0; i &lt; len; ++i) {
                el = this.board.select(this.parents[i]);
                if (Type.isPoint(el)) {
                    if (!el.draggable()) {
                        return this;
                    } else {
                        parents.push(el);
                    }
                }
            }

            if (coords.length === 3) {
                coords = coords.slice(1);
            }

            t = this.board.create(&#x27;transform&#x27;, coords, {type: &#x27;translate&#x27;});

            // We distinguish two cases:
            // 1) elements which depend on free elements, i.e. arcs and sectors
            // 2) other elements
            //
            // In the first case we simply transform the parents elements
            // In the second case we add a transform to the element.
            //
            len = parents.length;
            if (len &gt; 0) {
                t.applyOnce(parents);
            } else {
                if (this.transformations.length &gt; 0 &amp;&amp;
                        this.transformations[this.transformations.length - 1].isNumericMatrix) {
                    this.transformations[this.transformations.length - 1].melt(t);
                } else {
                    this.addTransform(t);
                }
            }

            /*
             * If - against the default configuration - defining gliders are marked as
             * draggable, then their position has to be updated now.
             */
            for (i = 0; i &lt; len; ++i) {
                if (parents[i].type === Const.OBJECT_TYPE_GLIDER) {
                    parents[i].updateGlider();
                }
            }

            return this;
        },

        /**
         * Moves an by the difference of two coordinates.
         *
         * @method setPositionDirectly
         * @param {Number} method The type of coordinates used here. Possible values are {@link JXG.COORDS_BY_USER} and {@link JXG.COORDS_BY_SCREEN}.
         * @param {Array} coords coordinates in screen/user units
         * @param {Array} oldcoords previous coordinates in screen/user units
         * @return {JXG.GeometryElement} this element
         * @chainable
         */
        setPositionDirectly: function (method, coords, oldcoords) {
            var c = new Coords(method, coords, this.board, false),
                oldc = new Coords(method, oldcoords, this.board, false),
                dc = Statistics.subtract(c.usrCoords, oldc.usrCoords);

            this.setPosition(Const.COORDS_BY_USER, dc);

            return this;
        },

        /**
         * Array of strings containing the polynomials defining the element.
         * Used for determining geometric loci the groebner way.
         *
         * @method generatePolynomial
         * @return {Array} An array containing polynomials describing the locus of the current object.
         */
        generatePolynomial: function () {
            return [];
        },

        /**
         * Animates properties for that object like stroke or fill color, opacity and maybe
         * even more later.
         *
         * @method animate
         * @param {Object} hash Object containing properties with target values for the animation.
         * @param {number} time Number of milliseconds to complete the animation.
         * @param {Object} [options] Optional settings for the animation:&lt;ul&gt;&lt;li&gt;callback: A function that is called as soon as the animation is finished.&lt;/li&gt;&lt;/ul&gt;
         * @return {JXG.GeometryElement} A reference to the object
         * @chainable
         */
        animate: function (hash, time, options) {
            options = options || {};
            var r, p, i,
                delay = this.board.attr.animationdelay,
                steps = Math.ceil(time / delay),
                self = this,

                animateColor = function (startRGB, endRGB, property) {
                    var hsv1, hsv2, sh, ss, sv;
                    hsv1 = Color.rgb2hsv(startRGB);
                    hsv2 = Color.rgb2hsv(endRGB);

                    sh = (hsv2[0] - hsv1[0]) / steps;
                    ss = (hsv2[1] - hsv1[1]) / steps;
                    sv = (hsv2[2] - hsv1[2]) / steps;
                    self.animationData[property] = [];

                    for (i = 0; i &lt; steps; i++) {
                        self.animationData[property][steps - i - 1] = Color.hsv2rgb(hsv1[0] + (i + 1) * sh, hsv1[1] + (i + 1) * ss, hsv1[2] + (i + 1) * sv);
                    }
                },

                animateFloat = function (start, end, property, round) {
                    var tmp, s;

                    start = parseFloat(start);
                    end = parseFloat(end);

                    // we can&#x27;t animate without having valid numbers.
                    // And parseFloat returns NaN if the given string doesn&#x27;t contain
                    // a valid float number.
                    if (isNaN(start) || isNaN(end)) {
                        return;
                    }

                    s = (end - start) / steps;
                    self.animationData[property] = [];

                    for (i = 0; i &lt; steps; i++) {
                        tmp = start + (i + 1) * s;
                        self.animationData[property][steps - i - 1] = round ? Math.floor(tmp) : tmp;
                    }
                };

            this.animationData = {};

            for (r in hash) {
                if (hash.hasOwnProperty(r)) {
                    p = r.toLowerCase();

                    switch (p) {
                    case &#x27;strokecolor&#x27;:
                    case &#x27;fillcolor&#x27;:
                        animateColor(this.visProp[p], hash[r], p);
                        break;
                    case &#x27;size&#x27;:
                        if (!Type.isPoint(this)) {
                            break;
                        }
                        animateFloat(this.visProp[p], hash[r], p, true);
                        break;
                    case &#x27;strokeopacity&#x27;:
                    case &#x27;strokewidth&#x27;:
                    case &#x27;fillopacity&#x27;:
                        animateFloat(this.visProp[p], hash[r], p, false);
                        break;
                    }
                }
            }

            this.animationCallback = options.callback;
            this.board.addAnimation(this);
            return this;
        },

        /**
         * Update method. Position and content of the element are updated.
         * The element is redrawn by a subsequent call of {@see #updateRenderer}.
         * Can be used sometimes to commit changes to the object.
         *
         * @method update
         * @chainable
         */
        update: function () {
            if (this.visProp.trace) {
                this.cloneToBackground();
            }
            return this;
        },

        /**
         * Provide updateRenderer method.
         *
         * @method updateRenderer
         * @chainable
         * @private
         */
        updateRenderer: function () {
            return this;
        },

        /**
         * Hide the element. It will still exist but not visible on the board.
         *
         * @method hideElement
         * @chainable
         */
        hideElement: function () {
            this.visProp.visible = false;
            this.board.renderer.hide(this);

            if (Type.exists(this.label) &amp;&amp; this.hasLabel) {
                this.label.hiddenByParent = true;
                if (this.label.visProp.visible) {
                    this.label.hideElement();
                }
            }
            return this;
        },

        /**
         * Make the element visible.
         *
         * @method showElement
         * @chainable
         */
        showElement: function () {
            this.visProp.visible = true;
            this.board.renderer.show(this);

            if (Type.exists(this.label) &amp;&amp; this.hasLabel &amp;&amp; this.label.hiddenByParent) {
                this.label.hiddenByParent = false;
                if (!this.label.visProp.visible) {
                    this.label.showElement().updateRenderer();
                }
            }
            return this;
        },

        /**
         * Sets the value of property &lt;tt&gt;property&lt;/tt&gt; to &lt;tt&gt;value&lt;/tt&gt;.
         *
         * @method _set
         * @param {String} property The property&#x27;s name.
         * @param value The new value
         * @private
         * @chainable
         */
        _set: function (property, value) {
            property = property.toLocaleLowerCase();

            // Search for entries in visProp with &quot;color&quot; as part of the property name
            // and containing a RGBA string
            if (this.visProp.hasOwnProperty(property) &amp;&amp; property.indexOf(&#x27;color&#x27;) &gt;= 0 &amp;&amp;
                    Type.isString(value) &amp;&amp; value.length === 9 &amp;&amp; value.charAt(0) === &#x27;#&#x27;) {
                value = Color.rgba2rgbo(value);
                this.visProp[property] = value[0];
                // Previously: *=. But then, we can only decrease opacity.
                this.visProp[property.replace(&#x27;color&#x27;, &#x27;opacity&#x27;)] = value[1];
            } else {
                this.visProp[property] = value;
            }

            return this;
        },

        /**
         * Resolves property shortcuts like &lt;tt&gt;color&lt;/tt&gt; and expands them, e.g. &lt;tt&gt;strokeColor&lt;/tt&gt; and &lt;tt&gt;fillColor&lt;/tt&gt;.
         * Writes the expanded properties back to the given &lt;tt&gt;properties&lt;/tt&gt;.
         *
         * @method resolveShortcuts
         * @param {Object} properties
         * @return {Object} The given parameter with shortcuts expanded.
         */
        resolveShortcuts: function (properties) {
            var key, i;

            for (key in Options.shortcuts) {
                if (Options.shortcuts.hasOwnProperty(key)) {
                    if (Type.exists(properties[key])) {
                        for (i = 0; i &lt; Options.shortcuts[key].length; i++) {
                            if (!Type.exists(properties[Options.shortcuts[key][i]])) {
                                properties[Options.shortcuts[key][i]] = properties[key];
                            }
                        }
                    }
                }
            }
            return properties;
        },

        /**
         * Sets a label and it&#x27;s text
         * If label doesn&#x27;t exist, it creates one
         *
         * @method setLabel
         * @param {String} str
         * @chainable
         */
        setLabel: function (str) {
            if (!this.hasLabel) {
                this.setAttribute({&#x27;withlabel&#x27;: true});
            }
            return this.setLabelText(str);
        },

        /**
         * Updates the element&#x27;s label text, strips all html.
         *
         * @method setLabelText
         * @param {String} str
         * @chainable
         */
        setLabelText: function (str) {

            if (Type.exists(this.label)) {
                str = str.replace(/&lt;/g, &#x27;&amp;lt;&#x27;).replace(/&gt;/g, &#x27;&amp;gt;&#x27;);
                this.label.setText(str);
            }

            return this;
        },

        /**
         * Updates the element&#x27;s label text and the element&#x27;s attribute &quot;name&quot;, strips all html.
         *
         * @method setName
         * @param {String} str
         * @chainable
         */
        setName: function (str) {
            str = str.replace(/&lt;/g, &#x27;&amp;lt;&#x27;).replace(/&gt;/g, &#x27;&amp;gt;&#x27;);
            if (this.elType !== &#x27;slider&#x27;) {
                this.setLabelText(str);
            }
            this.setAttribute({name: str});
            return this;
        },

        /**
         * Deprecated alias for {@link JXG.GeometryElement#setAttribute}.
         *
         * @method setProperty
         * @deprecated Use {@link JXG.GeometryElement#setAttribute}.
         */
        setProperty: function () {
            JXG.deprecated(&#x27;setProperty()&#x27;, &#x27;setAttribute()&#x27;);
            this.setAttribute.apply(this, arguments);
        },

        /**
         * Sets an arbitrary number of attributes.
         *
         * @method setAttribute
         * @param {Object} attributes An object with attributes.
         * @chainable
         * @example
         *     // Set property directly on creation of an element using the attributes object parameter
         *     var board = JXG.JSXGraph.initBoard(&#x27;jxgbox&#x27;, {boundingbox: [-1, 5, 5, 1]};
         *     var p = board.create(&#x27;point&#x27;, [2, 2], {visible: false});
         *
         *     // Now make this point visible and fixed:
         *     p.setAttribute({
         *         fixed: true,
         *         visible: true
         *     });
         */
        setAttribute: function (attributes) {
            var i, key, value, arg, opacity, pair, oldvalue,
                properties = {};

            // normalize the user input
            for (i = 0; i &lt; arguments.length; i++) {
                arg = arguments[i];
                if (Type.isString(arg)) {
                    // pairRaw is string of the form &#x27;key:value&#x27;
                    pair = arg.split(&#x27;:&#x27;);
                    properties[Type.trim(pair[0])] = Type.trim(pair[1]);
                } else if (!Type.isArray(arg)) {
                    // pairRaw consists of objects of the form {key1:value1,key2:value2,...}
                    JXG.extend(properties, arg);
                } else {
                    // pairRaw consists of array [key,value]
                    properties[arg[0]] = arg[1];
                }
            }

            // handle shortcuts
            properties = this.resolveShortcuts(properties);

            for (i in properties) {
                if (properties.hasOwnProperty(i)) {
                    key = i.replace(/\s+/g, &#x27;&#x27;).toLowerCase();
                    value = properties[i];
                    oldvalue = this.visProp[key];

                    switch (key) {
                    case &#x27;name&#x27;:
                        oldvalue = this.name;
                        delete this.board.elementsByName[this.name];
                        this.name = value;
                        this.board.elementsByName[this.name] = this;
                        break;
                    case &#x27;needsregularupdate&#x27;:
                        this.needsRegularUpdate = !(value === &#x27;false&#x27; || value === false);
                        this.board.renderer.setBuffering(this, this.needsRegularUpdate ? &#x27;auto&#x27; : &#x27;static&#x27;);
                        break;
                    case &#x27;labelcolor&#x27;:
                        value = Color.rgba2rgbo(value);
                        opacity = value[1];
                        value = value[0];
                        if (opacity === 0) {
                            if (Type.exists(this.label) &amp;&amp; this.hasLabel) {
                                this.label.hideElement();
                            }
                        }
                        if (Type.exists(this.label) &amp;&amp; this.hasLabel) {
                            this.label.visProp.strokecolor = value;
                            this.board.renderer.setObjectStrokeColor(this.label, value, opacity);
                        }
                        if (this.elementClass === Const.OBJECT_CLASS_TEXT) {
                            this.visProp.strokecolor = value;
                            this.visProp.strokeopacity = opacity;
                            this.board.renderer.setObjectStrokeColor(this, this.visProp.strokecolor, this.visProp.strokeopacity);
                        }
                        break;
                    case &#x27;infoboxtext&#x27;:
                        if (typeof value === &#x27;string&#x27;) {
                            this.infoboxText = value;
                        } else {
                            this.infoboxText = false;
                        }
                        break;
                    case &#x27;visible&#x27;:
                        if (value === &#x27;false&#x27; || value === false) {
                            this.visProp.visible = false;
                            this.hideElement();
                        } else if (value === &#x27;true&#x27; || value === true) {
                            this.visProp.visible = true;
                            this.showElement();
                        }
                        break;
                    case &#x27;face&#x27;:
                        if (Type.isPoint(this)) {
                            this.visProp.face = value;
                            this.board.renderer.changePointStyle(this);
                        }
                        break;
                    case &#x27;trace&#x27;:
                        if (value === &#x27;false&#x27; || value === false) {
                            this.clearTrace();
                            this.visProp.trace = false;
                        } else {
                            this.visProp.trace = true;
                        }
                        break;
                    case &#x27;gradient&#x27;:
                        this.visProp.gradient = value;
                        this.board.renderer.setGradient(this);
                        break;
                    case &#x27;gradientsecondcolor&#x27;:
                        value = Color.rgba2rgbo(value);
                        this.visProp.gradientsecondcolor = value[0];
                        this.visProp.gradientsecondopacity = value[1];
                        this.board.renderer.updateGradient(this);
                        break;
                    case &#x27;gradientsecondopacity&#x27;:
                        this.visProp.gradientsecondopacity = value;
                        this.board.renderer.updateGradient(this);
                        break;
                    case &#x27;withlabel&#x27;:
                        this.visProp.withlabel = value;
                        if (!value) {
                            if (this.label &amp;&amp; this.hasLabel) {
                                this.label.hideElement();
                            }
                        } else {
                            if (this.label) {
                                if (this.visProp.visible) {
                                    this.label.showElement();
                                }
                            } else {
                                this.createLabel();
                                if (!this.visProp.visible) {
                                    this.label.hideElement();
                                }
                            }
                        }
                        this.hasLabel = value;
                        break;
                    case &#x27;radius&#x27;:
                        if (this.type === Const.OBJECT_TYPE_ANGLE || this.type === Const.OBJECT_TYPE_SECTOR) {
                            this.setRadius(value);
                        }
                        break;
                    case &#x27;rotate&#x27;:
                        if ((this.elementClass === Const.OBJECT_CLASS_TEXT &amp;&amp; this.visProp.display === &#x27;internal&#x27;) ||
                                this.type === Const.OBJECT_TYPE_IMAGE) {
                            this.addRotation(value);
                        }
                        break;
                    case &#x27;ticksdistance&#x27;:
                        if (this.type === Const.OBJECT_TYPE_TICKS &amp;&amp; typeof value === &#x27;number&#x27;) {
                            this.ticksFunction = this.makeTicksFunction(value);
                        }
                        break;
                    case &#x27;generatelabelvalue&#x27;:
                        if (this.type === Const.OBJECT_TYPE_TICKS &amp;&amp; typeof value === &#x27;function&#x27;) {
                            this.generateLabelValue = value;
                        }
                        break;
                    case &#x27;onpolygon&#x27;:
                        if (this.type === Const.OBJECT_TYPE_GLIDER) {
                            this.onPolygon = !!value;
                        }
                        break;
                    case &#x27;disabled&#x27;:
                        // button, checkbox, input. Is not available on initial call.
                        if (JXG.exists(this.rendNodeTag)) {
                            this.rendNodeTag.disabled = !!value;
                        }
                        break;
                    default:
                        if (Type.exists(this.visProp[key]) &amp;&amp; (!JXG.Validator[key] || (JXG.Validator[key] &amp;&amp;
                                JXG.Validator[key](value)) || (JXG.Validator[key] &amp;&amp;
                                Type.isFunction(value) &amp;&amp; JXG.Validator[key](value())))) {
                            value = value.toLowerCase &amp;&amp; value.toLowerCase() === &#x27;false&#x27; ? false : value;
                            this._set(key, value);
                        }
                        break;
                    }
                    this.triggerEventHandlers([&#x27;attribute:&#x27; + key], [oldvalue, value, this]);
                }
            }

            this.triggerEventHandlers([&#x27;attribute&#x27;], [properties, this]);

            if (!this.visProp.needsregularupdate) {
                this.board.fullUpdate();
            } else {
                this.board.update(this);
            }

            return this;
        },

        /**
         * Deprecated alias for {@link JXG.GeometryElement#getAttribute}.
         *
         * @method getProperty
         * @deprecated Use {@link JXG.GeometryElement#getAttribute}.
         */
        getProperty: function () {
            JXG.deprecated(&#x27;getProperty()&#x27;, &#x27;getAttribute()&#x27;);
            this.getProperty.apply(this, arguments);
        },

        /**
         * Get the value of the property &lt;tt&gt;key&lt;/tt&gt;.
         *
         * @method getAttribute
         * @param {String} key The name of the property you are looking for
         * @return The value of the property
         */
        getAttribute: function (key) {
            var result;
            key = key.toLowerCase();

            switch (key) {
            case &#x27;needsregularupdate&#x27;:
                result = this.needsRegularUpdate;
                break;
            case &#x27;labelcolor&#x27;:
                result = this.label.visProp.strokecolor;
                break;
            case &#x27;infoboxtext&#x27;:
                result = this.infoboxText;
                break;
            case &#x27;withlabel&#x27;:
                result = this.hasLabel;
                break;
            default:
                result = this.visProp[key];
                break;
            }

            return result;
        },

        /**
         * Set the dash style of an object. See {@link #dash} for a list of available dash styles.
         * You should use {@link #setAttribute} instead of this method.
         *
         * @method setDash
         * @param {number} dash Indicates the new dash style
         * @private
         * @chainable
         */
        setDash: function (dash) {
            this.setAttribute({dash: dash});
            return this;
        },

        /**
         * Notify all child elements for updates.
         *
         * @method prepareUpdate
         * @private
         * @chainable
         */
        prepareUpdate: function () {
            this.needsUpdate = true;
            return this;
        },

        /**
         * Removes the element from the construction.  This only removes the SVG or VML node of the element and its label (if available) from
         * the renderer, to remove the element completely you should use {@link JXG.Board#removeObject}.
         *
         * @method remove
         * @chainable
         */
        remove: function () {
            this.board.renderer.remove(this.board.renderer.getElementById(this.id));

            if (this.hasLabel) {
                this.board.renderer.remove(this.board.renderer.getElementById(this.label.id));
            }
            return this;
        },

        /**
         * Returns the coords object where a text that is bound to the element shall be drawn.
         * Differs in some cases from the values that getLabelAnchor returns.
         *
         * @method getTextAnchor
         * @return {JXG.Coords} JXG.Coords Place where the text shall be drawn.
         * @see JXG.GeometryElement#getLabelAnchor
         */
        getTextAnchor: function () {
            return new Coords(Const.COORDS_BY_USER, [0, 0], this.board);
        },

        /**
         * Returns the coords object where the label of the element shall be drawn.
         * Differs in some cases from the values that getTextAnchor returns.
         *
         * @method getLabelAnchor
         * @return {JXG.Coords} JXG.Coords Place where the text shall be drawn.
         * @see JXG.GeometryElement#getTextAnchor
         */
        getLabelAnchor: function () {
            return new Coords(Const.COORDS_BY_USER, [0, 0], this.board);
        },

        /**
         * Determines whether the element has arrows at start or end of the arc.
         *
         * @method setArrow
         * @param {Boolean} firstArrow True if there is an arrow at the start of the arc, false otherwise.
         * @param {Boolean} lastArrow True if there is an arrow at the end of the arc, false otherwise.
         * @chainable
         */
        setArrow: function (firstArrow, lastArrow) {
            this.visProp.firstarrow = firstArrow;
            this.visProp.lastarrow = lastArrow;
            this.prepareUpdate().update();
            return this;
        },

        /**
         * Creates a gradient nodes in the renderer.
         *
         * @method createGradient
         * @see JXG.SVGRenderer#setGradient
         * @private
         * @chainable
         */
        createGradient: function () {
            if (this.visProp.gradient === &#x27;linear&#x27; || this.visProp.gradient === &#x27;radial&#x27;) {
                this.board.renderer.setGradient(this);
            }
            return this;
        },

        /**
         * Creates a label element for this geometry element.
         *
         * @method createLabel
         * @chainable
         * @see #addLabelToElement
         */
        createLabel: function () {
            var attr,
                that = this;

            // this is a dirty hack to resolve the text-dependency. If there is no text element available,
            // just don&#x27;t create a label. This method is usually not called by a user, so we won&#x27;t throw
            // an exception here and simply output a warning via JXG.debug.
            if (JXG.elements.text) {
                attr =  Type.deepCopy(this.visProp.label, null);
                attr.id = this.id + &#x27;Label&#x27;;
                attr.isLabel = true;
                attr.visible = this.visProp.visible;
                attr.anchor = this;
                attr.priv = this.visProp.priv;

                if (this.visProp.withlabel) {
                    this.label = JXG.elements.text(this.board, [0, 0, function () {
                        if (typeof that.name === &#x27;function&#x27;) {
                            return that.name();
                        }
                        return that.name;
                    }], attr);
                    this.label.needsUpdate = true;
                    this.label.update();

                    this.label.dump = false;

                    if (!this.visProp.visible) {
                        this.label.hiddenByParent = true;
                        this.label.visProp.visible = false;
                    }
                    this.hasLabel = true;
                }
            } else {
                JXG.debug(&#x27;JSXGraph: Can\&#x27;t create label: text element is not available. Make sure you include base/text&#x27;);
            }

            return this;
        },

        /**
         * Highlights the element.
         *
         * @method highlight
         * @param {Boolean} [force=false] Force the highlighting
         * @chainable
         */
        highlight: function (force) {
            force = Type.def(force, false);
            // I know, we have the JXG.Board.highlightedObjects AND JXG.GeometryElement.highlighted and YES we need both.
            // Board.highlightedObjects is for the internal highlighting and GeometryElement.highlighted is for user highlighting
            // initiated by the user, e.g. through custom DOM events. We can&#x27;t just pick one because this would break user
            // defined highlighting in many ways:
            //  * if overriding the highlight() methods the user had to handle the highlightedObjects stuff, otherwise he&#x27;d break
            //    everything (e.g. the pie chart example http://jsxgraph.uni-bayreuth.de/wiki/index.php/Pie_chart (not exactly
            //    user defined but for this type of chart the highlight method was overridden and not adjusted to the changes in here)
            //    where it just kept highlighting until the radius of the pie was far beyond infinity...
            //  * user defined highlighting would get pointless, everytime the user highlights something using .highlight(), it would get
            //    dehighlighted immediately, because highlight puts the element into highlightedObjects and from there it gets dehighlighted
            //    through dehighlightAll.

            // highlight only if not highlighted
            if (this.visProp.highlight &amp;&amp; (!this.highlighted || force)) {
                this.highlighted = true;
                this.board.highlightedObjects[this.id] = this;
                this.board.renderer.highlight(this);
            }
            return this;
        },

        /**
         * Uses the &quot;normal&quot; properties of the element.
         *
         * @method noHighlight
         * @chainable
         */
        noHighlight: function () {
            // see comment in JXG.GeometryElement.highlight()

            // dehighlight only if not highlighted
            if (this.highlighted) {
                this.highlighted = false;
                delete this.board.highlightedObjects[this.id];
                this.board.renderer.noHighlight(this);
            }
            return this;
        },

        /**
         * Removes all objects generated by the trace function.
         *
         * @method clearTrace
         * @chainable
         */
        clearTrace: function () {
            var obj;

            for (obj in this.traces) {
                if (this.traces.hasOwnProperty(obj)) {
                    this.board.renderer.remove(this.traces[obj]);
                }
            }

            this.numTraces = 0;
            return this;
        },

        /**
         * Copy the element to background. This is used for tracing elements.
         *
         * @method cloneToBackground
         * @chainable
         */
        cloneToBackground: function () {
            return this;
        },

        /**
         * Dimensions of the smallest rectangle enclosing the element.
         *
         * @method bounds
         * @return {Array} The coordinates of the enclosing rectangle in a format like the bounding box in {@link JXG.Board#setBoundingBox}.
         */
        bounds: function () {
            return [0, 0, 0, 0];
        },

        /**
         * Normalize the element&#x27;s standard form.
         *
         * @method normalize
         * @private
         * @chainable
         */
        normalize: function () {
            this.stdform = Mat.normalize(this.stdform);
            return this;
        },

        /**
         * EXPERIMENTAL. Generate JSON object code of visProp and other properties.
         *
         * @method toJSON
         * @type string
         * @private
         * @ignore
         * @return JSON string containing element&#x27;s properties.
         */
        toJSON: function () {
            var vis, key,
                json = [&#x27;{&quot;name&quot;:&#x27;, this.name];

            json.push(&#x27;, &#x27; + &#x27;&quot;id&quot;:&#x27; + this.id);

            vis = [];
            for (key in this.visProp) {
                if (this.visProp.hasOwnProperty(key)) {
                    if (Type.exists(this.visProp[key])) {
                        vis.push(&#x27;&quot;&#x27; + key + &#x27;&quot;:&#x27; + this.visProp[key]);
                    }
                }
            }
            json.push(&#x27;, &quot;visProp&quot;:{&#x27; + vis.toString() + &#x27;}&#x27;);
            json.push(&#x27;}&#x27;);

            return json.join(&#x27;&#x27;);
        },


        /**
         * Rotate texts or images by a given degree. Works only for texts where JXG.Text#display equal to &quot;internal&quot;.
         *
         * @method addRotation
         * @param {number} angle The degree of the rotation (90 means vertical text).
         * @see JXG.GeometryElement#rotate
         * @chainable
         */
        addRotation: function (angle) {
            var tOffInv, tOff, tS, tSInv, tRot,
                that = this;

            if (((this.elementClass === Const.OBJECT_CLASS_TEXT &amp;&amp; this.visProp.display === &#x27;internal&#x27;) ||
                    this.type === Const.OBJECT_TYPE_IMAGE) &amp;&amp; angle !== 0) {

                tOffInv = this.board.create(&#x27;transform&#x27;, [
                    function () {
                        return -that.X();
                    }, function () {
                        return -that.Y();
                    }
                ], {type: &#x27;translate&#x27;});

                tOff = this.board.create(&#x27;transform&#x27;, [
                    function () {
                        return that.X();
                    }, function () {
                        return that.Y();
                    }
                ], {type: &#x27;translate&#x27;});

                tS = this.board.create(&#x27;transform&#x27;, [
                    function () {
                        return that.board.unitX / that.board.unitY;
                    }, function () {
                        return 1;
                    }
                ], {type: &#x27;scale&#x27;});

                tSInv = this.board.create(&#x27;transform&#x27;, [
                    function () {
                        return that.board.unitY / that.board.unitX;
                    }, function () {
                        return 1;
                    }
                ], {type: &#x27;scale&#x27;});

                tRot = this.board.create(&#x27;transform&#x27;, [angle * Math.PI / 180], {type: &#x27;rotate&#x27;});

                tOffInv.bindTo(this);
                tS.bindTo(this);
                tRot.bindTo(this);
                tSInv.bindTo(this);
                tOff.bindTo(this);
            }

            return this;
        },

        /**
         * Set the highlightStrokeColor of an element
         *
         * @method highlightStrokeColor
         * @param {String} sColor String which determines the stroke color of an object when its highlighted.
         * @see JXG.GeometryElement#highlightStrokeColor
         * @deprecated Use {@link #setAttribute}
         * @chainable
         */
        highlightStrokeColor: function (sColor) {
            JXG.deprecated(&#x27;highlightStrokeColor()&#x27;, &#x27;setAttribute()&#x27;);
            this.setAttribute({highlightStrokeColor: sColor});
            return this;
        },

        /**
         * Set the strokeColor of an element
         *
         * @method strokeColor
         * @param {String} sColor String which determines the stroke color of an object.
         * @see JXG.GeometryElement#strokeColor
         * @deprecated Use {@link #setAttribute}
         * @chainable
         */
        strokeColor: function (sColor) {
            JXG.deprecated(&#x27;strokeColor()&#x27;, &#x27;setAttribute()&#x27;);
            this.setAttribute({strokeColor: sColor});
            return this;
        },

        /**
         * Set the strokeWidth of an element
         *
         * @method strokeWidth
         * @param {Number} width Integer which determines the stroke width of an outline.
         * @see JXG.GeometryElement#strokeWidth
         * @deprecated Use {@link #setAttribute}
         * @chainable
         */
        strokeWidth: function (width) {
            JXG.deprecated(&#x27;strokeWidth()&#x27;, &#x27;setAttribute()&#x27;);
            this.setAttribute({strokeWidth: width});
            return this;
        },


        /**
         * Set the fillColor of an element
         *
         * @method fillColor
         * @param {String} fColor String which determines the fill color of an object.
         * @see JXG.GeometryElement#fillColor
         * @deprecated Use {@link #setAttribute}
         * @chainable
         *
         */
        fillColor: function (fColor) {
            JXG.deprecated(&#x27;fillColor()&#x27;, &#x27;setAttribute()&#x27;);
            this.setAttribute({fillColor: fColor});
            return this;
        },

        /**
         * Set the highlightFillColor of an element
         *
         * @method highlightFillColor
         * @param {String} fColor String which determines the fill color of an object when its highlighted.
         * @see JXG.GeometryElement#highlightFillColor
         * @deprecated Use {@link #setAttribute}
         * @chainable
         */
        highlightFillColor: function (fColor) {
            JXG.deprecated(&#x27;highlightFillColor()&#x27;, &#x27;setAttribute()&#x27;);
            this.setAttribute({highlightFillColor: fColor});
            return this;
        },

        /**
         * Set the labelColor of an element
         *
         * @method labelColor
         * @param {String} lColor String which determines the text color of an object&#x27;s label.
         * @see JXG.GeometryElement#labelColor
         * @deprecated Use {@link #setAttribute}
         * @chainable
         */
        labelColor: function (lColor) {
            JXG.deprecated(&#x27;labelColor()&#x27;, &#x27;setAttribute()&#x27;);
            this.setAttribute({labelColor: lColor});
            return this;
        },

        /**
         * Set the dash type of an element
         *
         * @method dash
         * @param {Number} d Integer which determines the way of dashing an element&#x27;s outline.
         * @see JXG.GeometryElement#dash
         * @deprecated Use {@link #setAttribute}
         * @chainable
         */
        dash: function (d) {
            JXG.deprecated(&#x27;dash()&#x27;, &#x27;setAttribute()&#x27;);
            this.setAttribute({dash: d});
            return this;
        },

        /**
         * Set the visibility of an element
         *
         * @method visible
         * @param {Boolean} v Boolean which determines whether the element is drawn.
         * @see JXG.GeometryElement#visible
         * @deprecated Use {@link #setAttribute}
         * @chainable
         */
        visible: function (v) {
            JXG.deprecated(&#x27;visible()&#x27;, &#x27;setAttribute()&#x27;);
            this.setAttribute({visible: v});
            return this;
        },

        /**
         * Set the shadow of an element
         *
         * @method shadow
         * @param {Boolean} s Boolean which determines whether the element has a shadow or not.
         * @see JXG.GeometryElement#shadow
         * @deprecated Use {@link #setAttribute}
         * @chainable
         */
        shadow: function (s) {
            JXG.deprecated(&#x27;shadow()&#x27;, &#x27;setAttribute()&#x27;);
            this.setAttribute({shadow: s});
            return this;
        },

        /**
         * The type of the element as used in {@link JXG.Board#create}.
         *
         * @method getTpye
         * @return {String}
         */
        getType: function () {
            return this.elType;
        },

        /**
         * List of the element ids resp. values used as parents in {@link JXG.Board#create}.
         *
         * @method getParents
         * @return {Array}
         */
        getParents: function () {
            return Type.isArray(this.parents) ? this.parents : [];
        },

        /**
         * Snaps the element to the grid. Only works for points, lines and circles. Points will snap to the grid
         * as defined in their properties {@link JXG.Point#snapSizeX} and {@link JXG.Point#snapSizeY}. Lines and circles
         * will snap their parent points to the grid, if they have {@link JXG.Point#snapToGrid} set to true.
         *
         * @method snapToGrid
         * @return {JXG.GeometryElement} Reference to the element.
         * @chainable
         */
        snapToGrid: function () {
            return this;
        },

        /**
         * Snaps the element to points. Only works for points. Points will snap to the next point
         * as defined in their properties {@link JXG.Point#attractorDistance} and {@link JXG.Point#attractorUnit}.
         * Lines and circles
         * will snap their parent points to points.
         *
         * @method snapToPoints
         * @return {JXG.GeometryElement} Reference to the element.
         * @chainable
         */
        snapToPoints: function () {
            return this;
        },

        /**
         * Retrieve a copy of the current visProp.
         *
         * @method getAttributes
         * @return {Object}
         */
        getAttributes: function () {
            var attributes = Type.deepCopy(this.visProp),
                cleanThis = [&#x27;attractors&#x27;, &#x27;snatchdistance&#x27;, &#x27;traceattributes&#x27;, &#x27;frozen&#x27;,
                    &#x27;shadow&#x27;, &#x27;gradientangle&#x27;, &#x27;gradientsecondopacity&#x27;, &#x27;gradientpositionx&#x27;, &#x27;gradientpositiony&#x27;,
                    &#x27;needsregularupdate&#x27;, &#x27;zoom&#x27;, &#x27;layer&#x27;, &#x27;offset&#x27;],
                i, len = cleanThis.length;

            attributes.id = this.id;
            attributes.name = this.name;

            for (i = 0; i &lt; len; i++) {
                delete attributes[cleanThis[i]];
            }

            return attributes;
        },

        /**
         * Checks whether (x,y) is near the element.
         *
         * @method hasPoint
         * @param {Number} x Coordinate in x direction, screen coordinates.
         * @param {Number} y Coordinate in y direction, screen coordinates.
         * @return {Boolean} True if (x,y) is near the element, False otherwise.
         */
        hasPoint: function (x, y) {
            return false;
        },

        /**
         * Move an element to its nearest grid point.
         * The function uses the coords object of the element as
         * its actual position. If there is no coords object, nothing is done.
         *
         * @method handleSnapToGrid
         * @param {Boolean} force force snapping independent from what the snaptogrid attribute says
         * @return {JXG.GeometryElement} Reference to this element
         * @chainable
         */
        handleSnapToGrid: function (force) {
            var x, y, ticks,
                i, len, g, el, p, boardBB,
                needsSnapToGrid = false,
                sX = this.visProp.snapsizex,
                sY = this.visProp.snapsizey;

            if (!JXG.exists(this.coords)) {
                return this;
            }

            needsSnapToGrid = this.visProp.snaptogrid || force === true;

            // Test if in any of the groups this element is member of
            // there is an element with snaptogrid == true.
            /*
            if (!needsSnapToGrid &amp;&amp; Type.exists(this.groups)) {
                len = this.groups.length;
                for (i = 0; i &lt; len; ++i) {
                    g = this.board.groups[this.groups[i]];
                    for (el in g.objects) {
                        if (g.objects.hasOwnProperty(el)) {
                            if (g.objects[el].point.visProp.snaptogrid) {
                                needsSnapToGrid = true;
                                // Leave both loops immediately
                                i = len;
                                break;
                            }
                        }
                    }
                }
            }
            */

            if (needsSnapToGrid) {
                x = this.coords.usrCoords[1];
                y = this.coords.usrCoords[2];

                if (sX &lt;= 0 &amp;&amp; this.board.defaultAxes &amp;&amp; this.board.defaultAxes.x.defaultTicks) {
                    ticks = this.board.defaultAxes.x.defaultTicks;
                    sX = ticks.ticksDelta * (ticks.visProp.minorticks + 1);
                }

                if (sY &lt;= 0 &amp;&amp; this.board.defaultAxes &amp;&amp; this.board.defaultAxes.y.defaultTicks) {
                    ticks = this.board.defaultAxes.y.defaultTicks;
                    sY = ticks.ticksDelta * (ticks.visProp.minorticks + 1);
                }

                // if no valid snap sizes are available, don&#x27;t change the coords.
                if (sX &gt; 0 &amp;&amp; sY &gt; 0) {
                    boardBB = this.board.getBoundingBox();
                    x = Math.round(x / sX) * sX;
                    y = Math.round(y / sY) * sY;

                    // checking whether x and y are still within boundingBox,
                    // if not, adjust them to remain within the board
                    if (x &lt; boardBB[0]) {
                        x += sX;
                    } else if (x &gt; boardBB[2]) {
                        x -= sX;
                    }

                    if (y &lt; boardBB[3]) {
                        y += sY;
                    } else if (y &gt; boardBB[1]) {
                        y -= sY;
                    }

                    this.coords.setCoordinates(Const.COORDS_BY_USER, [x, y]);
                }
            }
            return this;
        },

        /**
         * Alias of {@link JXG.GeometryElement#on}.
         */
        addEvent: JXG.shortcut(JXG.GeometryElement.prototype, &#x27;on&#x27;),

        /**
         * Alias of {@link JXG.GeometryElement#off}.
         */
        removeEvent: JXG.shortcut(JXG.GeometryElement.prototype, &#x27;off&#x27;),

        /* **************************
         *     EVENT DEFINITION
         * for documentation purposes
         * ************************** */

        //region Event handler documentation
        /**
         * This event is fired whenever the user is hovering over an element.
         * @event over
         * @param {Event} e The browser&#x27;s event object.
         */
        __evt__over: function (e) { },

        /**
         * This event is fired whenever the user puts the mouse over an element.
         * @event mouseover
         * @param {Event} e The browser&#x27;s event object.
         */
        __evt__mouseover: function (e) { },

        /**
         *
         * This event is fired whenever the user is leaving an element.
         * @event out
         * @param {Event} e The browser&#x27;s event object.
         */
        __evt__out: function (e) { },

        /**
         * This event is fired whenever the user puts the mouse away from an element.
         * @event mouseout
         * @param {Event} e The browser&#x27;s event object.
         */
        __evt__mouseout: function (e) { },

        /**
         * This event is fired whenever the user is moving over an element.
         * @event move
         * @param {Event} e The browser&#x27;s event object.
         */
        __evt__move: function (e) { },

        /**
         * This event is fired whenever the user is moving the mouse over an element.
         * @event mousemove
         * @param {Event} e The browser&#x27;s event object.
         */
        __evt__mousemove: function (e) { },

        /**
         * This event is fired whenever the user drags an element.
         * @event drag
         * @param {Event} e The browser&#x27;s event object.
         */
        __evt__drag: function (e) { },

        /**
         * This event is fired whenever the user drags the element with a mouse.
         * @event mousedrag
         * @param {Event} e The browser&#x27;s event object.
         */
        __evt__mousedrag: function (e) { },

        /**
         * This event is fired whenever the user drags the element on a touch device.
         * @event touchdrag
         * @param {Event} e The browser&#x27;s event object.
         */
        __evt__touchdrag: function (e) { },

        /**
         * Whenever the user starts to touch or click an element.
         * @event down
         * @param {Event} e The browser&#x27;s event object.
         */
        __evt__down: function (e) { },

        /**
         * Whenever the user starts to click an element.
         * @event mousedown
         * @param {Event} e The browser&#x27;s event object.
         */
        __evt__mousedown: function (e) { },

        /**
         * Whenever the user starts to touch an element.
         * @event touchdown
         * @param {Event} e The browser&#x27;s event object.
         */
        __evt__touchdown: function (e) { },

        /**
         * Whenever the user stops to touch or click an element.
         * @event up
         * @param {Event} e The browser&#x27;s event object.
         */
        __evt__up: function (e) { },

        /**
         * Whenever the user releases the mousebutton over an element.
         * @event mouseup
         * @param {Event} e The browser&#x27;s event object.
         */
        __evt__mouseup: function (e) { },

        /**
         * Whenever the user stops touching an element.
         * @event touchup
         * @param {Event} e The browser&#x27;s event object.
         */
        __evt__touchup: function (e) {},

        /**
         * Notify everytime an attribute is changed.
         * @event attribute
         * @param {Object} o A list of changed attributes and their new value.
         * @param {Object} el Reference to the element
         */
        __evt__attribute: function (o, el) {},

        /**
         * This is a generic event handler. It exists for every possible attribute that can be set for
         * any element, e.g. if you want to be notified everytime an element&#x27;s strokecolor is changed, is the event
         * &lt;tt&gt;attribute:strokecolor&lt;/tt&gt;.
         * @event attribute:&lt;attribute&gt;
         * @param val The old value.
         * @param nval The new value
         * @param {Object} el Reference to the element
         */
        __evt__attribute_: function (val, nval, el) {},

        /**
         * @ignore
         */
        __evt: function () {}
        //endregion

    });

    return JXG.GeometryElement;
});

    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>

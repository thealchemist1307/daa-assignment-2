<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src/reader/sketch.js - JSXGraph</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="../assets/js/jsxgraphcore.js"></script>
    <link rel="stylesheet" href="../assets/css/jsxgraph.css">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../assets/css/logo_blue.png" title="JSXGraph" width="117" height="52"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.99.4</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/Angle.html">Angle</a> </li>
                                <li><a href="../classes/Arc.html">Arc</a> </li>
                                <li><a href="../classes/Arrow.html">Arrow</a> </li>
                                <li><a href="../classes/Arrowparallel.html">Arrowparallel</a> </li>
                                <li><a href="../classes/Axis.html">Axis</a> </li>
                                <li><a href="../classes/Bisector.html">Bisector</a> </li>
                                <li><a href="../classes/Bisectorlines.html">Bisectorlines</a> </li>
                                <li><a href="../classes/Button.html">Button</a> </li>
                                <li><a href="../classes/Checkbox.html">Checkbox</a> </li>
                                <li><a href="../classes/Circle.html">Circle</a> </li>
                                <li><a href="../classes/Circumcenter.html">Circumcenter</a> </li>
                                <li><a href="../classes/Circumcircle.html">Circumcircle</a> </li>
                                <li><a href="../classes/CircumcircleArc.html">CircumcircleArc</a> </li>
                                <li><a href="../classes/CircumcircleSector.html">CircumcircleSector</a> </li>
                                <li><a href="../classes/Conic.html">Conic</a> </li>
                                <li><a href="../classes/Curve.html">Curve</a> </li>
                                <li><a href="../classes/Ellipse.html">Ellipse</a> </li>
                                <li><a href="../classes/EventEmitter.html">EventEmitter</a> </li>
                                <li><a href="../classes/Functiongraph.html">Functiongraph</a> </li>
                                <li><a href="../classes/Glider.html">Glider</a> </li>
                                <li><a href="../classes/Grid.html">Grid</a> </li>
                                <li><a href="../classes/Group.html">Group</a> </li>
                                <li><a href="../classes/Hatch.html">Hatch</a> </li>
                                <li><a href="../classes/Hyperbola.html">Hyperbola</a> </li>
                                <li><a href="../classes/Image.html">Image</a> </li>
                                <li><a href="../classes/Incenter.html">Incenter</a> </li>
                                <li><a href="../classes/Incircle.html">Incircle</a> </li>
                                <li><a href="../classes/Inequality.html">Inequality</a> </li>
                                <li><a href="../classes/Input.html">Input</a> </li>
                                <li><a href="../classes/Integral.html">Integral</a> </li>
                                <li><a href="../classes/Intersection.html">Intersection</a> </li>
                                <li><a href="../classes/JXG.html">JXG</a> </li>
                                <li><a href="../classes/JXG.AbstractRenderer.html">JXG.AbstractRenderer</a> </li>
                                <li><a href="../classes/JXG.Board.html">JXG.Board</a> </li>
                                <li><a href="../classes/JXG.C.html">JXG.C</a> </li>
                                <li><a href="../classes/JXG.CanvasRenderer.html">JXG.CanvasRenderer</a> </li>
                                <li><a href="../classes/JXG.Chart.html">JXG.Chart</a> </li>
                                <li><a href="../classes/JXG.Circle.html">JXG.Circle</a> </li>
                                <li><a href="../classes/JXG.Complex.html">JXG.Complex</a> </li>
                                <li><a href="../classes/JXG.Composition.html">JXG.Composition</a> </li>
                                <li><a href="../classes/JXG.Coords.html">JXG.Coords</a> </li>
                                <li><a href="../classes/JXG.CoordsElement.html">JXG.CoordsElement</a> </li>
                                <li><a href="../classes/JXG.Curve.html">JXG.Curve</a> </li>
                                <li><a href="../classes/JXG.GeometryElement.html">JXG.GeometryElement</a> </li>
                                <li><a href="../classes/JXG.Group.html">JXG.Group</a> </li>
                                <li><a href="../classes/JXG.Image.html">JXG.Image</a> </li>
                                <li><a href="../classes/JXG.JSXGraph.html">JXG.JSXGraph</a> </li>
                                <li><a href="../classes/JXG.Line.html">JXG.Line</a> </li>
                                <li><a href="../classes/JXG.Math.html">JXG.Math</a> </li>
                                <li><a href="../classes/JXG.Math.Geometry.html">JXG.Math.Geometry</a> </li>
                                <li><a href="../classes/JXG.Math.Numerics.html">JXG.Math.Numerics</a> </li>
                                <li><a href="../classes/JXG.Math.Poly.html">JXG.Math.Poly</a> </li>
                                <li><a href="../classes/JXG.Math.Poly.Monomial.html">JXG.Math.Poly.Monomial</a> </li>
                                <li><a href="../classes/JXG.Math.Poly.Polynomial.html">JXG.Math.Poly.Polynomial</a> </li>
                                <li><a href="../classes/JXG.Math.Poly.Ring.html">JXG.Math.Poly.Ring</a> </li>
                                <li><a href="../classes/JXG.Math.Quadtree.html">JXG.Math.Quadtree</a> </li>
                                <li><a href="../classes/JXG.Math.Statistics.html">JXG.Math.Statistics</a> </li>
                                <li><a href="../classes/JXG.Math.Symbolic.html">JXG.Math.Symbolic</a> </li>
                                <li><a href="../classes/JXG.NoRenderer.html">JXG.NoRenderer</a> </li>
                                <li><a href="../classes/JXG.Options.html">JXG.Options</a> </li>
                                <li><a href="../classes/JXG.Point.html">JXG.Point</a> </li>
                                <li><a href="../classes/JXG.Polygon.html">JXG.Polygon</a> </li>
                                <li><a href="../classes/JXG.SVGRenderer.html">JXG.SVGRenderer</a> </li>
                                <li><a href="../classes/JXG.Text.html">JXG.Text</a> </li>
                                <li><a href="../classes/JXG.Ticks.html">JXG.Ticks</a> </li>
                                <li><a href="../classes/JXG.Transformation.html">JXG.Transformation</a> </li>
                                <li><a href="../classes/JXG.Turtle.html">JXG.Turtle</a> </li>
                                <li><a href="../classes/JXG.Util.Base64.html">JXG.Util.Base64</a> </li>
                                <li><a href="../classes/JXG.Util.Unzip.html">JXG.Util.Unzip</a> </li>
                                <li><a href="../classes/JXG.VMLRenderer.html">JXG.VMLRenderer</a> </li>
                                <li><a href="../classes/Line.html">Line</a> </li>
                                <li><a href="../classes/Locus.html">Locus</a> </li>
                                <li><a href="../classes/MajorArc.html">MajorArc</a> </li>
                                <li><a href="../classes/Midpoint.html">Midpoint</a> </li>
                                <li><a href="../classes/MinorArc.html">MinorArc</a> </li>
                                <li><a href="../classes/MinorSector.html">MinorSector</a> </li>
                                <li><a href="../classes/Mirrorpoint.html">Mirrorpoint</a> </li>
                                <li><a href="../classes/NonReflexAngle.html">NonReflexAngle</a> </li>
                                <li><a href="../classes/Normal.html">Normal</a> </li>
                                <li><a href="../classes/Orthogonalprojection.html">Orthogonalprojection</a> </li>
                                <li><a href="../classes/OtherIntersection.html">OtherIntersection</a> </li>
                                <li><a href="../classes/Parabola.html">Parabola</a> </li>
                                <li><a href="../classes/Parallel.html">Parallel</a> </li>
                                <li><a href="../classes/Parallelpoint.html">Parallelpoint</a> </li>
                                <li><a href="../classes/Perpendicular.html">Perpendicular</a> </li>
                                <li><a href="../classes/PerpendicularPoint.html">PerpendicularPoint</a> </li>
                                <li><a href="../classes/PerpendicularSegment.html">PerpendicularSegment</a> </li>
                                <li><a href="../classes/Point.html">Point</a> </li>
                                <li><a href="../classes/PolarLine.html">PolarLine</a> </li>
                                <li><a href="../classes/PolePoint.html">PolePoint</a> </li>
                                <li><a href="../classes/Polygon.html">Polygon</a> </li>
                                <li><a href="../classes/RadicalAxis.html">RadicalAxis</a> </li>
                                <li><a href="../classes/Reflection.html">Reflection</a> </li>
                                <li><a href="../classes/ReflexAngle.html">ReflexAngle</a> </li>
                                <li><a href="../classes/registerReader.html">registerReader</a> </li>
                                <li><a href="../classes/RegularPolygon.html">RegularPolygon</a> </li>
                                <li><a href="../classes/Riemannsum.html">Riemannsum</a> </li>
                                <li><a href="../classes/Sector.html">Sector</a> </li>
                                <li><a href="../classes/Segment.html">Segment</a> </li>
                                <li><a href="../classes/Semicircle.html">Semicircle</a> </li>
                                <li><a href="../classes/Slider.html">Slider</a> </li>
                                <li><a href="../classes/Slopetriangle.html">Slopetriangle</a> </li>
                                <li><a href="../classes/Spline.html">Spline</a> </li>
                                <li><a href="../classes/Stepfunction.html">Stepfunction</a> </li>
                                <li><a href="../classes/Tangent.html">Tangent</a> </li>
                                <li><a href="../classes/Tapemeasure.html">Tapemeasure</a> </li>
                                <li><a href="../classes/Text.html">Text</a> </li>
                                <li><a href="../classes/Ticks.html">Ticks</a> </li>
                                <li><a href="../classes/Tracecurve.html">Tracecurve</a> </li>
                                <li><a href="../classes/Transformation.html">Transformation</a> </li>
                                <li><a href="../classes/Turtle.html">Turtle</a> </li>
                            </ul>
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="../modules/JXG.html">JXG</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: src/reader/sketch.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/*
 Copyright 2008-2015
 Matthias Ehmann,
 Michael Gerhaeuser,
 Carsten Miller,
 Bianca Valentin,
 Heiko Vogel,
 Alfred Wassermann,
 Peter Wilfahrt

 This file is part of JSXGraph.

 JSXGraph is free software dual licensed under the GNU LGPL or MIT License.

 You can redistribute it and/or modify it under the terms of the

 * GNU Lesser General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version
 OR
 * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT

 JSXGraph is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU Lesser General Public License for more details.

 You should have received a copy of the GNU Lesser General Public License and
 the MIT License along with JSXGraph. If not, see &lt;http://www.gnu.org/licenses/&gt;
 and &lt;http://opensource.org/licenses/MIT/&gt;.
 */

/*global JXG: true*/
/*jslint nomen: true, plusplus: true*/

/* depends:
 jxg
 base/constants
 math/math
 options
 utils/zip
 utils/encoding
 utils/base64
 utils/uuid
 utils/type
 */

(function () {

    &quot;use strict&quot;;

    // this is a small workaround to adapt the SketchReader to our new file API
    // we don&#x27;t have to change anything in sketchometry.
    JXG.SketchReader = function (board, str) {
        this.read = function () {
            var i, t, arr, unzipped, meta, constr;

            unzipped = new JXG.Util.Unzip(JXG.Util.Base64.decodeAsArray(str)).unzip();

            if (!JXG.exists(unzipped[0])) {
                return &#x27;&#x27;;
            }

            unzipped = JXG.Util.UTF8.decode(unzipped[0][0]);
            //constr = JSON.parse(unzipped);
            constr = jQuery.parseJSON(unzipped);

            meta = constr.pop();

            if (!JXG.exists(meta.unredo)) {
                t = constr.length - 1;
            } else {
                t = meta.unredo;
            }
            
            for (i = 0; i &lt;= t; i++) {
                if (constr[i].type !== 0) {
                    try {
                        if (constr[i].type &gt; 50) {
                            arr = JXG.SketchReader.generateJCodeMeta(constr[i], board);
                        } else {
                            arr = JXG.SketchReader.generateJCode(constr[i], board, constr);
                        }
                    } catch (e) {
                        JXG.debug(&#x27;#steps: &#x27; + constr.length);
                        JXG.debug(&#x27;step: &#x27; + i + &#x27;, type: &#x27; + constr[i].type);
                        JXG.debug(constr[i]);
                    }

                    board.jc.parse(arr[0], true);
                }
            }

            // bounding box
            arr = meta.boundingBox;
            board.jc.parse(&#x27;$board.setView(&#x27; + JSON.stringify(arr) + &#x27;);&#x27;);

            return &#x27;&#x27;;
        };
    };

    // No prototype here
    JXG.extend(JXG.SketchReader, /** @lends JXG.SketchReader */ {
        generateJCodeMeta: function () {
            return [&#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;];
        },

        id: function () {
            return JXG.Util.genUUID();
        },

        generator: {
            toFixed: 8, // should be enough for now ...
            freeLine: false,
            useGlider: false,
            useSymbols: false
        },

        /**
         * Generates {@link JXG.JessieCode} code from a sketchometry construction step.
         * @param {Object} step
         * @param {Number} step.type One of the JXG.GENTYPE_* constant values
         * @param {Array} step.args Mostly visual properties
         * @param {Array} step.src_ids Parent element ids
         * @param {Array} step.dest_sub_ids Ids for subelements, e.g. the center of a circumcircle or the baseline
         * of a glider
         * @param {String} step.dest_id Id of the generated main element
         * @param {JXG.Board} board
         * @param {Array} step_log The complete step log
         * @return {Array} JessieCode to set and reset the step.
         */
        generateJCode: function (step, board, step_log) {
            var i, j, k, sub_id, str, str1, str2, objects, pid1, pid2, pid3,
                xstart, ystart, el, arr, step2, options, assign, attrid,
                copy_log = [],
                set_str = &#x27;&#x27;,
                reset_str = &#x27;&#x27;,
                ctx_set_str = &#x27;&#x27;,
                ctx_reset_str = &#x27;&#x27;,

            // these two could be outsourced into the iife surrounding the SketchReader definition

            // print number -- helper to prepare numbers
            // for printing, e.g. trim them with toFixed()
                pn = function (v) {
                    if (options.toFixed &gt; 0) {
                        // toFixed is a method if Number since JavaScript 1.5, resp. ECMAScript (ECMA 262) 3rd Edition
                        // introduced somewhat around 1999/2000. It is part of every recent version of every major browser.
                        // See this table: http://en.wikipedia.org/wiki/JavaScript#Versions
                        // The only possible explanation is that v might not be a number but a string or something else.
                        // In that case the caller should be fixed instead of rendering this function completely useless.

                        // make sure v is a float (or NaN if it neither is a float nor could be converted to float).
                        v = parseFloat(v);
                        v = v.toFixed(options.toFixed); // toFixed is not a member function of the Number class ...
                    }

                    return v;
                },

                getObject = function (v) {
                    var o;

                    if (options.useSymbols) {
                        if (board.jc.scope.locals[v]) {
                            o = board.jc.scope.locals[v];
                        } else {
                            o = objects[v];
                        }
                    } else {
                        o = objects[v];
                    }

                    return o;
                };



            options = JXG.SketchReader.generator;
            objects = board.objects;

            assign = &#x27;&#x27;;
            attrid = &#x27;id: \&#x27;&#x27; + step.dest_id + &#x27;\&#x27;, &#x27;;

            if (JXG.exists(board) &amp;&amp; options.useSymbols &amp;&amp; step.type !== JXG.GENTYPE_ABLATION) {
                attrid = &#x27;&#x27;;
                assign = step.dest_id + &#x27; = &#x27;;

                for (i = 0; i &lt; step.src_ids.length; i++) {
                    str = board.jc.findSymbol(getObject(step.src_ids[i]), 0);

                    if (str.length &gt; 0) {
                        step.src_ids[i] = str[0];
                    }
                }
            }

            if (step.type &gt; 50) {
                return JXG.SketchReader.generateJCodeMeta(step, board);
            }

            switch (step.type) {

                case JXG.GENTYPE_TRUNCATE:
                    set_str = &#x27;trunclen = &#x27; + JXG.Options.trunclen + &#x27;; &#x27;;
                    break;

                case JXG.GENTYPE_JCODE:
                    set_str = step.args.code;
                    break;

                case JXG.GENTYPE_AXIS:
                    set_str = step.args.name[0] + &#x27; = point(&#x27; + step.args.coords[0].usrCoords[1] + &#x27;, &#x27;;
                    set_str += step.args.coords[0].usrCoords[2] + &#x27;) &lt;&lt;id: \&#x27;&#x27; + step.dest_sub_ids[0] + &#x27;\&#x27;, name: \&#x27;&#x27;;
                    set_str += step.args.name[0] + &#x27;\&#x27;, fixed: true, priv: true, visible: false&gt;&gt;; &#x27; + step.args.name[1];
                    set_str += &#x27; = point(&#x27; + step.args.coords[1].usrCoords[1] + &#x27;, &#x27;;
                    set_str += step.args.coords[1].usrCoords[2] + &#x27;) &lt;&lt;id: \&#x27;&#x27; + step.dest_sub_ids[1] + &#x27;\&#x27;, name: \&#x27;&#x27;;
                    set_str += step.args.name[1] + &#x27;\&#x27;, fixed: true, priv: true, visible: false&gt;&gt;; &#x27; + step.args.name[2];
                    set_str += &#x27; = point(&#x27; + step.args.coords[2].usrCoords[1] + &#x27;, &#x27;;
                    set_str += step.args.coords[2].usrCoords[2] + &#x27;) &lt;&lt;id: \&#x27;&#x27; + step.dest_sub_ids[2] + &#x27;\&#x27;, name: \&#x27;&#x27;;
                    set_str += step.args.name[2] + &#x27;\&#x27;, fixed: true, priv: true, visible: false&gt;&gt;; &#x27;;

                    // x-axis
                    set_str += step.args.name[3] + &#x27; = axis(&#x27; + step.args.name[0] + &#x27;, &#x27; + step.args.name[1] + &#x27;) &#x27;;
                    set_str += &#x27;&lt;&lt;id: \&#x27;&#x27; + step.dest_sub_ids[3] + &#x27;\&#x27;, name: \&#x27;&#x27; + step.args.name[3] + &#x27;\&#x27;, ticks: &#x27;;
                    set_str += &#x27;&lt;&lt;minorHeight:0, majorHeight:10, insertTicks: true, ticksDistance: 1, drawLabels: true&#x27;;
                    set_str += &#x27;, label: &lt;&lt;offset: [-4, -16], parse: false, display: &quot;internal&quot;&gt;&gt;&#x27;;
                    set_str += &#x27;, drawZero: false&gt;&gt;&gt;&gt;; &#x27;;
                    
                    // y-axis
                    set_str += step.args.name[4] + &#x27; = axis(&#x27; + step.args.name[0] + &#x27;, &#x27; + step.args.name[2] + &#x27;) &#x27;;
                    set_str += &#x27;&lt;&lt;id: \&#x27;&#x27; + step.dest_sub_ids[4] + &#x27;\&#x27;, name: \&#x27;&#x27; + step.args.name[4] + &#x27;\&#x27;, ticks: &#x27;;
                    set_str += &#x27;&lt;&lt;minorHeight:0, majorHeight:10, insertTicks: true, ticksDistance: 1, drawLabels: true&#x27;;
                    set_str += &#x27;, label: &lt;&lt;offset: [10, 0], parse: false, display: &quot;internal&quot;&gt;&gt;&#x27;;
                    set_str += &#x27;, drawZero: false&gt;&gt;&gt;&gt;; &#x27;;

                    set_str += step.dest_sub_ids[3] + &#x27;.visible = false; &#x27;;
                    set_str += step.dest_sub_ids[4] + &#x27;.visible = false; &#x27;;

                    set_str += &#x27;delete jxgBoard1_infobox; &#x27;;

                    reset_str = &#x27;delete &#x27; + step.dest_sub_ids[4] + &#x27;; delete &#x27; + step.dest_sub_ids[3];
                    reset_str += &#x27;; delete &#x27; + step.dest_sub_ids[2] + &#x27;; &#x27;;
                    reset_str += &#x27;delete &#x27; + step.dest_sub_ids[1] + &#x27;; delete &#x27; + step.dest_sub_ids[0] + &#x27;; &#x27;;

                    break;

                case JXG.GENTYPE_MID:
                    set_str = assign + &#x27;midpoint(&#x27; + step.src_ids[0] + &#x27;, &#x27; + step.src_ids[1] + &#x27;) &lt;&lt;&#x27; + attrid;
                    set_str += &#x27;fillColor: \&#x27;&#x27; + step.args.fillColor + &#x27;\&#x27;&#x27;;
                    if (JXG.exists(step.args.strokeColor)) {
                        set_str += &#x27;, strokeColor: \&#x27;&#x27; + step.args.strokeColor + &#x27;\&#x27;&#x27;;
                    }
                    set_str += &#x27;&gt;&gt;; &#x27;;
                    reset_str = &#x27;delete &#x27; + step.dest_id + &#x27;; &#x27;;
                    break;

                case JXG.GENTYPE_REFLECTION:
                    set_str = assign + &#x27;reflection(&#x27; + step.src_ids[0] + &#x27;, &#x27; + step.src_ids[1] + &#x27;) &lt;&lt;&#x27; + attrid;
                    set_str += &#x27;fillColor: \&#x27;&#x27; + step.args.fillColor + &#x27;\&#x27;&#x27;;
                    if (JXG.exists(step.args.strokeColor)) {
                        set_str += &#x27;, strokeColor: \&#x27;&#x27; + step.args.strokeColor + &#x27;\&#x27;&#x27;;
                        set_str += &#x27;, opacity: \&#x27;&#x27; + step.args.opacity + &#x27;\&#x27;&#x27;;
                    }
                    set_str += &#x27;, name: &quot;&#x27; + step.args.name + &#x27;&quot;&gt;&gt;; &#x27;;
                    reset_str = &#x27;delete &#x27; + step.dest_id + &#x27;; &#x27;;
                    break;

                case JXG.GENTYPE_MIRRORPOINT:
                    set_str = assign + &#x27;mirrorpoint(&#x27; + step.src_ids[1] + &#x27;, &#x27; + step.src_ids[0] + &#x27;) &lt;&lt;&#x27; + attrid;
                    set_str += &#x27;fillColor: \&#x27;&#x27; + step.args.fillColor + &#x27;\&#x27;&#x27;;
                    if (JXG.exists(step.args.strokeColor)) {
                        set_str += &#x27;, strokeColor: \&#x27;&#x27; + step.args.strokeColor + &#x27;\&#x27;&#x27;;
                        set_str += &#x27;, opacity: \&#x27;&#x27; + step.args.opacity + &#x27;\&#x27;&#x27;;
                    }
                    set_str += &#x27;, name: &quot;&#x27; + step.args.name + &#x27;&quot;&gt;&gt;; &#x27;;
                    reset_str = &#x27;delete &#x27; + step.dest_id + &#x27;; &#x27;;
                    break;

                case JXG.GENTYPE_TANGENT:
                    if (step.args.create_point) {
                        sub_id = step.dest_sub_ids[2];
                        set_str = &#x27;point(&#x27; + pn(step.args.usrCoords[1]) + &#x27;,&#x27; + pn(step.args.usrCoords[2]) + &#x27;) &lt;&lt;id: \&#x27;&#x27;;
                        set_str += sub_id + &#x27;\&#x27;, fillColor: \&#x27;&#x27; + step.args.fillColor + &#x27;\&#x27;&#x27;;
                        if (JXG.exists(step.args.strokeColor)) {
                            set_str += &#x27;, strokeColor: \&#x27;&#x27; + step.args.strokeColor + &#x27;\&#x27;&#x27;;
                        }
                        set_str += &#x27;&gt;&gt;; &#x27; + sub_id + &#x27;.glide(&#x27;;
                        set_str += step.src_ids[0] + &#x27;); &#x27;;
                        reset_str = &#x27;delete &#x27; + sub_id + &#x27;; &#x27;;
                    } else {
                        sub_id = step.src_ids[0];
                    }

                    set_str += assign + &#x27;tangent(&#x27; + sub_id + &#x27;) &lt;&lt;&#x27; + attrid + &#x27;point1: &lt;&lt;name: \&#x27;&#x27; + step.dest_sub_ids[0];
                    set_str += &#x27;\&#x27;, id: \&#x27;&#x27; + step.dest_sub_ids[0] + &#x27;\&#x27;, priv: true&gt;&gt;, point2: &lt;&lt;name: \&#x27;&#x27; + step.dest_sub_ids[1];
                    set_str += &#x27;\&#x27;, id: \&#x27;&#x27; + step.dest_sub_ids[1] + &#x27;\&#x27;, priv: true&gt;&gt; &gt;&gt;; &#x27;;
                    reset_str = &#x27;delete &#x27; + step.dest_sub_ids[0] + &#x27;; &#x27; + reset_str;
                    reset_str = &#x27;delete &#x27; + step.dest_id + &#x27;; delete &#x27; + step.dest_sub_ids[1] + &#x27;; &#x27; + reset_str;
                    break;

                case JXG.GENTYPE_PARALLEL:
                    if (step.args.create_point) {
                        sub_id = step.dest_sub_ids[1];
                        set_str = &#x27;point(&#x27; + pn(step.args.usrCoords[1]) + &#x27;, &#x27; + pn(step.args.usrCoords[2]) + &#x27;) &lt;&lt;id: \&#x27;&#x27;;
                        set_str += sub_id + &#x27;\&#x27;, name: \&#x27;\&#x27;, visible: false, priv: true&gt;&gt;; &#x27;;
                        reset_str = &#x27;delete &#x27; + sub_id + &#x27;; &#x27;;
                    } else {
                        sub_id = step.src_ids[1];
                    }

                    set_str += assign + &#x27;parallel(&#x27; + step.src_ids[0] + &#x27;, &#x27; + sub_id + &#x27;) &lt;&lt;&#x27; + attrid + &#x27;name: \&#x27;\&#x27;, point: &lt;&lt;id: \&#x27;&#x27;;
                    set_str += step.dest_sub_ids[0] + &#x27;\&#x27;, name: \&#x27;&#x27; + step.dest_sub_ids[0] + &#x27;\&#x27;&gt;&gt; &gt;&gt;; &#x27;;
                    reset_str = &#x27;delete &#x27; + step.dest_id + &#x27;; delete &#x27; + step.dest_sub_ids[0] + &#x27;; &#x27; + reset_str;
                    break;

                case JXG.GENTYPE_BISECTORLINES:
                    set_str = &#x27;bisectorlines(&#x27; + step.src_ids[0] + &#x27;, &#x27; + step.src_ids[1] + &#x27;) &lt;&lt;line1: &lt;&lt;id: \&#x27;&#x27;;
                    set_str = set_str + step.dest_sub_ids[2] + &#x27;\&#x27;, point1: &lt;&lt;id: \&#x27;&#x27; + step.dest_sub_ids[1];
                    set_str += &#x27;\&#x27;, name: \&#x27;&#x27; + step.dest_sub_ids[1] + &#x27;\&#x27;&gt;&gt;, point2: &lt;&lt;id: \&#x27;&#x27; + step.dest_sub_ids[0];
                    set_str += &#x27;\&#x27;, name: \&#x27;&#x27; + step.dest_sub_ids[0] + &#x27;\&#x27;&gt;&gt;&gt;&gt;, line2: &lt;&lt;id: \&#x27;&#x27; + step.dest_sub_ids[5];
                    set_str += &#x27;\&#x27;, point1: &lt;&lt;id: \&#x27;&#x27; + step.dest_sub_ids[4] + &#x27;\&#x27;, name: \&#x27;&#x27; + step.dest_sub_ids[4];
                    set_str += &#x27;\&#x27;&gt;&gt;, point2: &lt;&lt;id: \&#x27;&#x27; + step.dest_sub_ids[3] + &#x27;\&#x27;, name: \&#x27;&#x27; + step.dest_sub_ids[3];
                    set_str += &#x27;\&#x27;&gt;&gt;&gt;&gt;&gt;&gt;; &#x27;;
                    reset_str = &#x27;delete &#x27; + step.dest_sub_ids[5] + &#x27;; delete &#x27; + step.dest_sub_ids[4] + &#x27;; delete &#x27;;
                    reset_str += step.dest_sub_ids[3] + &#x27;; delete &#x27; + step.dest_sub_ids[2] + &#x27;; delete &#x27;;
                    reset_str += step.dest_sub_ids[1] + &#x27;; delete &#x27; + step.dest_sub_ids[0] + &#x27;; &#x27;;
                    break;

                case JXG.GENTYPE_BOARDIMG:
                    set_str = &quot;image(&#x27;&quot; + step.args.s + &quot;&#x27;, [ &quot; + step.args.anchor + &quot; ], [ &quot; + step.args.scale + &quot; ]) &quot;;
                    set_str += &quot;&lt;&lt;id: &#x27;&quot; + step.dest_id + &quot;&#x27;&gt;&gt;; &quot;;

                    reset_str = &quot;delete &quot; + step.dest_id + &quot;; &quot;;
                    break;

                case JXG.GENTYPE_BISECTOR:
                    if (step.args.create_point) {
                        // TODO: use &quot;if (options.useGlider) {&quot;

                        // Projection to first line
                        pid1 = step.dest_sub_ids[1];
                        set_str = &#x27;point(&#x27; + pn(step.args.usrCoords[1]) + &#x27;, &#x27; + pn(step.args.usrCoords[2]) + &#x27;) &#x27;;
                        set_str += &#x27;&lt;&lt;id:\&#x27;&#x27; + pid1 + &#x27;\&#x27;, &#x27;;
                        set_str += &#x27;name:\&#x27;\&#x27;, priv:true, visible:false &gt;&gt;; &#x27;;
                        set_str += pid1 + &#x27;.glide(&#x27; + step.src_ids[0] + &#x27;); &#x27;;
                        reset_str = &#x27;delete &#x27; + pid1 + &#x27;; &#x27;;

                        // Projection to second line
                        pid2 = step.dest_sub_ids[2];
                        set_str += &#x27;point(&#x27; + pn(step.args.usrCoords[1]) + &#x27;, &#x27; + pn(step.args.usrCoords[2]) + &#x27;) &#x27;;
                        set_str += &#x27;&lt;&lt;id:\&#x27;&#x27; + pid2 + &#x27;\&#x27;, &#x27;;
                        set_str += &#x27;name:\&#x27;\&#x27;, priv:true, visible:false &gt;&gt;; &#x27;;
                        set_str += pid2 + &#x27;.glide(&#x27; + step.src_ids[1] + &#x27;); &#x27;;
                        reset_str += &#x27;delete &#x27; + pid2 + &#x27;; &#x27;;

                        if (step.args.create_intersection) {
                            // intersection point
                            pid3 = step.dest_sub_ids[3];
                            set_str += &#x27;intersection(&#x27; + step.src_ids[0] + &#x27;, &#x27; + step.src_ids[1] + &#x27;, 0) &#x27;;
                            set_str += &#x27;&lt;&lt;id:\&#x27;&#x27; + pid3 + &#x27;\&#x27;, fillColor: \&#x27;&#x27; + step.args.fillColor + &#x27;\&#x27;, &#x27;;
                            set_str += &#x27;name:\&#x27;\&#x27;, priv:true, visible:false &gt;&gt;; &#x27;;
                            reset_str += &#x27;delete &#x27; + pid3 + &#x27;; &#x27;;
                        } else {
                            pid3 = step.src_ids[2];
                        }

                        set_str += assign + &#x27;bisector(&#x27; + pid1 + &#x27;, &#x27; + pid3 + &#x27;, &#x27; + pid2 + &#x27;) &#x27;;
                        set_str += &#x27;&lt;&lt;&#x27; + attrid + &#x27;name: \&#x27;\&#x27;, point: &lt;&lt;id: \&#x27;&#x27; + step.dest_sub_ids[0] + &#x27;\&#x27;, priv: true, name: \&#x27;&#x27;;
                        set_str += step.dest_sub_ids[0] + &#x27;\&#x27;&gt;&gt; &gt;&gt;;&#x27;;
                        reset_str += &#x27;delete &#x27; + step.dest_id + &#x27;; delete &#x27; + step.dest_sub_ids[0] + &#x27;;&#x27;;
                    } else {
                        set_str = assign + &#x27;bisector(&#x27; + step.src_ids[1] + &#x27;, &#x27; + step.src_ids[2] + &#x27;, &#x27; + step.src_ids[0];
                        set_str += &#x27;) &lt;&lt;&#x27; + attrid + &#x27;name: \&#x27;\&#x27;, point: &lt;&lt;id: \&#x27;&#x27; + step.dest_sub_ids[0] + &#x27;\&#x27;, priv: true, name: \&#x27;&#x27;;
                        set_str += step.dest_sub_ids[0] + &#x27;\&#x27;&gt;&gt;&gt;&gt;;&#x27;;
                        reset_str = &#x27;delete &#x27; + step.dest_id + &#x27;; delete &#x27; + step.dest_sub_ids[0] + &#x27;;&#x27;;
                    }
                    break;

                case JXG.GENTYPE_NORMAL:
                    if (step.args.create_point) {
                        sub_id = step.dest_sub_ids[1];
                        set_str = &#x27;point(&#x27; + pn(step.args.usrCoords[1]) + &#x27;, &#x27; + pn(step.args.usrCoords[2]);
                        set_str += &#x27;) &lt;&lt;id: \&#x27;&#x27; + sub_id + &#x27;\&#x27;, name: \&#x27;\&#x27;, visible: false, priv: true&gt;&gt;; &#x27;;
                        reset_str = &#x27;delete &#x27; + sub_id + &#x27;; &#x27;;
                    } else {
                        sub_id = step.src_ids[1];
                    }

                    set_str += assign + &#x27;normal(&#x27; + sub_id + &#x27;, &#x27; + step.src_ids[0] + &#x27;) &lt;&lt;&#x27; + attrid;
                    set_str += &#x27;name: \&#x27;\&#x27;, point: &lt;&lt;id: \&#x27;&#x27; + step.dest_sub_ids[0] + &#x27;\&#x27;, name: \&#x27;&#x27; + step.dest_sub_ids[0];
                    set_str += &#x27;\&#x27;&gt;&gt; &gt;&gt;; &#x27;;
                    reset_str = &#x27;delete &#x27; + step.dest_id + &#x27;; delete &#x27; + step.dest_sub_ids[0] + &#x27;; &#x27; + reset_str;
                    break;

                case JXG.GENTYPE_PERPSEGMENT:
                    set_str += assign + &#x27;perpendicularsegment(&#x27; + step.src_ids[1] + &#x27;, &#x27; + step.src_ids[0] + &#x27;) &lt;&lt;&#x27; + attrid;
                    set_str += &#x27;name: \&#x27;\&#x27;, point: &lt;&lt;id: \&#x27;&#x27; + step.dest_sub_ids[0] + &#x27;\&#x27;, name: \&#x27;&#x27; + step.dest_sub_ids[0];
                    set_str += &#x27;\&#x27;&gt;&gt; &gt;&gt;; &#x27;;
                    reset_str = &#x27;delete &#x27; + step.dest_id + &#x27;; delete &#x27; + step.dest_sub_ids[0] + &#x27;; &#x27; + reset_str;
                    break;

                case JXG.GENTYPE_POINT:
                    set_str = assign + &#x27;point(&#x27; + pn(step.args.usrCoords[1]) + &#x27;, &#x27; + pn(step.args.usrCoords[2]);
                    set_str += &#x27;)&#x27; + (options.useSymbols ? &#x27;&#x27; : &#x27; &lt;&lt;id: \&#x27;&#x27; + step.dest_id + &#x27;\&#x27;&#x27;
                        + &#x27;, snaptogrid: &#x27; + JXG.Options.elements.snapToGrid
                        + &#x27;, snaptopoints: &#x27; + JXG.Options.elements.snapToPoints + &#x27;&gt;&gt;&#x27;) + &#x27;; &#x27;;

                    reset_str = &#x27;delete &#x27; + step.dest_id + &#x27;; &#x27;;
                    break;

                case JXG.GENTYPE_GLIDER:
                    if (options.useGlider) {
                        set_str = assign + &#x27;glider(&#x27; + pn(step.args.usrCoords[1]) + &#x27;, &#x27; + pn(step.args.usrCoords[2]);
                        set_str += &#x27;, &#x27; + step.src_ids[0] + &#x27;)&#x27;;
                        set_str += (options.useSymbols ? &#x27;&#x27; : &#x27;&lt;&lt;id: \&#x27;&#x27; + step.dest_id + &#x27;\&#x27;&#x27;
                            + &#x27;, snaptogrid: false, snaptopoints: false&#x27;
                            + &#x27;, snaptopoints: &#x27; + JXG.Options.elements.snapToPoints + &#x27;&gt;&gt;&#x27;) + &#x27;;&#x27;;

                    } else {
                        set_str = assign + &#x27;point(&#x27; + pn(step.args.usrCoords[1]) + &#x27;, &#x27; + pn(step.args.usrCoords[2]);
                        set_str += &#x27;) &lt;&lt;&#x27; + attrid + &#x27;fillColor: \&#x27;&#x27; +  JXG.Options.glider.fillColor + &#x27;\&#x27;&#x27;;
                        set_str += &#x27;, strokeColor: \&#x27;&#x27; +  JXG.Options.glider.strokeColor + &#x27;\&#x27;&#x27;;
                        set_str += &#x27;, snapToGrid: false, snapToPoints: false&#x27;;
                        set_str += &#x27;&gt;&gt;; &#x27; + step.dest_id;
                        set_str += &#x27;.glide(&#x27; + step.src_ids[0] + &#x27;); &#x27;;
                    } 
                    set_str += step.dest_id + &#x27;.onPolygon = &#x27; + !!step.args.onPolygon + &#x27;;&#x27;;

                    if (!(step.args &amp;&amp; step.args.undoIsEmpty)) {
                        reset_str = &#x27;delete &#x27; + step.dest_id + &#x27;; &#x27;;
                    }

                    break;

                case JXG.GENTYPE_INTERSECTION:
                    set_str = assign + &#x27;intersection(&#x27; + step.src_ids[0] + &#x27;, &#x27; + step.src_ids[1] + &#x27;, &#x27; + step.args.choice;
                    set_str += &#x27;) &lt;&lt;&#x27; + attrid + &#x27; fillColor: \&#x27;&#x27; + JXG.Options.intersection.fillColor + &#x27;\&#x27;&#x27;;
                    set_str += &#x27;, strokeColor: \&#x27;&#x27; + JXG.Options.intersection.strokeColor + &#x27;\&#x27;&#x27;;
                    set_str += &#x27;&gt;&gt;; &#x27;;

                    if (!(step.args &amp;&amp; step.args.undoIsEmpty)) {
                        reset_str = &#x27;delete &#x27; + step.dest_id + &#x27;; &#x27;;
                    }

                    break;

                case JXG.GENTYPE_MIGRATE:

                    set_str = &#x27;$board.migratePoint(&#x27; + step.src_ids[0] + &#x27;, &#x27; + step.dest_id + &#x27;, false); &#x27;;

                    if (step.args &amp;&amp; step.args.migrateToGlider) {

                        var o, gl, uc1, uc2;

                        reset_str = step.dest_id + &#x27;.free(); &#x27; + step.dest_id;
                        reset_str += &#x27;.fillColor = \&#x27;&#x27; + step.args.fillColor + &#x27;\&#x27;; &#x27; + step.dest_id;
                        reset_str += &#x27;.strokeColor = \&#x27;&#x27; + step.args.strokeColor + &#x27;\&#x27;; &#x27;;

                        uc1 = step.args.usrCoords[1];
                        uc2 = step.args.usrCoords[2];

                        reset_str += &#x27;point(&#x27; + uc1 + &#x27;, &#x27; + uc2 + &#x27;)&#x27;;
                        reset_str += &#x27; &lt;&lt;id: \&#x27;&#x27; + step.src_ids[0] + &#x27;\&#x27;, name: \&#x27;\&#x27;&gt;&gt;&#x27; + &#x27;; &#x27;;
                        reset_str += &#x27;$board.migratePoint(&#x27; + step.dest_id + &#x27;, &#x27; + step.src_ids[0] + &#x27;, false); &#x27;;
                        reset_str += step.src_ids[0] + &#x27;.name = \&#x27;&#x27; + step.args.orig_name + &#x27;\&#x27;; &#x27;;
                        reset_str += step.src_ids[0] + &#x27;.label.setText(\&#x27;&#x27; + step.args.orig_name + &#x27;\&#x27;); &#x27;;

                        o = board.objects[step.dest_id];
                        gl = o.slideObject.id;

                        uc1 = o.coords.usrCoords[1];
                        uc2 = o.coords.usrCoords[2];

                        reset_str +=  assign + &#x27;point(&#x27; + uc1 + &#x27;, &#x27; + uc2 + &#x27;) &#x27;;
                        reset_str += &#x27;&lt;&lt;&#x27; + attrid + &#x27;fillColor: \&#x27;&#x27; +  JXG.Options.glider.fillColor + &#x27;\&#x27;&gt;&gt;; &#x27;;
                        reset_str += step.dest_id + &#x27;.glide(&#x27; + gl + &#x27;); &#x27;;

                    } else {
                        // Do nothing
                        //reset_str = &#x27;delete &#x27; + step.dest_id + &#x27;; &#x27;;
                    }

                    break;

                case JXG.GENTYPE_COMBINED:

                    set_str = reset_str = &#x27;&#x27;;

                    for (i = 0; i &lt; step.args.steps.length; i++) {
                        arr = this.generateJCode(step.args.steps[i], board, step_log);

                        set_str = set_str + arr[0];
                        reset_str = arr[2] + reset_str;
                    }

                    break;

                case JXG.GENTYPE_CIRCLE:
                    reset_str = &#x27;delete &#x27; + step.dest_sub_ids[0] + &#x27;; &#x27;;

                    if (step.args.create_point) {
                        set_str = &#x27;point(&#x27; + pn(step.args.usrCoords[1]) + &#x27;, &#x27; + pn(step.args.usrCoords[2]);
                        set_str += &#x27;) &lt;&lt;id: \&#x27;&#x27; + step.dest_sub_ids[0] + &#x27;\&#x27;, priv: false&gt;&gt;; &#x27;;

                        set_str += assign + &#x27;circle(&#x27; + step.dest_sub_ids[0] + &#x27;, &#x27; + step.src_ids[0] + &#x27;) &lt;&lt;&#x27; + attrid;
                        set_str += &#x27;name: \&#x27;\&#x27;, fillOpacity: &#x27; + JXG.Options.opacityLevel
                            + &#x27;, snaptogrid: &#x27; + JXG.Options.elements.snapToGrid
                            + &#x27;, snaptopoints: &#x27; + JXG.Options.elements.snapToPoints + &#x27;&gt;&gt;;&#x27;;

                        reset_str = &#x27;delete &#x27; + step.dest_id + &#x27;; &#x27; + reset_str;
                    } else if (step.args.create_by_radius) {
                        set_str = &#x27;point(&#x27; + pn(step.args.x) + &#x27;, &#x27; + pn(step.args.y) + &#x27;) &lt;&lt;id: \&#x27;&#x27; + step.dest_sub_ids[0];
                        set_str += &#x27;\&#x27;, name: \&#x27;\&#x27;, withLabel: true, visible: true, priv: false&gt;&gt;; &#x27;;
                        set_str += step.dest_sub_ids[0] + &#x27;.visible = true; &#x27;;
                        set_str += assign + &#x27;circle(\&#x27;&#x27; + step.dest_sub_ids[0] + &#x27;\&#x27;, &#x27; + pn(step.args.r) + &#x27;) &lt;&lt;&#x27; + attrid;
                        set_str += &#x27;name: \&#x27;\&#x27;, fillOpacity: &#x27; + JXG.Options.opacityLevel
                            + &#x27;, snaptogrid: &#x27; + JXG.Options.elements.snapToGrid
                            + &#x27;, snaptopoints: &#x27; + JXG.Options.elements.snapToPoints + &#x27;&gt;&gt;;&#x27;;

                        reset_str = &#x27;delete &#x27; + step.dest_id + &#x27;; delete &#x27; + step.dest_sub_ids[0] + &#x27;; &#x27;;
                    } else {
                        set_str = assign + &#x27;circle(&#x27; + step.src_ids[0] + &#x27;, &#x27; + step.src_ids[1] + &#x27;, &#x27; + step.src_ids[2];
                        set_str += &#x27;) &lt;&lt;center: &lt;&lt;id: \&#x27;&#x27; + step.dest_sub_ids[0] + &#x27;\&#x27;, name: \&#x27;&#x27; + step.dest_sub_ids[0];
                        set_str += &#x27;\&#x27;, visible: true&gt;&gt;, &#x27; + attrid + &#x27;name: \&#x27;\&#x27;, fillOpacity: &#x27; + JXG.Options.opacityLevel
                            + &#x27;, snaptogrid: &#x27; + JXG.Options.elements.snapToGrid
                            + &#x27;, snaptopoints: &#x27; + JXG.Options.elements.snapToPoints + &#x27;&gt;&gt;; &#x27;;

                        reset_str = &#x27;delete &#x27; + step.dest_id + &#x27;; &#x27; + reset_str;
                    }

                    break;

                case JXG.GENTYPE_CIRCLE2POINTS:
                    if (step.args.create_two_points) {
                        set_str = &#x27;point(&#x27; + pn(step.args.x1) + &#x27;, &#x27; + pn(step.args.y1) + &#x27;) &lt;&lt;id: \&#x27;&#x27; + step.dest_sub_ids[0];
                        set_str += &#x27;\&#x27;&gt;&gt;; &#x27;;
                        set_str += &#x27;point(&#x27; + pn(step.args.x2) + &#x27;, &#x27; + pn(step.args.y2) + &#x27;) &lt;&lt;id: \&#x27;&#x27;;
                        set_str += step.dest_sub_ids[1] + &#x27;\&#x27;&gt;&gt;; &#x27;;
                        set_str += assign + &#x27;circle(&#x27; + step.dest_sub_ids[0] + &#x27;, &#x27; + step.dest_sub_ids[1] + &#x27;) &lt;&lt;&#x27; + attrid;
                        set_str += &#x27;name: \&#x27;\&#x27;, fillOpacity: &#x27; + JXG.Options.opacityLevel
                            + &#x27;, snaptogrid: &#x27; + JXG.Options.elements.snapToGrid
                            + &#x27;, snaptopoints: &#x27; + JXG.Options.elements.snapToPoints + &#x27;&gt;&gt;; &#x27;;

                        reset_str = &#x27;delete &#x27; + step.dest_id + &#x27;; delete &#x27; + step.dest_sub_ids[1] + &#x27;; delete &#x27;;
                        reset_str += step.dest_sub_ids[0] + &#x27;; &#x27;;
                    } else if (step.args.create_point) {
                        set_str = &#x27;point(&#x27; + pn(step.args.x) + &#x27;, &#x27; + pn(step.args.y) + &#x27;) &lt;&lt;id: \&#x27;&#x27; + step.dest_sub_ids[0];
                        set_str += &#x27;\&#x27;&gt;&gt;; &#x27;;
                        set_str += assign + &#x27;circle(&#x27; + step.dest_sub_ids[0] + &#x27;, &#x27; + step.src_ids[0] + &#x27;) &lt;&lt;&#x27; + attrid;
                        set_str += &#x27;name: \&#x27;\&#x27;, fillOpacity: &#x27; + JXG.Options.opacityLevel
                            + &#x27;, snaptogrid: &#x27; + JXG.Options.elements.snapToGrid
                            + &#x27;, snaptopoints: &#x27; + JXG.Options.elements.snapToPoints + &#x27;&gt;&gt;; &#x27;;

                        reset_str = &#x27;delete &#x27; + step.dest_id + &#x27;; delete &#x27; + step.dest_sub_ids[0] + &#x27;; &#x27;;
                    } else if (step.args.create_by_radius) {
                        set_str = assign + &#x27;circle(&#x27; + step.src_ids[0] + &#x27;, &#x27; + step.args.r + &#x27;) &lt;&lt;&#x27; + attrid;
                        set_str += &#x27;name: \&#x27;\&#x27;, fillOpacity: &#x27; + JXG.Options.opacityLevel
                            + &#x27;, snaptogrid: &#x27; + JXG.Options.elements.snapToGrid
                            + &#x27;, snaptopoints: &#x27; + JXG.Options.elements.snapToPoints + &#x27;&gt;&gt;; &#x27;;

                        reset_str = &#x27;delete &#x27; + step.dest_id + &#x27;; &#x27;;
                    } else {
                        set_str = assign + &#x27;circle(&#x27; + step.src_ids[0] + &#x27;, &#x27; + step.src_ids[1] + &#x27;) &lt;&lt;&#x27; + attrid;
                        set_str += &#x27;name: \&#x27;\&#x27;, fillOpacity: &#x27; + JXG.Options.opacityLevel
                            + &#x27;, snaptogrid: &#x27; + JXG.Options.elements.snapToGrid
                            + &#x27;, snaptopoints: &#x27; + JXG.Options.elements.snapToPoints + &#x27;&gt;&gt;; &#x27;;

                        reset_str = &#x27;delete &#x27; + step.dest_id + &#x27;; &#x27;;
                    }

                    break;

                case JXG.GENTYPE_LINE:

                    k = 0;
                    j = 0;

                    if (step.args.create_point1) {
                        pid1 = step.dest_sub_ids[k];
                        k += 1;
                        str1 = [];
                        for (i = 0; i &lt; step.args.p1.length; i++) {
                            str1[i] = pn(step.args.p1[i]);
                        }

                        set_str = &#x27;point(&#x27; + str1.join(&#x27;, &#x27;) + &#x27;) &lt;&lt;id: \&#x27;&#x27; + pid1 + &#x27;\&#x27;, name: \&#x27;\&#x27;, visible: false, &#x27;;
                        set_str += &#x27;snaptogrid: false, snaptopoints: false, priv: true&gt;&gt;; &#x27;;
                        reset_str = &#x27;delete &#x27; + pid1 + &#x27;; &#x27;;
                    } else {
                        pid1 = step.src_ids[j];
                        j += 1;
                    }

                    if (step.args.create_point2) {
                        pid2 = step.dest_sub_ids[k++];
                        str1 = [];
                        for (i = 0; i &lt; step.args.p2.length; i++) {
                            str1[i] = pn(step.args.p2[i]);
                        }

                        set_str += &#x27;point(&#x27; + str1.join(&#x27;, &#x27;) + &#x27;) &lt;&lt;id: \&#x27;&#x27; + pid2 + &#x27;\&#x27;, name: \&#x27;\&#x27;, visible: false, &#x27;;
                        set_str += &#x27;snaptogrid: false, snaptopoints: false, priv: true&gt;&gt;; &#x27;;
                        reset_str = &#x27;delete &#x27; + pid2 + &#x27;; &#x27; + reset_str;
                    } else {
                        pid2 = step.src_ids[j];
                        j += 1;
                    }

                    str = &#x27;line&#x27;;
                    str1 = &#x27;&#x27;;

                    // the line&#x27;s parents
                    str2 = pid1 + &#x27;, &#x27; + pid2;

                    // if we want a truly free line
                    if (step.args.create_point1 &amp;&amp; step.args.create_point2 &amp;&amp; options.freeLine) {
                        // forget the points
                        set_str = &#x27;&#x27;;
                        reset_str = &#x27;&#x27;;

                        // use the stdform instead
                        if (step.args.p1.length === 2) {
                            step.args.p1.unshift(1);
                        }

                        if (step.args.p2.length === 2) {
                            step.args.p2.unshift(1);
                        }

                        str2 = JXG.Math.crossProduct(step.args.p1, step.args.p2);
                        for (i = 0; i &lt; str2.length; i++) {
                            str2[i] = pn(str2[i]);
                        }

                        str2 = str2.join(&#x27;, &#x27;);
                    }

                    if (!step.args.first &amp;&amp; !step.args.last) {
                        str = &#x27;segment&#x27;;
                    } else {
                        if (!step.args.first) {
                            str1 = &#x27;straightFirst: &#x27; + step.args.first;
                        }

                        if (!step.args.last) {
                            str1 = &#x27;straightLast: &#x27; + step.args.last;
                        }

                        if (str1.length &gt; 0 &amp;&amp; !options.useSymbols) {
                            str1 += &#x27;, &#x27;;
                        }
                    }

                    // this is a corner case, we have to get rid of the &#x27;,&#x27; at the end
                    // simple solution: rebuild attrid
                    if (!options.useSymbols) {
                        attrid = &#x27;id: \&#x27;&#x27; + step.dest_id + &#x27;\&#x27;&#x27;;
                    }

                    set_str += assign + str + &#x27;(&#x27; + str2 + &#x27;)&#x27;;

                    if (str1.length + attrid.length &gt; 0) {
                        set_str += &#x27; &lt;&lt;&#x27; + str1 + attrid + &#x27;, name: \&#x27;\&#x27;, snaptogrid: &#x27; + JXG.Options.elements.snapToGrid
                            + &#x27;, snaptopoints: &#x27; + JXG.Options.elements.snapToPoints + &#x27;&gt;&gt;; &#x27;;

                    } else {
                        set_str += &#x27; &lt;&lt;name: \&#x27;\&#x27;, snaptogrid: &#x27; + JXG.Options.elements.snapToGrid
                            + &#x27;, snaptopoints: &#x27; + JXG.Options.elements.snapToPoints + &#x27;&gt;&gt;; &#x27;;
                    }

                    reset_str = &#x27;delete &#x27; + step.dest_id + &#x27;; &#x27; + reset_str;

                    break;

                case JXG.GENTYPE_VECTOR:

                    k = 0;
                    j = 0;

                    if (step.args.create_point1) {
                        pid1 = step.dest_sub_ids[k];
                        k += 1;
                        str1 = [];
                        for (i = 0; i &lt; step.args.p1.length; i++) {
                            str1[i] = pn(step.args.p1[i]);
                        }

                        set_str = &#x27;point(&#x27; + str1.join(&#x27;, &#x27;) + &#x27;) &lt;&lt;id: \&#x27;&#x27; + pid1 + &#x27;\&#x27;, name: \&#x27;\&#x27;, visible: true, &#x27;;
                        set_str += &#x27;snaptogrid: false, snaptopoints: false, priv: false&gt;&gt;; &#x27;;
                        reset_str = &#x27;delete &#x27; + pid1 + &#x27;; &#x27;;
                    } else {
                        pid1 = step.src_ids[j];
                        j += 1;
                    }

                    if (step.args.create_point2) {
                        pid2 = step.dest_sub_ids[k++];
                        str1 = [];
                        for (i = 0; i &lt; step.args.p2.length; i++) {
                            str1[i] = pn(step.args.p2[i]);
                        }

                        set_str += &#x27;point(&#x27; + str1.join(&#x27;, &#x27;) + &#x27;) &lt;&lt;id: \&#x27;&#x27; + pid2 + &#x27;\&#x27;, name: \&#x27;\&#x27;, visible: true, &#x27;;
                        set_str += &#x27;layer: &#x27; + JXG.Options.layer.line + &#x27;, size: 2, opacity: 0.2, &#x27;;
                        set_str += &#x27;snaptogrid: false, snaptopoints: false, priv: false&gt;&gt;; &#x27;;
                        reset_str = &#x27;delete &#x27; + pid2 + &#x27;; &#x27; + reset_str;
                    } else {
                        pid2 = step.src_ids[j];
                        j += 1;
                    }

                    str1 = &#x27;&#x27;;
                    // the line&#x27;s parents
                    str2 = pid1 + &#x27;, &#x27; + pid2;
                    str = &#x27;arrow&#x27;;

                    // this is a corner case, we have to get rid of the &#x27;,&#x27; at the end
                    // simple solution: rebuild attrid
                    if (!options.useSymbols) {
                        attrid = &#x27;id: \&#x27;&#x27; + step.dest_id + &#x27;\&#x27;&#x27;;
                    }

                    set_str += assign + str + &#x27;(&#x27; + str2 + &#x27;)&#x27;;

                    if (str1.length + attrid.length &gt; 0) {
                        set_str += &#x27; &lt;&lt;&#x27; + str1 + attrid + &#x27;, name: \&#x27;\&#x27;, strokeColor: \&#x27;black\&#x27;, snaptogrid: &#x27; + JXG.Options.elements.snapToGrid
                            + &#x27;, snaptopoints: &#x27; + JXG.Options.elements.snapToPoints + &#x27;&gt;&gt;; &#x27;;

                    } else {
                        set_str += &#x27; &lt;&lt;name: \&#x27;\&#x27;, strokeColor: \&#x27;black\&#x27;, snaptogrid: &#x27; + JXG.Options.elements.snapToGrid
                            + &#x27;, snaptopoints: &#x27; + JXG.Options.elements.snapToPoints + &#x27;&gt;&gt;; &#x27;;
                    }

                    reset_str = &#x27;delete &#x27; + step.dest_id + &#x27;; &#x27; + reset_str;

                    break;

                case JXG.GENTYPE_TRIANGLE:
                    for (i = 0; i &lt; step.args.create_point.length; i++) {
                        if (step.args.create_point[i]) {
                            set_str += &#x27;point(&#x27; + pn(step.args.coords[i].usrCoords[1]) + &#x27;, &#x27;;
                            set_str += pn(step.args.coords[i].usrCoords[2]) + &#x27;) &lt;&lt;id: \&#x27;&#x27; + step.dest_sub_ids[i];
                            set_str +=  &#x27;\&#x27;, snaptogrid: &#x27; + JXG.Options.elements.snapToGrid;
                            set_str += &#x27;, snaptopoints: &#x27; + JXG.Options.elements.snapToPoints + &#x27;&gt;&gt;; &#x27;;
                        }
                    }

                    for (i = 0; i &lt; step.dest_sub_ids.length; i++) {
                        if (step.dest_sub_ids[i] !== 0) {
                            reset_str = &#x27;delete &#x27; + step.dest_sub_ids[i] + &#x27;; &#x27; + reset_str;
                        }
                    }

                    reset_str = &#x27;delete &#x27; + step.dest_id + &#x27;; &#x27; + reset_str;
                    set_str += assign + &#x27;polygon(&#x27;;

                    for (i = 0; i &lt; step.src_ids.length; i++) {
                        set_str += step.src_ids[i];
                        if (i &lt; step.src_ids.length - 1) {
                            set_str += &#x27;, &#x27;;
                        }
                    }

                    for (i = 0; i &lt; 3; i++) {
                        if (step.dest_sub_ids[i] !== 0) {
                            if (step.src_ids.length &gt; 0 || i &gt; 0) {
                                set_str += &#x27;, &#x27;;
                            }
                            set_str += step.dest_sub_ids[i];
                        }
                    }

                    set_str += &#x27;) &lt;&lt;borders: &lt;&lt;ids: [\&#x27;&#x27; + step.dest_sub_ids[3] + &#x27;\&#x27;, \&#x27;&#x27; + step.dest_sub_ids[4];
                    set_str += &#x27;\&#x27;, \&#x27;&#x27; + step.dest_sub_ids[5] + &#x27;\&#x27;]&#x27;;
                    set_str += &#x27;, names: [\&#x27;\&#x27;, \&#x27;\&#x27;, \&#x27;\&#x27;]&#x27;;
                    set_str += &#x27;&gt;&gt;, &#x27; + attrid + &#x27; fillOpacity: &#x27;;
                    set_str += JXG.Options.opacityLevel + &#x27;, name: \&#x27;\&#x27;, hasInnerPoints:&#x27; + JXG.Options.polygon.hasInnerPoints;
                    set_str += &#x27;, snaptogrid: &#x27; + JXG.Options.elements.snapToGrid;
                    set_str += &#x27;, snaptopoints: &#x27; + JXG.Options.elements.snapToPoints + &#x27;, scalable:true&gt;&gt;; &#x27;;
                    break;

                case JXG.GENTYPE_QUADRILATERAL:
                    for (i = 0; i &lt; step.args.create_point.length; i++) {
                        if (step.args.create_point[i]) {
                            set_str += &#x27;point(&#x27; + pn(step.args.coords[i].usrCoords[1]) + &#x27;, &#x27;;
                            set_str += pn(step.args.coords[i].usrCoords[2]) + &#x27;) &lt;&lt;id: \&#x27;&#x27; + step.dest_sub_ids[i];
                            set_str += &#x27;\&#x27;, snaptogrid: &#x27; + JXG.Options.elements.snapToGrid;
                            set_str += &#x27;, snaptopoints: &#x27; + JXG.Options.elements.snapToPoints + &#x27;&gt;&gt;; &#x27;;
                        }
                    }

                    for (i = 0; i &lt; step.dest_sub_ids.length; i++) {
                        if (step.dest_sub_ids[i] !== 0) {
                            reset_str = &#x27;delete &#x27; + step.dest_sub_ids[i] + &#x27;; &#x27; + reset_str;
                        }
                    }

                    reset_str = &#x27;delete &#x27; + step.dest_id + &#x27;; &#x27; + reset_str;
                    set_str += assign + &#x27;polygon(&#x27;;

                    for (i = 0; i &lt; step.src_ids.length; i++) {
                        set_str += step.src_ids[i];
                        if (i &lt; step.src_ids.length - 1) {
                            set_str += &#x27;, &#x27;;
                        }
                    }

                    set_str += &#x27;) &lt;&lt;borders: &lt;&lt;ids: [ \&#x27;&#x27; + step.dest_sub_ids[4] + &#x27;\&#x27;, \&#x27;&#x27; + step.dest_sub_ids[5];
                    set_str += &#x27;\&#x27;, \&#x27;&#x27;;
                    set_str += step.dest_sub_ids[6] + &#x27;\&#x27;, \&#x27;&#x27; + step.dest_sub_ids[7] + &#x27;\&#x27; ]&#x27;;
                    set_str += &#x27;, names: [\&#x27;\&#x27;, \&#x27;\&#x27;, \&#x27;\&#x27;, \&#x27;\&#x27;]&#x27;;
                    set_str += &#x27;&gt;&gt;, &#x27; + attrid;
                    set_str += &#x27; fillOpacity: &#x27;;
                    set_str += JXG.Options.opacityLevel + &#x27;, name: \&#x27;\&#x27;, hasInnerPoints:&#x27; + JXG.Options.polygon.hasInnerPoints;
                    set_str += &#x27;, snaptogrid: &#x27; + JXG.Options.elements.snapToGrid;
                    set_str += &#x27;, snaptopoints: &#x27; + JXG.Options.elements.snapToPoints + &#x27;, scalable:true&gt;&gt;; &#x27;;
                    break;

                case JXG.GENTYPE_TEXT:
                    set_str = assign + &#x27;text(&#x27; + pn(step.args.x) + &#x27;, &#x27; + pn(step.args.y) + &#x27;, &#x27; + step.args.str + &#x27;) &lt;&lt;&#x27;;
                    set_str += attrid + &#x27;name: \&#x27;\&#x27;&#x27;;
                    if (typeof step.args.anchor != &#x27;undefined&#x27;) {
                        set_str += &#x27;, anchor: &#x27; + step.args.anchor;
                    }
                    set_str += &#x27;&gt;&gt;; &#x27; + step.dest_id + &#x27;.setText(&#x27; + step.args.str;
                    set_str += &#x27;); &#x27;;
                    reset_str = &#x27;delete &#x27; + step.dest_id + &#x27;; &#x27;;
                    break;

                case JXG.GENTYPE_RULER:
                    set_str = assign + &#x27;tapemeasure([ &#x27; + step.args.p1 + &#x27; ], [ &#x27; + step.args.p2 + &#x27; ]) &lt;&lt;&#x27;;
                    /*
                     set_str += attrid + &#x27;name: \&#x27;\&#x27;, point1: &lt;&lt;id: \&#x27;&#x27; + step.dest_sub_ids[0] + &#x27;\&#x27;, snaptogrid: &#x27;
                     + JXG.Options.elements.snapToGrid + &#x27;, snaptopoints: &#x27; + JXG.Options.elements.snapToPoints + &#x27;&gt;&gt;, &#x27;
                     + &#x27;point2: &lt;&lt;id: \&#x27;&#x27; + step.dest_sub_ids[1] + &#x27;\&#x27;&#x27;+ &#x27;, snaptogrid: &#x27;
                     + JXG.Options.elements.snapToGrid + &#x27;, snaptopoints: &#x27; + JXG.Options.elements.snapToPoints + &#x27;&gt;&gt; &gt;&gt;; &#x27;;
                     */
                    set_str += attrid + &#x27;name: \&#x27;\&#x27;&#x27;
                        + &#x27;, precision: &#x27; + JXG.Options.trunclen
                        + &#x27;, point1: &lt;&lt;id: \&#x27;&#x27; + step.dest_sub_ids[0] + &#x27;\&#x27;, snaptogrid: &#x27;
                        + JXG.Options.elements.snapToGrid + &#x27;&gt;&gt;, &#x27;
                        + &#x27;point2: &lt;&lt;id: \&#x27;&#x27; + step.dest_sub_ids[1] + &#x27;\&#x27;&#x27; + &#x27;, snaptogrid: &#x27;
                        + JXG.Options.elements.snapToGrid + &#x27;&gt;&gt; &gt;&gt;; &#x27;;
                    reset_str = &#x27;delete &#x27; + step.dest_id + &#x27;; &#x27;;
                    break;

                case JXG.GENTYPE_POLYGON:
                    set_str = assign + &#x27;polygon(&#x27;;

                    for (i = 0; i &lt; step.src_ids.length; i++) {
                        set_str += step.src_ids[i];
                        if (i !== step.src_ids.length - 1) {
                            set_str += &#x27;, &#x27;;
                        }
                    }

                    set_str += &#x27;) &lt;&lt;borders: &lt;&lt;ids: [\&#x27;&#x27;;

                    for (i = 0; i &lt; step.dest_sub_ids.length; i++) {
                        set_str += step.dest_sub_ids[i];
                        if (i &lt; step.dest_sub_ids.length - 1) {
                            set_str += &#x27;\&#x27;, \&#x27;&#x27;;
                        }
                    }
                    set_str += &#x27;\&#x27;]&#x27;;

                    set_str += &#x27;, names: [&#x27;;
                    for (i = 0; i &lt; step.dest_sub_ids.length; i++) {
                        set_str += &#x27;\&#x27;\&#x27;&#x27;;
                        if (i &lt; step.dest_sub_ids.length - 1) {
                            set_str += &#x27;, &#x27;;
                        }
                    }
                    set_str += &#x27;]&#x27;;
                    set_str += &#x27;, name: \&#x27;\&#x27;&gt;&gt;, &#x27; + attrid + &#x27; fillOpacity: &#x27; + JXG.Options.opacityLevel;
                    set_str += &#x27;, name: \&#x27;\&#x27;&gt;&gt;; &#x27;;
                    reset_str = &#x27;delete &#x27; + step.dest_id + &#x27;; &#x27;;
                    break;

                case JXG.GENTYPE_REGULARPOLYGON:
                    set_str = assign + &#x27;regularpolygon(&#x27; + step.src_ids.join(&#x27;, &#x27;) + &#x27;, &#x27;;
                    set_str += step.args.corners + &#x27;) &lt;&lt;borders: &lt;&lt;ids: [ &#x27;;

                    for (i = 0; i &lt; step.args.corners; i++) {
                        set_str += &#x27;\&#x27;&#x27; + step.dest_sub_ids[i] + &#x27;\&#x27;&#x27;;
                        if (i !== step.args.corners - 1) {
                            set_str += &#x27;, &#x27;;
                        }
                        reset_str = &#x27;delete &#x27; + step.dest_sub_ids[i] + &#x27;; &#x27; + reset_str;
                    }
                    set_str += &#x27;]&#x27;;

                    set_str += &#x27;, names: [&#x27;;
                    for (i = 0; i &lt; step.args.corners; i++) {
                        set_str += &#x27;\&#x27;\&#x27;&#x27;;
                        if (i &lt; step.args.corners - 1) {
                            set_str += &#x27;, &#x27;;
                        }
                    }
                    set_str += &#x27;]&#x27;;

                    set_str += &#x27;&gt;&gt;, vertices: &lt;&lt;ids: [ &#x27;;
                    for (i = 0; i &lt; step.args.corners - 2; i++) {
                        set_str += &#x27;\&#x27;&#x27; + step.dest_sub_ids[i + parseInt(step.args.corners, 10)] + &#x27;\&#x27;&#x27;;
                        if (i !== step.args.corners - 3) {
                            set_str += &#x27;, &#x27;;
                        }
                        reset_str = &#x27;delete &#x27; + step.dest_sub_ids[i + parseInt(step.args.corners, 10)] + &#x27;; &#x27; + reset_str;
                    }
                    set_str += &#x27; ]&#x27;;
                    set_str += &#x27;, name: \&#x27;\&#x27;&#x27;;
                    set_str += &#x27;, fillColor: \&#x27;&#x27; + JXG.Options.intersection.fillColor + &#x27;\&#x27;&#x27;;
                    set_str += &#x27;, strokeColor: \&#x27;&#x27; + JXG.Options.intersection.strokeColor + &#x27;\&#x27;&#x27;;
                    set_str += &#x27;, opacity: \&#x27;&#x27; + JXG.Options.intersection.opacity + &#x27;\&#x27;&#x27;;
                    set_str += &#x27;&gt;&gt;, &#x27; + attrid;
                    set_str += &#x27; fillOpacity: &#x27; + JXG.Options.opacityLevel;
                    set_str += &#x27;, hasInnerPoints_Org: &#x27; + JXG.Options.polygon.hasInnerPoints;
                    set_str += &#x27;, hasInnerPoints: &#x27; + JXG.Options.polygon.hasInnerPoints;
                    set_str += &#x27;, name: \&#x27;\&#x27;&gt;&gt;; &#x27;;
                    reset_str = &#x27;delete &#x27; + step.dest_id + &#x27;; &#x27; + reset_str;
                    
                    break;

                case JXG.GENTYPE_SECTOR:
                    set_str = assign + &#x27;sector(&#x27; + step.src_ids.join(&#x27;, &#x27;) + &#x27;) &#x27;;
                    set_str += &#x27;&lt;&lt;&#x27;;
                    set_str += attrid + &#x27; name: \&#x27;\&#x27;, fillOpacity: &#x27; + JXG.Options.opacityLevel;
                    set_str += &#x27;, arc: &lt;&lt;id: \&#x27;&#x27; + step.dest_sub_ids[0] + &#x27;\&#x27;, priv: true&gt;&gt; &gt;&gt;; &#x27;;
                    reset_str = &#x27;delete &#x27; + step.dest_id + &#x27;; &#x27;;
                    break;

                case JXG.GENTYPE_ANGLE:
                    set_str = assign + &#x27;angle(&#x27; + step.src_ids.join(&#x27;, &#x27;) + &#x27;) &#x27;;
                    set_str += &#x27;&lt;&lt;&#x27;;
                    set_str += &#x27;dot: &lt;&lt;priv:true, id: \&#x27;&#x27; + step.dest_sub_ids[0] + &#x27;\&#x27;, name: \&#x27;&#x27; + step.dest_sub_ids[0] + &#x27;\&#x27;&gt;&gt;, &#x27;;
                    set_str += attrid + &#x27; fillOpacity: &#x27; + JXG.Options.opacityLevel + &#x27;&gt;&gt;; &#x27;;
                    reset_str = &#x27;delete &#x27; + step.dest_id + &#x27;; &#x27;;
                    reset_str += &#x27;delete &#x27; + step.dest_sub_ids[0] + &#x27;; &#x27;;
                    break;

                case JXG.GENTYPE_NONREFLEXANGLE:
                    set_str = assign + &#x27;nonreflexangle(&#x27; + step.src_ids.join(&#x27;, &#x27;) + &#x27;) &#x27;;
                    set_str += &#x27;&lt;&lt;&#x27;;
                    set_str += &#x27;dot: &lt;&lt;priv:true, id: \&#x27;&#x27; + step.dest_sub_ids[0] + &#x27;\&#x27;, &#x27;;
                    set_str += &#x27;name: \&#x27;&#x27; + step.dest_sub_ids[0] + &#x27;\&#x27;&gt;&gt;, &#x27;;
                    set_str += attrid + &#x27; fillOpacity: &#x27; + JXG.Options.opacityLevel + &#x27;&gt;&gt;; &#x27;;
                    reset_str = &#x27;delete &#x27; + step.dest_id + &#x27;; &#x27;;
                    reset_str += &#x27;delete &#x27; + step.dest_sub_ids[0] + &#x27;; &#x27;;
                    break;

                case JXG.GENTYPE_REFLEXANGLE:
                    set_str = assign + &#x27;reflexangle(&#x27; + step.src_ids.join(&#x27;, &#x27;) + &#x27;) &#x27;;
                    set_str += &#x27;&lt;&lt;&#x27;;
                    set_str += &#x27;dot: &lt;&lt;priv:true, id: \&#x27;&#x27; + step.dest_sub_ids[0] + &#x27;\&#x27;, &#x27;;
                    set_str += &#x27;name: \&#x27;&#x27; + step.dest_sub_ids[0] + &#x27;\&#x27;&gt;&gt;, &#x27;;
                    set_str += attrid + &#x27; fillOpacity: &#x27; + JXG.Options.opacityLevel + &#x27;&gt;&gt;; &#x27;;
                    reset_str = &#x27;delete &#x27; + step.dest_id + &#x27;; &#x27;;
                    reset_str += &#x27;delete &#x27; + step.dest_sub_ids[0] + &#x27;; &#x27;;
                    break;

                case JXG.GENTYPE_SLOPETRIANGLE:
                    // step.src_ids[0] may contain one or two parent elements.
                    set_str = assign + &#x27;slopetriangle(&#x27; + step.src_ids[0] + &#x27;) &lt;&lt;&#x27;;
                    set_str += attrid + &#x27; name: \&#x27;\&#x27;,&#x27;;
                    set_str += &#x27;borders: &lt;&lt;ids: [\&#x27;&#x27; + step.dest_sub_ids[4] + &#x27;\&#x27;, \&#x27;&#x27; + step.dest_sub_ids[5] + &#x27;\&#x27;, \&#x27;&#x27; + step.dest_sub_ids[6] + &#x27;\&#x27;]&gt;&gt;,&#x27;;
                    set_str += &#x27;basepoint: &lt;&lt;id: \&#x27;&#x27; + step.dest_sub_ids[0] + &#x27;\&#x27;&gt;&gt;, baseline: &lt;&lt;id: \&#x27;&#x27; + step.dest_sub_ids[1] + &#x27;\&#x27;&gt;&gt;,&#x27;;
                    set_str += &#x27;glider: &lt;&lt;id: \&#x27;&#x27; + step.dest_sub_ids[2] + &#x27;\&#x27;&gt;&gt;, toppoint: &lt;&lt;id: \&#x27;&#x27; + step.dest_sub_ids[3] + &#x27;\&#x27;&gt;&gt;&#x27;;
                    set_str += &#x27;&gt;&gt;;&#x27;;
                    reset_str = &#x27;delete &#x27; + step.dest_id + &#x27;; &#x27;;

                    break;

                case JXG.GENTYPE_PLOT:

                    set_str = assign + step.args.plot_type + &#x27;(&#x27; + step.args.func;

                    if (isNaN(step.args.a) || step.args.a == null)
                        step.args.a = &quot;-infinity&quot;;
                    if (isNaN(step.args.b) || step.args.b == null)
                        step.args.b = &quot;infinity&quot;;

                    if (step.args.a != step.args.b)
                        set_str += &#x27;, &#x27; + step.args.a + &#x27;, &#x27; + step.args.b;

                    set_str += &#x27;) &lt;&lt;&#x27;;

                    if (step.args.isPolar)
                        set_str += &#x27;curveType: \&#x27;polar\&#x27;, &#x27;;

                    set_str += attrid + &#x27;name: \&#x27;\&#x27;, withLabel: true, strokeColor: \&#x27;&#x27; + step.args.color + &#x27;\&#x27;, doAdvancedPlot: true, doAdvancedPlotOld: false &gt;&gt;; &#x27;;
                    reset_str = &#x27;delete &#x27; + step.dest_id + &#x27;; &#x27;;

                    break;

                case JXG.GENTYPE_SLIDER:
                    set_str = assign + &#x27;slider([&#x27; + pn(step.args.x1) + &#x27;, &#x27; + pn(step.args.y1) + &#x27;], [&#x27; + pn(step.args.x2);
                    set_str += &#x27;, &#x27; + pn(step.args.y2) + &#x27;], [&#x27; + pn(step.args.start) + &#x27;, &#x27; + pn(step.args.ini) + &#x27;, &#x27;;
                    set_str += pn(step.args.end) + &#x27;]) &lt;&lt;&#x27; + attrid;
                    set_str += &#x27; snapWidth: 0.1, &#x27;;
                    set_str += &#x27;baseline: &lt;&lt;id: \&#x27;&#x27;;
                    set_str += step.dest_sub_ids[0] + &#x27;\&#x27;, name: \&#x27;&#x27; + step.dest_sub_ids[0] + &#x27;\&#x27;, priv: true&gt;&gt;, highline: &lt;&lt;id: \&#x27;&#x27;;
                    set_str += step.dest_sub_ids[1] + &#x27;\&#x27;, name: \&#x27;&#x27; + step.dest_sub_ids[1] + &#x27;\&#x27;, priv: true&gt;&gt;, point1: &lt;&lt;id: \&#x27;&#x27;;
                    set_str += step.dest_sub_ids[2] + &#x27;\&#x27;, name: \&#x27;&#x27; + step.dest_sub_ids[2] + &#x27;\&#x27;, priv: true, frozen: true&gt;&gt;, point2: &lt;&lt;id: \&#x27;&#x27;;
                    set_str += step.dest_sub_ids[3] + &#x27;\&#x27;, name: \&#x27;&#x27; + step.dest_sub_ids[3] + &#x27;\&#x27;, priv: true, frozen: true&gt;&gt;, label: &lt;&lt;id: \&#x27;&#x27;;
                    set_str += step.dest_sub_ids[4] + &#x27;\&#x27;, name: \&#x27;&#x27; + step.dest_sub_ids[4] + &#x27;\&#x27;, priv: true&gt;&gt;&#x27;;
                    set_str += &#x27;, name: \&#x27;&#x27; + step.args.name + &#x27;\&#x27;&gt;&gt;; &#x27;;

                    reset_str = &#x27;delete &#x27; + step.dest_id + &#x27;; delete &#x27; + step.dest_sub_ids[4] + &#x27;; delete &#x27;;
                    reset_str += step.dest_sub_ids[3] + &#x27;; delete &#x27; + step.dest_sub_ids[2] + &#x27;; delete &#x27;;
                    reset_str += step.dest_sub_ids[1] + &#x27;; delete &#x27;;
                    reset_str += step.dest_sub_ids[0] + &#x27;; &#x27;;
                    break;

                /*
                 case JXG.GENTYPE_TRANSFORM:

                 set_str = step.dest_sub_ids[0] + &#x27; = transform(&#x27; + step.args.tmat + &#x27;) &lt;&lt;type: \&#x27;generic\&#x27;&gt;&gt;; &#x27;;
                 set_str += &#x27;point(&#x27; + step.src_ids[0] + &#x27;, &#x27; + step.dest_sub_ids[0] + &#x27;) &lt;&lt;id: \&#x27;&#x27; + step.dest_id;
                 set_str += &#x27;\&#x27;, visible: true&gt;&gt;; &#x27;;

                 reset_str = &#x27;delete &#x27; + step.dest_id + &#x27;; &#x27;;
                 reset_str += &#x27;delete &#x27; + step.dest_sub_ids[0] + &#x27;; &#x27;;

                 break;

                 case JXG.GENTYPE_PERPENDICULAR_BISECTOR:
                 if (step.args.create_line) {
                 sub_id = step.dest_sub_ids[2];
                 set_str = &#x27;line(&#x27; + step.src_ids[0] + &#x27;, &#x27; + step.src_ids[1] + &#x27;) &lt;&lt;id: \&#x27;&#x27; + sub_id;
                 set_str += &#x27;\&#x27;, visible: true&gt;&gt;; &#x27;;
                 reset_str = &#x27;delete &#x27; + sub_id + &#x27;; &#x27;;
                 } else {
                 sub_id = step.src_ids[2];
                 }

                 set_str += &#x27;midpoint(&#x27; + step.src_ids[0] + &#x27;, &#x27; + step.src_ids[1] + &#x27;) &lt;&lt;id: \&#x27;&#x27; + step.dest_sub_ids[0];
                 set_str += &#x27;\&#x27;, fillColor: \&#x27;&#x27; + step.args.fillColor + &#x27;\&#x27;&gt;&gt;; &#x27;;
                 set_str += assign + &#x27;normal(&#x27; + step.dest_sub_ids[0] + &#x27;, &#x27; + sub_id + &#x27;) &lt;&lt;&#x27; + attrid;
                 set_str += &#x27; point: &lt;&lt;id: \&#x27;&#x27; + step.dest_sub_ids[1] + &#x27;\&#x27;, name: \&#x27;&#x27; + step.dest_sub_ids[1];
                 set_str += &#x27;\&#x27;&gt;&gt; &gt;&gt;; &#x27;;
                 reset_str = &#x27;delete &#x27; + step.dest_sub_ids[0] + &#x27;; &#x27; + reset_str;
                 reset_str = &#x27;delete &#x27; + step.dest_id + &#x27;; delete &#x27; + step.dest_sub_ids[1] + &#x27;; &#x27; + reset_str;
                 break;
                 */

                case JXG.GENTYPE_DELETE:

                    arr = [];
                    ctx_set_str = [];
                    ctx_reset_str = [];

                    for (i = 0; i &lt; step.args.steps.length; i++) {

                        if (step_log[step.args.steps[i]].type &gt; 50) {
                            arr = this.generateJCodeMeta(step_log[step.args.steps[i]], board);
                        } else {
                            arr = this.generateJCode(step_log[step.args.steps[i]], board, step_log);
                        }
                        
                        if (arr.length &gt;= 3 &amp;&amp; JXG.trim(arr[2]) !== &#x27;&#x27;) {
                            set_str = arr[2] + set_str;
                        }
                        if (arr.length &gt;= 4 &amp;&amp; JXG.isFunction(arr[3])) {
                            ctx_set_str.unshift(arr[3]);
                        }
                        if (arr.length &gt;= 1 &amp;&amp; JXG.trim(arr[0]) !== &#x27;&#x27;) {
                            reset_str += arr[0];
                        }
                        if (arr.length &gt;= 2 &amp;&amp; JXG.isFunction(arr[1])) {
                            ctx_reset_str.push(arr[1]);
                        }
                    }

                    break;

                case JXG.GENTYPE_COPY:
                    copy_log = [];

                    // Adapt the steps to the new IDs
                    for (el in step.args.steps) {
                        if (step.args.steps.hasOwnProperty(el)) {
                            step2 = JXG.deepCopy(step_log[step.args.steps[el]]);

                            if (step2.type === JXG.GENTYPE_COPY) {
                                for (i = 0; i &lt; step2.args.map.length; i++) {
                                    for (j = 0; j &lt; step.args.map.length; j++) {
                                        if (step2.args.map[i].copy === step.args.map[j].orig) {
                                            step2.args.map[i].copy = step.args.map[j].copy;
                                        }
                                    }
                                }

                                step2 = JXG.SketchReader.replaceStepDestIds(step2, step2.args.map);
                            } else {
                                step2 = JXG.SketchReader.replaceStepDestIds(step2, step.args.map);
                            }

                            copy_log.push(step2);
                        }
                    }

                    for (i = 0; i &lt; copy_log.length; i++) {
                        if (copy_log[i].type &gt; 50) {
                            arr = this.generateJCodeMeta(copy_log[i], board);
                        } else {
                            arr = this.generateJCode(copy_log[i], board, step_log);
                        }

                        if (JXG.trim(arr[0]) !== &#x27;&#x27;) {
                            set_str += arr[0];
                        }

                        if (JXG.isFunction(arr[1])) {
                            ctx_set_str.push(arr[1]);
                        }

                        if (JXG.trim(arr[2]) !== &#x27;&#x27;) {
                            reset_str = arr[2] + reset_str;
                        }

                        if (JXG.isFunction(arr[3])) {
                            ctx_reset_str.unshift(arr[3]);
                        }
                    }

                    // Apply the offset-translation to the free points of the copy
                    if (step.args.dep_copy) {
                        for (i = 0; i &lt; step.args.map.length; i++) {
                            if (getObject(step.args.map[i].orig).elementClass === JXG.OBJECT_CLASS_POINT) {
                                set_str += step.args.map[i].copy;
                                set_str += &#x27;.X = function() { return (&#x27; + step.args.map[i].orig + &#x27;.X() - &#x27;;
                                set_str += pn(step.args.x) + &#x27;); }; &#x27;;
                                set_str += step.args.map[i].copy;
                                set_str += &#x27;.Y = function() { return (&#x27; + step.args.map[i].orig + &#x27;.Y() - &#x27;;
                                set_str += pn(step.args.y) + &#x27;); }; &#x27;;
                            }
                        }
                    } else {
                        for (i = 0; i &lt; step.args.free_points.length; i++) {
                            xstart = getObject(step.args.free_points[i].orig).coords.usrCoords[1];
                            ystart = getObject(step.args.free_points[i].orig).coords.usrCoords[2];

                            set_str += step.args.free_points[i].copy + &#x27;.X = function() { return &#x27;;
                            set_str += pn(xstart - step.args.x) + &#x27;; }; &#x27;;
                            set_str += step.args.free_points[i].copy + &#x27;.Y = function() { return &#x27;;
                            set_str += pn(ystart - step.args.y) + &#x27;; }; &#x27;;
                            set_str += step.args.free_points[i].copy + &#x27;.free(); &#x27;;
                        }
                    }

                    for (j = 0; j &lt; step.args.map.length; j++) {
                        el = getObject(step.args.map[j].orig);

                        // Check if a radius-defined circle should be copied
                        if (el.type === JXG.OBJECT_TYPE_CIRCLE &amp;&amp; !JXG.exists(el.point2)) {
                            // Make the radius of the circle copy depend on the original circle&#x27;s radius
                            set_str += step.args.map[j].copy + &#x27;.setRadius(function () { return &#x27;;
                            set_str += step.args.map[j].orig + &#x27;.radius(); }); &#x27;;
                        }
                    }

                    break;

                case JXG.GENTYPE_ABLATION:

                    xstart = getObject(step.src_ids[0]).coords.usrCoords[1];
                    ystart = getObject(step.src_ids[0]).coords.usrCoords[2];

                    set_str = &#x27;point(&#x27; + pn(xstart - step.args.x) + &#x27;, &#x27; + pn(ystart - step.args.y) + &#x27;) &lt;&lt;id: \&#x27;&#x27;;
                    set_str += step.dest_sub_ids[0] + &#x27;\&#x27;, name: \&#x27;\&#x27;, withLabel: false&gt;&gt;; &#x27;;
                    set_str += &#x27;circle(\&#x27;&#x27; + step.dest_sub_ids[0] + &#x27;\&#x27;, 1) &lt;&lt;id: \&#x27;&#x27; + step.dest_sub_ids[1];
                    set_str += &#x27;\&#x27;, fillOpacity: &#x27; + JXG.Options.opacityLevel;
                    set_str += &#x27;, strokeColor: \&#x27;#888888\&#x27;, visible: true, name: \&#x27;\&#x27;, withLabel: false&gt;&gt;; &#x27;;

                    if (step.args.fids.length === 1) {
                        step.args.func = step.args.fids[0] + &#x27;.radius()&#x27;;
                    } else {
                        step.args.func = &#x27;dist(&#x27; + step.args.fids[0] + &#x27;, &#x27; + step.args.fids[1] + &#x27;)&#x27;;
                    }

                    set_str += step.dest_sub_ids[1] + &#x27;.setRadius(function() { return &#x27; + step.args.func + &#x27;; }); &#x27;;
                    
                    for (j = 0; j &lt; step.src_ids.length; j++) {
                        set_str += step.src_ids[j] + &#x27;.addChild(&#x27; + step.dest_sub_ids[0] + &#x27;); &#x27;;
                        set_str += step.src_ids[j] + &#x27;.addChild(&#x27; + step.dest_sub_ids[1] + &#x27;); &#x27;;
                    }
                    
                    if (step.args.migrate !== 0 &amp;&amp; step.args.migrate !== -1) {
                        set_str += &#x27;$board.migratePoint(&#x27; + step.dest_sub_ids[0] + &#x27;, &#x27; + step.args.migrate + &#x27;); &#x27;;
                    }

                    reset_str = &#x27;delete &#x27; + step.dest_sub_ids[1] + &#x27;; delete &#x27; + step.dest_sub_ids[0] + &#x27;; &#x27;;

                    break;

                case JXG.GENTYPE_VECTORCOPY:

                    xstart = getObject(step.src_ids[0]).coords.usrCoords[1];
                    ystart = getObject(step.src_ids[0]).coords.usrCoords[2];

                    set_str = &#x27;point(&#x27; + pn(xstart - step.args.x) + &#x27;, &#x27; + pn(ystart - step.args.y) + &#x27;) &lt;&lt;id: \&#x27;&#x27;;
                    set_str += step.dest_sub_ids[0] + &#x27;\&#x27;, name: \&#x27;\&#x27;, withLabel: false&gt;&gt;; &#x27;;
                    set_str += &#x27;parallelpoint(\&#x27;&#x27; + step.src_ids[0] + &#x27;\&#x27;,\&#x27;&#x27; + step.src_ids[1] + &#x27;\&#x27;,\&#x27;&#x27; + step.dest_sub_ids[0] + &#x27;\&#x27;) &lt;&lt;id: \&#x27;&#x27; + step.dest_sub_ids[1];
                    set_str += &#x27;\&#x27;, strokeColor: \&#x27;#888888\&#x27;, visible: true, priv: false, name: \&#x27;\&#x27;, &#x27;;
                    set_str += &#x27;layer: &#x27; + JXG.Options.layer.line + &#x27;, size: 2, opacity: 0.2, withLabel: false&gt;&gt;; &#x27;;
                    set_str += &#x27;arrow(\&#x27;&#x27; + step.dest_sub_ids[0] + &#x27;\&#x27;,\&#x27;&#x27; + step.dest_sub_ids[1]  + &#x27;\&#x27;) &lt;&lt;id: \&#x27;&#x27; + step.dest_sub_ids[2];
                    set_str += &#x27;\&#x27;, strokeColor: \&#x27;#888888\&#x27;, visible: true, name: \&#x27;\&#x27;, withLabel: false&gt;&gt;; &#x27;;

                    for (j = 0; j &lt; step.src_ids.length; j++) {
                        set_str += step.src_ids[j] + &#x27;.addChild(&#x27; + step.dest_sub_ids[0] + &#x27;); &#x27;;
                        set_str += step.src_ids[j] + &#x27;.addChild(&#x27; + step.dest_sub_ids[1] + &#x27;); &#x27;;
                        set_str += step.src_ids[j] + &#x27;.addChild(&#x27; + step.dest_sub_ids[2] + &#x27;); &#x27;;
                    }

                    if (step.args.migrate !== 0 &amp;&amp; step.args.migrate !== -1) {
                        set_str += &#x27;$board.migratePoint(&#x27; + step.dest_sub_ids[0] + &#x27;, &#x27; + step.args.migrate + &#x27;); &#x27;;
                    }

                    reset_str = &#x27;delete &#x27; + step.dest_sub_ids[1] + &#x27;; delete &#x27; + step.dest_sub_ids[0] + &#x27;; delete &#x27; + step.dest_sub_ids[2] + &#x27;;&#x27;;

                    break;

                case JXG.GENTYPE_MOVEMENT:

                    if (step.args.obj_type === JXG.OBJECT_TYPE_LINE || step.args.obj_type === JXG.OBJECT_TYPE_VECTOR) {
                        set_str = step.src_ids[0] + &#x27;.move([&#x27; + pn(step.args.coords[0].usrCoords[0]) + &#x27;, &#x27;;
                        set_str += pn(step.args.coords[0].usrCoords[1]) + &#x27;, &#x27; + pn(step.args.coords[0].usrCoords[2]) + &#x27;]); &#x27;;
                        reset_str = step.src_ids[0] + &#x27;.move([&#x27; + step.args.zstart[0] + &#x27;, &#x27; + step.args.xstart[0] + &#x27;, &#x27;;
                        reset_str += step.args.ystart[0] + &#x27;]); &#x27;;

                        set_str += step.src_ids[1] + &#x27;.move([&#x27; + pn(step.args.coords[1].usrCoords[0]) + &#x27;, &#x27;;
                        set_str += pn(step.args.coords[1].usrCoords[1]) + &#x27;, &#x27; + pn(step.args.coords[1].usrCoords[2]) + &#x27;]); &#x27;;
                        reset_str += step.src_ids[1] + &#x27;.move([&#x27; + step.args.zstart[1] + &#x27;, &#x27; + step.args.xstart[1] + &#x27;, &#x27;;
                        reset_str += step.args.ystart[1] + &#x27;]); &#x27;;

                    } else if (step.args.obj_type === JXG.OBJECT_TYPE_CIRCLE) {
                        set_str = step.src_ids[0] + &#x27;.move([&#x27; + pn(step.args.coords[0].usrCoords[1]) + &#x27;, &#x27;;
                        set_str += pn(step.args.coords[0].usrCoords[2]) + &#x27;]); &#x27;;
                        reset_str = step.src_ids[0] + &#x27;.move([&#x27; + step.args.xstart + &#x27;, &#x27; + step.args.ystart + &#x27;]); &#x27;;

                        if (step.args.has_point2) {
                            set_str += step.src_ids[1] + &#x27;.move([&#x27; + pn(step.args.coords[1].usrCoords[1]) + &#x27;, &#x27;;
                            set_str += pn(step.args.coords[1].usrCoords[2]) + &#x27;]); &#x27;;
                            reset_str += step.src_ids[1] + &#x27;.move([&#x27; + step.args.old_p2x + &#x27;, &#x27; + step.args.old_p2y;
                            reset_str += &#x27;]); &#x27;;
                        }

                    } else if (step.args.obj_type === JXG.OBJECT_TYPE_POLYGON) {
                        set_str = reset_str = &quot;&quot;;

                        for (i = 0; i &lt; step.src_ids.length; i++) {
                            set_str += step.src_ids[i] + &#x27;.move([&#x27; + pn(step.args.coords[i].usrCoords[1]) + &#x27;, &#x27;;
                            set_str += pn(step.args.coords[i].usrCoords[2]) + &#x27;]); &#x27;;
                            reset_str += step.src_ids[i] + &#x27;.move([&#x27; + step.args.xstart[i] + &#x27;, &#x27; + step.args.ystart[i];
                            reset_str += &#x27;]); &#x27;;
                        }

                    } else {
                        // Upwards compatibility of pre 1.0 files
                        if (JXG.exists(step.args.coords[0])) {
                            set_str = step.src_ids[0] + &#x27;.move([&#x27; + pn(step.args.coords[0].usrCoords[1]) + &#x27;, &#x27;;
                            set_str += pn(step.args.coords[0].usrCoords[2]) + &#x27;]); &#x27;;
    
                            reset_str = step.src_ids[0] + &#x27;.move([&#x27; + step.args.xstart + &#x27;, &#x27; + step.args.ystart + &#x27;]); &#x27;;
                        } 
                    }

                    break;

                default:
                    JXG.debug(&quot;No such GENTYPE!&quot; + step.type);
                    return [];
            }

            return [set_str, ctx_set_str, reset_str, ctx_reset_str];
        },

        replaceStepDestIds: function (step, id_map) {
            var i, j, copy_ids = [];

            for (i = 0; i &lt; id_map.length; i++) {
                copy_ids.push(id_map[i].copy);

                if (step.dest_id === id_map[i].orig) {
                    step.dest_id = id_map[i].copy;
                }

                for (j = 0; j &lt; step.dest_sub_ids.length; j++) {
                    if (step.dest_sub_ids[j] === id_map[i].orig) {
                        step.dest_sub_ids[j] = id_map[i].copy;
                    }
                }

                for (j = 0; j &lt; step.src_ids.length; j++) {
                    if (step.src_ids[j] === id_map[i].orig) {
                        step.src_ids[j] = id_map[i].copy;
                    }
                }
            }

            for (j = 0; j &lt; step.dest_sub_ids.length; j++) {
                if (!JXG.isInArray(copy_ids, step.dest_sub_ids[j])) {
                    step.dest_sub_ids[j] = this.id();
                }
            }

            step.src_ids = JXG.uniqueArray(step.src_ids);
            step.dest_sub_ids = JXG.uniqueArray(step.dest_sub_ids);

            return step;
        }
    });

    JXG.registerReader(JXG.SketchReader, [&#x27;sketch&#x27;, &#x27;sketchometry&#x27;]);
}());

    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>

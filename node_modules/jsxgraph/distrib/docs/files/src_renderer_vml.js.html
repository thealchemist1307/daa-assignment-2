<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src/renderer/vml.js - JSXGraph</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="../assets/js/jsxgraphcore.js"></script>
    <link rel="stylesheet" href="../assets/css/jsxgraph.css">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../assets/css/logo_blue.png" title="JSXGraph" width="117" height="52"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.99.4</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/Angle.html">Angle</a> </li>
                                <li><a href="../classes/Arc.html">Arc</a> </li>
                                <li><a href="../classes/Arrow.html">Arrow</a> </li>
                                <li><a href="../classes/Arrowparallel.html">Arrowparallel</a> </li>
                                <li><a href="../classes/Axis.html">Axis</a> </li>
                                <li><a href="../classes/Bisector.html">Bisector</a> </li>
                                <li><a href="../classes/Bisectorlines.html">Bisectorlines</a> </li>
                                <li><a href="../classes/Button.html">Button</a> </li>
                                <li><a href="../classes/Checkbox.html">Checkbox</a> </li>
                                <li><a href="../classes/Circle.html">Circle</a> </li>
                                <li><a href="../classes/Circumcenter.html">Circumcenter</a> </li>
                                <li><a href="../classes/Circumcircle.html">Circumcircle</a> </li>
                                <li><a href="../classes/CircumcircleArc.html">CircumcircleArc</a> </li>
                                <li><a href="../classes/CircumcircleSector.html">CircumcircleSector</a> </li>
                                <li><a href="../classes/Conic.html">Conic</a> </li>
                                <li><a href="../classes/Curve.html">Curve</a> </li>
                                <li><a href="../classes/Ellipse.html">Ellipse</a> </li>
                                <li><a href="../classes/EventEmitter.html">EventEmitter</a> </li>
                                <li><a href="../classes/Functiongraph.html">Functiongraph</a> </li>
                                <li><a href="../classes/Glider.html">Glider</a> </li>
                                <li><a href="../classes/Grid.html">Grid</a> </li>
                                <li><a href="../classes/Group.html">Group</a> </li>
                                <li><a href="../classes/Hatch.html">Hatch</a> </li>
                                <li><a href="../classes/Hyperbola.html">Hyperbola</a> </li>
                                <li><a href="../classes/Image.html">Image</a> </li>
                                <li><a href="../classes/Incenter.html">Incenter</a> </li>
                                <li><a href="../classes/Incircle.html">Incircle</a> </li>
                                <li><a href="../classes/Inequality.html">Inequality</a> </li>
                                <li><a href="../classes/Input.html">Input</a> </li>
                                <li><a href="../classes/Integral.html">Integral</a> </li>
                                <li><a href="../classes/Intersection.html">Intersection</a> </li>
                                <li><a href="../classes/JXG.html">JXG</a> </li>
                                <li><a href="../classes/JXG.AbstractRenderer.html">JXG.AbstractRenderer</a> </li>
                                <li><a href="../classes/JXG.Board.html">JXG.Board</a> </li>
                                <li><a href="../classes/JXG.C.html">JXG.C</a> </li>
                                <li><a href="../classes/JXG.CanvasRenderer.html">JXG.CanvasRenderer</a> </li>
                                <li><a href="../classes/JXG.Chart.html">JXG.Chart</a> </li>
                                <li><a href="../classes/JXG.Circle.html">JXG.Circle</a> </li>
                                <li><a href="../classes/JXG.Complex.html">JXG.Complex</a> </li>
                                <li><a href="../classes/JXG.Composition.html">JXG.Composition</a> </li>
                                <li><a href="../classes/JXG.Coords.html">JXG.Coords</a> </li>
                                <li><a href="../classes/JXG.CoordsElement.html">JXG.CoordsElement</a> </li>
                                <li><a href="../classes/JXG.Curve.html">JXG.Curve</a> </li>
                                <li><a href="../classes/JXG.GeometryElement.html">JXG.GeometryElement</a> </li>
                                <li><a href="../classes/JXG.Group.html">JXG.Group</a> </li>
                                <li><a href="../classes/JXG.Image.html">JXG.Image</a> </li>
                                <li><a href="../classes/JXG.JSXGraph.html">JXG.JSXGraph</a> </li>
                                <li><a href="../classes/JXG.Line.html">JXG.Line</a> </li>
                                <li><a href="../classes/JXG.Math.html">JXG.Math</a> </li>
                                <li><a href="../classes/JXG.Math.Geometry.html">JXG.Math.Geometry</a> </li>
                                <li><a href="../classes/JXG.Math.Numerics.html">JXG.Math.Numerics</a> </li>
                                <li><a href="../classes/JXG.Math.Poly.html">JXG.Math.Poly</a> </li>
                                <li><a href="../classes/JXG.Math.Poly.Monomial.html">JXG.Math.Poly.Monomial</a> </li>
                                <li><a href="../classes/JXG.Math.Poly.Polynomial.html">JXG.Math.Poly.Polynomial</a> </li>
                                <li><a href="../classes/JXG.Math.Poly.Ring.html">JXG.Math.Poly.Ring</a> </li>
                                <li><a href="../classes/JXG.Math.Quadtree.html">JXG.Math.Quadtree</a> </li>
                                <li><a href="../classes/JXG.Math.Statistics.html">JXG.Math.Statistics</a> </li>
                                <li><a href="../classes/JXG.Math.Symbolic.html">JXG.Math.Symbolic</a> </li>
                                <li><a href="../classes/JXG.NoRenderer.html">JXG.NoRenderer</a> </li>
                                <li><a href="../classes/JXG.Options.html">JXG.Options</a> </li>
                                <li><a href="../classes/JXG.Point.html">JXG.Point</a> </li>
                                <li><a href="../classes/JXG.Polygon.html">JXG.Polygon</a> </li>
                                <li><a href="../classes/JXG.SVGRenderer.html">JXG.SVGRenderer</a> </li>
                                <li><a href="../classes/JXG.Text.html">JXG.Text</a> </li>
                                <li><a href="../classes/JXG.Ticks.html">JXG.Ticks</a> </li>
                                <li><a href="../classes/JXG.Transformation.html">JXG.Transformation</a> </li>
                                <li><a href="../classes/JXG.Turtle.html">JXG.Turtle</a> </li>
                                <li><a href="../classes/JXG.Util.Base64.html">JXG.Util.Base64</a> </li>
                                <li><a href="../classes/JXG.Util.Unzip.html">JXG.Util.Unzip</a> </li>
                                <li><a href="../classes/JXG.VMLRenderer.html">JXG.VMLRenderer</a> </li>
                                <li><a href="../classes/Line.html">Line</a> </li>
                                <li><a href="../classes/Locus.html">Locus</a> </li>
                                <li><a href="../classes/MajorArc.html">MajorArc</a> </li>
                                <li><a href="../classes/Midpoint.html">Midpoint</a> </li>
                                <li><a href="../classes/MinorArc.html">MinorArc</a> </li>
                                <li><a href="../classes/MinorSector.html">MinorSector</a> </li>
                                <li><a href="../classes/Mirrorpoint.html">Mirrorpoint</a> </li>
                                <li><a href="../classes/NonReflexAngle.html">NonReflexAngle</a> </li>
                                <li><a href="../classes/Normal.html">Normal</a> </li>
                                <li><a href="../classes/Orthogonalprojection.html">Orthogonalprojection</a> </li>
                                <li><a href="../classes/OtherIntersection.html">OtherIntersection</a> </li>
                                <li><a href="../classes/Parabola.html">Parabola</a> </li>
                                <li><a href="../classes/Parallel.html">Parallel</a> </li>
                                <li><a href="../classes/Parallelpoint.html">Parallelpoint</a> </li>
                                <li><a href="../classes/Perpendicular.html">Perpendicular</a> </li>
                                <li><a href="../classes/PerpendicularPoint.html">PerpendicularPoint</a> </li>
                                <li><a href="../classes/PerpendicularSegment.html">PerpendicularSegment</a> </li>
                                <li><a href="../classes/Point.html">Point</a> </li>
                                <li><a href="../classes/PolarLine.html">PolarLine</a> </li>
                                <li><a href="../classes/PolePoint.html">PolePoint</a> </li>
                                <li><a href="../classes/Polygon.html">Polygon</a> </li>
                                <li><a href="../classes/RadicalAxis.html">RadicalAxis</a> </li>
                                <li><a href="../classes/Reflection.html">Reflection</a> </li>
                                <li><a href="../classes/ReflexAngle.html">ReflexAngle</a> </li>
                                <li><a href="../classes/registerReader.html">registerReader</a> </li>
                                <li><a href="../classes/RegularPolygon.html">RegularPolygon</a> </li>
                                <li><a href="../classes/Riemannsum.html">Riemannsum</a> </li>
                                <li><a href="../classes/Sector.html">Sector</a> </li>
                                <li><a href="../classes/Segment.html">Segment</a> </li>
                                <li><a href="../classes/Semicircle.html">Semicircle</a> </li>
                                <li><a href="../classes/Slider.html">Slider</a> </li>
                                <li><a href="../classes/Slopetriangle.html">Slopetriangle</a> </li>
                                <li><a href="../classes/Spline.html">Spline</a> </li>
                                <li><a href="../classes/Stepfunction.html">Stepfunction</a> </li>
                                <li><a href="../classes/Tangent.html">Tangent</a> </li>
                                <li><a href="../classes/Tapemeasure.html">Tapemeasure</a> </li>
                                <li><a href="../classes/Text.html">Text</a> </li>
                                <li><a href="../classes/Ticks.html">Ticks</a> </li>
                                <li><a href="../classes/Tracecurve.html">Tracecurve</a> </li>
                                <li><a href="../classes/Transformation.html">Transformation</a> </li>
                                <li><a href="../classes/Turtle.html">Turtle</a> </li>
                            </ul>
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="../modules/JXG.html">JXG</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: src/renderer/vml.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/*
    Copyright 2008-2015
        Matthias Ehmann,
        Michael Gerhaeuser,
        Carsten Miller,
        Bianca Valentin,
        Alfred Wassermann,
        Peter Wilfahrt

    This file is part of JSXGraph.

    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.

    You can redistribute it and/or modify it under the terms of the

      * GNU Lesser General Public License as published by
        the Free Software Foundation, either version 3 of the License, or
        (at your option) any later version
      OR
      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT

    JSXGraph is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License and
    the MIT License along with JSXGraph. If not, see &lt;http://www.gnu.org/licenses/&gt;
    and &lt;http://opensource.org/licenses/MIT/&gt;.
 */


/*global JXG: true, define: true, AMprocessNode: true, MathJax: true, document: true */
/*jslint nomen: true, plusplus: true, newcap:true*/

/* depends:
 jxg
 renderer/abstract
 base/constants
 utils/type
 utils/color
 math/math
 math/numerics
*/

define([
    &#x27;jxg&#x27;, &#x27;renderer/abstract&#x27;, &#x27;base/constants&#x27;, &#x27;utils/type&#x27;, &#x27;utils/color&#x27;, &#x27;math/math&#x27;, &#x27;math/numerics&#x27;
], function (JXG, AbstractRenderer, Const, Type, Color, Mat, Numerics) {

    &quot;use strict&quot;;

    /**
     * Uses VML to implement the rendering methods defined in {@link JXG.AbstractRenderer}.
     * @class JXG.VMLRenderer
     * @extends JXG.AbstractRenderer
     * @param {Node} container Reference to a DOM node containing the board.
     * @see JXG.AbstractRenderer
     */
    JXG.VMLRenderer = function (container) {
        this.type = &#x27;vml&#x27;;

        this.container = container;
        this.container.style.overflow = &#x27;hidden&#x27;;
        if (this.container.style.position === &#x27;&#x27;) {
            this.container.style.position = &#x27;relative&#x27;;
        }
        this.container.onselectstart = function () {
            return false;
        };

        this.resolution = 10; // Paths are drawn with a a resolution of this.resolution/pixel.

        // Add VML includes and namespace
        // Original: IE &lt;=7
        //container.ownerDocument.createStyleSheet().addRule(&quot;v\\:*&quot;, &quot;behavior: url(#default#VML);&quot;);
        if (!Type.exists(JXG.vmlStylesheet)) {
            container.ownerDocument.namespaces.add(&quot;jxgvml&quot;, &quot;urn:schemas-microsoft-com:vml&quot;);
            JXG.vmlStylesheet = this.container.ownerDocument.createStyleSheet();
            JXG.vmlStylesheet.addRule(&quot;.jxgvml&quot;, &quot;behavior:url(#default#VML)&quot;);
        }

        try {
            if (!container.ownerDocument.namespaces.jxgvml) {
                container.ownerDocument.namespaces.add(&quot;jxgvml&quot;, &quot;urn:schemas-microsoft-com:vml&quot;);
            }

            this.createNode = function (tagName) {
                return container.ownerDocument.createElement(&#x27;&lt;jxgvml:&#x27; + tagName + &#x27; class=&quot;jxgvml&quot;&gt;&#x27;);
            };
        } catch (e) {
            this.createNode = function (tagName) {
                return container.ownerDocument.createElement(&#x27;&lt;&#x27; + tagName + &#x27; xmlns=&quot;urn:schemas-microsoft.com:vml&quot; class=&quot;jxgvml&quot;&gt;&#x27;);
            };
        }

        // dash styles
        this.dashArray = [&#x27;Solid&#x27;, &#x27;1 1&#x27;, &#x27;ShortDash&#x27;, &#x27;Dash&#x27;, &#x27;LongDash&#x27;, &#x27;ShortDashDot&#x27;, &#x27;LongDashDot&#x27;];
    };

    JXG.VMLRenderer.prototype = new AbstractRenderer();

    JXG.extend(JXG.VMLRenderer.prototype, /** @lends JXG.VMLRenderer */ {

        /**
         * Sets attribute &lt;tt&gt;key&lt;/tt&gt; of node &lt;tt&gt;node&lt;/tt&gt; to &lt;tt&gt;value&lt;/tt&gt;.
         * @param {Node} node A DOM node.
         * @param {String} key Name of the attribute.
         * @param {String} val New value of the attribute.
         * @param {Boolean} [iFlag=false] If false, the attribute&#x27;s name is case insensitive.
         */
        _setAttr: function (node, key, val, iFlag) {
            try {
                if (this.container.ownerDocument.documentMode === 8) {
                    node[key] = val;
                } else {
                    node.setAttribute(key, val, iFlag);
                }
            } catch (e) {
                JXG.debug(&#x27;_setAttr:&#x27;/*node.id*/ + &#x27; &#x27; + key + &#x27; &#x27; + val + &#x27;&lt;br&gt;\n&#x27;);
            }
        },

        /* ******************************** *
         *  This renderer does not need to
         *  override draw/update* methods
         *  since it provides draw/update*Prim
         *  methods.
         * ******************************** */

        /* **************************
         *    Lines
         * **************************/

        // documented in AbstractRenderer
        updateTicks: function (ticks) {
            var i, len, c, x, y,
                r = this.resolution,
                tickArr = [];

            len = ticks.ticks.length;
            for (i = 0; i &lt; len; i++) {
                c = ticks.ticks[i];
                x = c[0];
                y = c[1];

                if (typeof x[0] === &#x27;number&#x27; &amp;&amp; typeof x[1] === &#x27;number&#x27;) {
                    tickArr.push(&#x27; m &#x27; + Math.round(r * x[0]) + &#x27;, &#x27; + Math.round(r * y[0]) +
                        &#x27; l &#x27; + Math.round(r * x[1]) + &#x27;, &#x27; + Math.round(r * y[1]) + &#x27; &#x27;);
                }
            }

            if (!Type.exists(ticks.rendNode)) {
                ticks.rendNode = this.createPrim(&#x27;path&#x27;, ticks.id);
                this.appendChildPrim(ticks.rendNode, ticks.visProp.layer);
            }

            this._setAttr(ticks.rendNode, &#x27;stroked&#x27;, &#x27;true&#x27;);
            this._setAttr(ticks.rendNode, &#x27;strokecolor&#x27;, ticks.visProp.strokecolor, 1);
            this._setAttr(ticks.rendNode, &#x27;strokeweight&#x27;, ticks.visProp.strokewidth);
            this._setAttr(ticks.rendNodeStroke, &#x27;opacity&#x27;, (ticks.visProp.strokeopacity * 100) + &#x27;%&#x27;);
            this.updatePathPrim(ticks.rendNode, tickArr, ticks.board);
        },

        /* **************************
         *    Text related stuff
         * **************************/

        // already documented in JXG.AbstractRenderer
        displayCopyright: function (str, fontsize) {
            var node, t;

            node = this.createNode(&#x27;textbox&#x27;);
            node.style.position = &#x27;absolute&#x27;;
            this._setAttr(node, &#x27;id&#x27;, this.container.id + &#x27;_&#x27; + &#x27;licenseText&#x27;);

            node.style.left = 20;
            node.style.top = 2;
            node.style.fontSize = fontsize;
            node.style.color = &#x27;#356AA0&#x27;;
            node.style.fontFamily = &#x27;Arial,Helvetica,sans-serif&#x27;;
            this._setAttr(node, &#x27;opacity&#x27;, &#x27;30%&#x27;);
            node.style.filter = &quot;progid:DXImageTransform.Microsoft.Matrix(M11=&#x27;1.0&#x27;, sizingMethod=&#x27;auto expand&#x27;, enabled = false) progid:DXImageTransform.Microsoft.Alpha(opacity = 30, enabled = true)&quot;;

            t = this.container.ownerDocument.createTextNode(str);
            node.appendChild(t);
            this.appendChildPrim(node, 0);
        },

        // documented in AbstractRenderer
        drawInternalText: function (el) {
            var node;
            node = this.createNode(&#x27;textbox&#x27;);
            node.style.position = &#x27;absolute&#x27;;
            /*
             if (this.container.ownerDocument.documentMode === 8) {                 // IE 8
             node.setAttribute(&#x27;class&#x27;, el.visProp.cssclass);
             } else {
             node.setAttribute(this.container.ownerDocument.all ? &#x27;className&#x27; : &#x27;class&#x27;, el.visProp.cssclass);
             }
             */
            el.rendNodeText = this.container.ownerDocument.createTextNode(&#x27;&#x27;);
            node.appendChild(el.rendNodeText);
            this.appendChildPrim(node, 9);
            node.style.filter = &quot;progid:DXImageTransform.Microsoft.Matrix(M11=&#x27;1.0&#x27;, sizingMethod=&#x27;auto expand&#x27;, enabled = false) progid:DXImageTransform.Microsoft.Alpha(opacity = 100, enabled = false)&quot;;

            return node;
        },

        // documented in AbstractRenderer
        updateInternalText: function (el) {
            var v, content = el.plaintext,
                m = this.joinTransforms(el, el.transformations),
                offset = [0, 0],
                maxX, maxY, minX, minY, i,
                node = el.rendNode,
                p = [];

            if (!isNaN(el.coords.scrCoords[1] + el.coords.scrCoords[2])) {
                // Horizontal
                if (el.visProp.anchorx === &#x27;right&#x27;) {
                    offset[0] = 1;
                } else if (el.visProp.anchorx === &#x27;middle&#x27;) {
                    offset[0] = 0.5;
                } // default (el.visProp.anchorx === &#x27;left&#x27;) offset[0] = 0;

                // Vertical
                if (el.visProp.anchory === &#x27;bottom&#x27;) {
                    offset[1] = 1;
                } else if (el.visProp.anchory === &#x27;middle&#x27;) {
                    offset[1] = 0.5;
                } // default (el.visProp.anchory === &#x27;top&#x27;) offset[1] = 0;

                // Compute maxX, maxY, minX, minY
                p[0] = Mat.matVecMult(m, [1,
                                          el.coords.scrCoords[1] - offset[0] * el.size[0],
                                          el.coords.scrCoords[2] + (1 - offset[1]) * el.size[1] + this.vOffsetText]);
                p[0][1] /= p[0][0];
                p[0][2] /= p[0][0];
                p[1] = Mat.matVecMult(m, [1,
                                          el.coords.scrCoords[1] + (1 - offset[0]) * el.size[0],
                                          el.coords.scrCoords[2] + (1 - offset[1]) * el.size[1] + this.vOffsetText]);
                p[1][1] /= p[1][0];
                p[1][2] /= p[1][0];
                p[2] = Mat.matVecMult(m, [1,
                                          el.coords.scrCoords[1] + (1 - offset[0]) * el.size[0],
                                          el.coords.scrCoords[2] - offset[1] * el.size[1] + this.vOffsetText]);
                p[2][1] /= p[2][0];
                p[2][2] /= p[2][0];
                p[3] = Mat.matVecMult(m, [1,
                                          el.coords.scrCoords[1] - offset[0] * el.size[0],
                                          el.coords.scrCoords[2] - offset[1] * el.size[1] + this.vOffsetText]);
                p[3][1] /= p[3][0];
                p[3][2] /= p[3][0];
                maxX = p[0][1];
                minX = p[0][1];
                maxY = p[0][2];
                minY = p[0][2];

                for (i = 1; i &lt; 4; i++) {
                    maxX = Math.max(maxX, p[i][1]);
                    minX = Math.min(minX, p[i][1]);
                    maxY = Math.max(maxY, p[i][2]);
                    minY = Math.min(minY, p[i][2]);
                }

                // Horizontal
                v = offset[0] === 1 ? Math.floor(el.board.canvasWidth - maxX) : Math.floor(minX);
                if (el.visPropOld.left !== (el.visProp.anchorx + v)) {
                    if (offset[0] === 1) {
                        el.rendNode.style.right = v + &#x27;px&#x27;;
                        el.rendNode.style.left = &#x27;auto&#x27;;
                    } else {
                        el.rendNode.style.left = v + &#x27;px&#x27;;
                        el.rendNode.style.right = &#x27;auto&#x27;;
                    }
                    el.visPropOld.left = el.visProp.anchorx + v;
                }

                // Vertical
                v = offset[1] === 1 ? Math.floor(el.board.canvasHeight - maxY) : Math.floor(minY);
                if (el.visPropOld.top !== (el.visProp.anchory + v)) {
                    if (offset[1] === 1) {
                        el.rendNode.style.bottom = v + &#x27;px&#x27;;
                        el.rendNode.style.top = &#x27;auto&#x27;;
                    } else {
                        el.rendNode.style.top = v + &#x27;px&#x27;;
                        el.rendNode.style.bottom = &#x27;auto&#x27;;
                    }
                    el.visPropOld.top = el.visProp.anchory + v;
                }

            }

            if (el.htmlStr !== content) {
                el.rendNodeText.data = content;
                el.htmlStr = content;
            }

            //this.transformImage(el, el.transformations);
            node.filters.item(0).M11 = m[1][1];
            node.filters.item(0).M12 = m[1][2];
            node.filters.item(0).M21 = m[2][1];
            node.filters.item(0).M22 = m[2][2];
            node.filters.item(0).enabled = true;
        },

        /* **************************
         *    Image related stuff
         * **************************/

        // already documented in JXG.AbstractRenderer
        drawImage: function (el) {
            // IE 8: Bilder ueber data URIs werden bis 32kB unterstuetzt.
            var node;

            node = this.container.ownerDocument.createElement(&#x27;img&#x27;);
            node.style.position = &#x27;absolute&#x27;;
            this._setAttr(node, &#x27;id&#x27;, this.container.id + &#x27;_&#x27; + el.id);

            this.container.appendChild(node);
            this.appendChildPrim(node, el.visProp.layer);

            // Adding the rotation filter. This is always filter item 0:
            // node.filters.item(0), see transformImage
            // Also add the alpha filter. This is always filter item 1
            // node.filters.item(1), see setObjectFillColor and setObjectSTrokeColor
            //node.style.filter = node.style[&#x27;-ms-filter&#x27;] = &quot;progid:DXImageTransform.Microsoft.Matrix(M11=&#x27;1.0&#x27;, sizingMethod=&#x27;auto expand&#x27;)&quot;;
            node.style.filter = &quot;progid:DXImageTransform.Microsoft.Matrix(M11=&#x27;1.0&#x27;, sizingMethod=&#x27;auto expand&#x27;) progid:DXImageTransform.Microsoft.Alpha(opacity = 100, enabled = false)&quot;;
            el.rendNode = node;
            this.updateImage(el);
        },

        // already documented in JXG.AbstractRenderer
        transformImage: function (el, t) {
            var m, s, maxX, maxY, minX, minY, i, nt,
                node = el.rendNode,
                p = [],
                len = t.length;

            if (len &gt; 0) {
                /*
                nt = el.rendNode.style.filter.toString();
                if (!nt.match(/DXImageTransform/)) {
                    node.style.filter = &quot;progid:DXImageTransform.Microsoft.Matrix(M11=&#x27;1.0&#x27;, sizingMethod=&#x27;auto expand&#x27;) &quot; + nt;
                }
                */

                m = this.joinTransforms(el, t);
                p[0] = Mat.matVecMult(m, el.coords.scrCoords);
                p[0][1] /= p[0][0];
                p[0][2] /= p[0][0];
                p[1] = Mat.matVecMult(m, [1, el.coords.scrCoords[1] + el.size[0], el.coords.scrCoords[2]]);
                p[1][1] /= p[1][0];
                p[1][2] /= p[1][0];
                p[2] = Mat.matVecMult(m, [1, el.coords.scrCoords[1] + el.size[0], el.coords.scrCoords[2] - el.size[1]]);
                p[2][1] /= p[2][0];
                p[2][2] /= p[2][0];
                p[3] = Mat.matVecMult(m, [1, el.coords.scrCoords[1], el.coords.scrCoords[2] - el.size[1]]);
                p[3][1] /= p[3][0];
                p[3][2] /= p[3][0];
                maxX = p[0][1];
                minX = p[0][1];
                maxY = p[0][2];
                minY = p[0][2];

                for (i = 1; i &lt; 4; i++) {
                    maxX = Math.max(maxX, p[i][1]);
                    minX = Math.min(minX, p[i][1]);
                    maxY = Math.max(maxY, p[i][2]);
                    minY = Math.min(minY, p[i][2]);
                }
                node.style.left = Math.floor(minX) + &#x27;px&#x27;;
                node.style.top  = Math.floor(minY) + &#x27;px&#x27;;

                node.filters.item(0).M11 = m[1][1];
                node.filters.item(0).M12 = m[1][2];
                node.filters.item(0).M21 = m[2][1];
                node.filters.item(0).M22 = m[2][2];
                node.filters.item(0).enabled = true;
            }
        },

        // already documented in JXG.AbstractRenderer
        updateImageURL: function (el) {
            var url = Type.evaluate(el.url);

            this._setAttr(el.rendNode, &#x27;src&#x27;, url);
        },

        /* **************************
         * Render primitive objects
         * **************************/

        // already documented in JXG.AbstractRenderer
        appendChildPrim: function (node, level) {
            // For trace nodes
            if (!Type.exists(level)) {
                level = 0;
            }

            node.style.zIndex = level;
            this.container.appendChild(node);

            return node;
        },

        // already documented in JXG.AbstractRenderer
        appendNodesToElement: function (element, type) {
            if (type === &#x27;shape&#x27; || type === &#x27;path&#x27; || type === &#x27;polygon&#x27;) {
                element.rendNodePath = this.getElementById(element.id + &#x27;_path&#x27;);
            }
            element.rendNodeFill = this.getElementById(element.id + &#x27;_fill&#x27;);
            element.rendNodeStroke = this.getElementById(element.id + &#x27;_stroke&#x27;);
            element.rendNodeShadow = this.getElementById(element.id + &#x27;_shadow&#x27;);
            element.rendNode = this.getElementById(element.id);
        },

        // already documented in JXG.AbstractRenderer
        createPrim: function (type, id) {
            var node, pathNode,
                fillNode = this.createNode(&#x27;fill&#x27;),
                strokeNode = this.createNode(&#x27;stroke&#x27;),
                shadowNode = this.createNode(&#x27;shadow&#x27;);

            this._setAttr(fillNode, &#x27;id&#x27;, this.container.id + &#x27;_&#x27; + id + &#x27;_fill&#x27;);
            this._setAttr(strokeNode, &#x27;id&#x27;, this.container.id + &#x27;_&#x27; + id + &#x27;_stroke&#x27;);
            this._setAttr(shadowNode, &#x27;id&#x27;, this.container.id + &#x27;_&#x27; + id + &#x27;_shadow&#x27;);

            if (type === &#x27;circle&#x27; || type === &#x27;ellipse&#x27;) {
                node = this.createNode(&#x27;oval&#x27;);
                node.appendChild(fillNode);
                node.appendChild(strokeNode);
                node.appendChild(shadowNode);
            } else if (type === &#x27;polygon&#x27; || type === &#x27;path&#x27; || type === &#x27;shape&#x27; || type === &#x27;line&#x27;) {
                node = this.createNode(&#x27;shape&#x27;);
                node.appendChild(fillNode);
                node.appendChild(strokeNode);
                node.appendChild(shadowNode);
                pathNode = this.createNode(&#x27;path&#x27;);
                this._setAttr(pathNode, &#x27;id&#x27;, this.container.id + &#x27;_&#x27; + id + &#x27;_path&#x27;);
                node.appendChild(pathNode);
            } else {
                node = this.createNode(type);
                node.appendChild(fillNode);
                node.appendChild(strokeNode);
                node.appendChild(shadowNode);
            }

            node.style.position = &#x27;absolute&#x27;;
            node.style.left = &#x27;0px&#x27;;
            node.style.top = &#x27;0px&#x27;;
            this._setAttr(node, &#x27;id&#x27;, this.container.id + &#x27;_&#x27; + id);

            return node;
        },

        // already documented in JXG.AbstractRenderer
        remove: function (node) {
            if (Type.exists(node)) {
                node.removeNode(true);
            }
        },

        // already documented in JXG.AbstractRenderer
        makeArrows: function (el) {
            var nodeStroke;

            if (el.visPropOld.firstarrow === el.visProp.firstarrow &amp;&amp; el.visPropOld.lastarrow === el.visProp.lastarrow) {
                return;
            }

            if (el.visProp.firstarrow) {
                nodeStroke = el.rendNodeStroke;
                this._setAttr(nodeStroke, &#x27;startarrow&#x27;, &#x27;block&#x27;);
                this._setAttr(nodeStroke, &#x27;startarrowlength&#x27;, &#x27;long&#x27;);
            } else {
                nodeStroke = el.rendNodeStroke;
                if (Type.exists(nodeStroke)) {
                    this._setAttr(nodeStroke, &#x27;startarrow&#x27;, &#x27;none&#x27;);
                }
            }

            if (el.visProp.lastarrow) {
                nodeStroke = el.rendNodeStroke;
                this._setAttr(nodeStroke, &#x27;id&#x27;, this.container.id + &#x27;_&#x27; + el.id + &quot;stroke&quot;);
                this._setAttr(nodeStroke, &#x27;endarrow&#x27;, &#x27;block&#x27;);
                this._setAttr(nodeStroke, &#x27;endarrowlength&#x27;, &#x27;long&#x27;);
            } else {
                nodeStroke = el.rendNodeStroke;
                if (Type.exists(nodeStroke)) {
                    this._setAttr(nodeStroke, &#x27;endarrow&#x27;, &#x27;none&#x27;);
                }
            }
            el.visPropOld.firstarrow = el.visProp.firstarrow;
            el.visPropOld.lastarrow = el.visProp.lastarrow;
        },

        // already documented in JXG.AbstractRenderer
        updateEllipsePrim: function (node, x, y, rx, ry) {
            node.style.left = Math.floor(x - rx) + &#x27;px&#x27;;
            node.style.top =  Math.floor(y - ry) + &#x27;px&#x27;;
            node.style.width = Math.floor(Math.abs(rx) * 2) + &#x27;px&#x27;;
            node.style.height = Math.floor(Math.abs(ry) * 2) + &#x27;px&#x27;;
        },

        // already documented in JXG.AbstractRenderer
        updateLinePrim: function (node, p1x, p1y, p2x, p2y, board) {
            var s, r = this.resolution;

            if (!isNaN(p1x + p1y + p2x + p2y)) {
                s = [&#x27;m &#x27;, Math.floor(r * p1x), &#x27;, &#x27;, Math.floor(r * p1y), &#x27; l &#x27;, Math.floor(r * p2x), &#x27;, &#x27;, Math.floor(r * p2y)];
                this.updatePathPrim(node, s, board);
            }
        },

        // already documented in JXG.AbstractRenderer
        updatePathPrim: function (node, pointString, board) {
            var x = board.canvasWidth,
                y = board.canvasHeight;
            if (pointString.length &lt;= 0) {
                pointString = [&#x27;m 0,0&#x27;];
            }
            node.style.width = x;
            node.style.height = y;
            this._setAttr(node, &#x27;coordsize&#x27;, [Math.floor(this.resolution * x), Math.floor(this.resolution * y)].join(&#x27;,&#x27;));
            this._setAttr(node, &#x27;path&#x27;, pointString.join(&quot;&quot;));
        },

        // already documented in JXG.AbstractRenderer
        updatePathStringPoint: function (el, size, type) {
            var s = [],
                mround = Math.round,
                scr = el.coords.scrCoords,
                sqrt32 = size * Math.sqrt(3) * 0.5,
                s05 = size * 0.5,
                r = this.resolution;

            if (type === &#x27;x&#x27;) {
                s.push([
                    &#x27; m &#x27;, mround(r * (scr[1] - size)), &#x27;, &#x27;, mround(r * (scr[2] - size)),
                    &#x27; l &#x27;, mround(r * (scr[1] + size)), &#x27;, &#x27;, mround(r * (scr[2] + size)),
                    &#x27; m &#x27;, mround(r * (scr[1] + size)), &#x27;, &#x27;, mround(r * (scr[2] - size)),
                    &#x27; l &#x27;, mround(r * (scr[1] - size)), &#x27;, &#x27;, mround(r * (scr[2] + size))
                ].join(&#x27;&#x27;));
            } else if (type === &#x27;+&#x27;) {
                s.push([
                    &#x27; m &#x27;, mround(r * (scr[1] - size)), &#x27;, &#x27;, mround(r * (scr[2])),
                    &#x27; l &#x27;, mround(r * (scr[1] + size)), &#x27;, &#x27;, mround(r * (scr[2])),
                    &#x27; m &#x27;, mround(r * (scr[1])),        &#x27;, &#x27;, mround(r * (scr[2] - size)),
                    &#x27; l &#x27;, mround(r * (scr[1])),        &#x27;, &#x27;, mround(r * (scr[2] + size))
                ].join(&#x27;&#x27;));
            } else if (type === &#x27;&lt;&gt;&#x27;) {

                s.push([
                    &#x27; m &#x27;, mround(r * (scr[1] - size)), &#x27;, &#x27;, mround(r * (scr[2])),
                    &#x27; l &#x27;, mround(r * (scr[1])),        &#x27;, &#x27;, mround(r * (scr[2] + size)),
                    &#x27; l &#x27;, mround(r * (scr[1] + size)), &#x27;, &#x27;, mround(r * (scr[2])),
                    &#x27; l &#x27;, mround(r * (scr[1])),        &#x27;, &#x27;, mround(r * (scr[2] - size)),
                    &#x27; x e &#x27;
                ].join(&#x27;&#x27;));
            } else if (type === &#x27;^&#x27;) {
                s.push([
                    &#x27; m &#x27;, mround(r * (scr[1])),          &#x27;, &#x27;, mround(r * (scr[2] - size)),
                    &#x27; l &#x27;, mround(r * (scr[1] - sqrt32)), &#x27;, &#x27;, mround(r * (scr[2] + s05)),
                    &#x27; l &#x27;, mround(r * (scr[1] + sqrt32)), &#x27;, &#x27;, mround(r * (scr[2] + s05)),
                    &#x27; x e &#x27;
                ].join(&#x27;&#x27;));
            } else if (type === &#x27;v&#x27;) {
                s.push([
                    &#x27; m &#x27;, mround(r * (scr[1])),          &#x27;, &#x27;, mround(r * (scr[2] + size)),
                    &#x27; l &#x27;, mround(r * (scr[1] - sqrt32)), &#x27;, &#x27;, mround(r * (scr[2] - s05)),
                    &#x27; l &#x27;, mround(r * (scr[1] + sqrt32)), &#x27;, &#x27;, mround(r * (scr[2] - s05)),
                    &#x27; x e &#x27;
                ].join(&#x27;&#x27;));
            } else if (type === &#x27;&gt;&#x27;) {
                s.push([
                    &#x27; m &#x27;, mround(r * (scr[1] + size)), &#x27;, &#x27;, mround(r * (scr[2])),
                    &#x27; l &#x27;, mround(r * (scr[1] - s05)),  &#x27;, &#x27;, mround(r * (scr[2] - sqrt32)),
                    &#x27; l &#x27;, mround(r * (scr[1] - s05)),  &#x27;, &#x27;, mround(r * (scr[2] + sqrt32)),
                    &#x27; l &#x27;, mround(r * (scr[1] + size)), &#x27;, &#x27;, mround(r * (scr[2]))
                ].join(&#x27;&#x27;));
            } else if (type === &#x27;&lt;&#x27;) {
                s.push([
                    &#x27; m &#x27;, mround(r * (scr[1] - size)), &#x27;, &#x27;, mround(r * (scr[2])),
                    &#x27; l &#x27;, mround(r * (scr[1] + s05)),  &#x27;, &#x27;, mround(r * (scr[2] - sqrt32)),
                    &#x27; l &#x27;, mround(r * (scr[1] + s05)),  &#x27;, &#x27;, mround(r * (scr[2] + sqrt32)),
                    &#x27; x e &#x27;
                ].join(&#x27;&#x27;));
            }

            return s;
        },

        // already documented in JXG.AbstractRenderer
        updatePathStringPrim: function (el) {
            var i, scr,
                pStr = [],
                r = this.resolution,
                mround = Math.round,
                symbm = &#x27; m &#x27;,
                symbl = &#x27; l &#x27;,
                symbc = &#x27; c &#x27;,
                nextSymb = symbm,
                // isNotPlot = (el.visProp.curvetype !== &#x27;plot&#x27;),
                len = Math.min(el.numberPoints, 8192); // otherwise IE 7 crashes in hilbert.html

            if (el.numberPoints &lt;= 0) {
                return &#x27;&#x27;;
            }
            len = Math.min(len, el.points.length);

            if (el.bezierDegree === 1) {
                /*
                if (isNotPlot &amp;&amp; el.board.options.curve.RDPsmoothing) {
                    el.points = Numerics.RamerDouglasPeucker(el.points, 1.0);
                }
                */

                for (i = 0; i &lt; len; i++) {
                    scr = el.points[i].scrCoords;
                    if (isNaN(scr[1]) || isNaN(scr[2])) {  // PenUp
                        nextSymb = symbm;
                    } else {
                        // IE has problems with values  being too far away.
                        if (scr[1] &gt; 20000.0) {
                            scr[1] = 20000.0;
                        } else if (scr[1] &lt; -20000.0) {
                            scr[1] = -20000.0;
                        }

                        if (scr[2] &gt; 20000.0) {
                            scr[2] = 20000.0;
                        } else if (scr[2] &lt; -20000.0) {
                            scr[2] = -20000.0;
                        }

                        pStr.push([nextSymb, mround(r * scr[1]), &#x27;, &#x27;, mround(r * scr[2])].join(&#x27;&#x27;));
                        nextSymb = symbl;
                    }
                }
            } else if (el.bezierDegree === 3) {
                i = 0;
                while (i &lt; len) {
                    scr = el.points[i].scrCoords;
                    if (isNaN(scr[1]) || isNaN(scr[2])) {  // PenUp
                        nextSymb = symbm;
                    } else {
                        pStr.push([nextSymb, mround(r * scr[1]), &#x27;, &#x27;, mround(r * scr[2])].join(&#x27;&#x27;));
                        if (nextSymb === symbc) {
                            i += 1;
                            scr = el.points[i].scrCoords;
                            pStr.push([&#x27; &#x27;, mround(r * scr[1]), &#x27;, &#x27;, mround(r * scr[2])].join(&#x27;&#x27;));
                            i += 1;
                            scr = el.points[i].scrCoords;
                            pStr.push([&#x27; &#x27;, mround(r * scr[1]), &#x27;, &#x27;, mround(r * scr[2])].join(&#x27;&#x27;));
                        }
                        nextSymb = symbc;
                    }
                    i += 1;
                }
            }
            pStr.push(&#x27; e&#x27;);
            return pStr;
        },

        // already documented in JXG.AbstractRenderer
        updatePathStringBezierPrim: function (el) {
            var i, j, k, scr, lx, ly,
                pStr = [],
                f = el.visProp.strokewidth,
                r = this.resolution,
                mround = Math.round,
                symbm = &#x27; m &#x27;,
                symbl = &#x27; c &#x27;,
                nextSymb = symbm,
                isNoPlot = (el.visProp.curvetype !== &#x27;plot&#x27;),
                len = Math.min(el.numberPoints, 8192); // otherwise IE 7 crashes in hilbert.html

            if (el.numberPoints &lt;= 0) {
                return &#x27;&#x27;;
            }
            if (isNoPlot &amp;&amp; el.board.options.curve.RDPsmoothing) {
                el.points = Numerics.RamerDouglasPeucker(el.points, 1.0);
            }
            len = Math.min(len, el.points.length);

            for (j = 1; j &lt; 3; j++) {
                nextSymb = symbm;
                for (i = 0; i &lt; len; i++) {
                    scr = el.points[i].scrCoords;
                    if (isNaN(scr[1]) || isNaN(scr[2])) {  // PenUp
                        nextSymb = symbm;
                    } else {
                        // IE has problems with values  being too far away.
                        if (scr[1] &gt; 20000.0) {
                            scr[1] = 20000.0;
                        } else if (scr[1] &lt; -20000.0) {
                            scr[1] = -20000.0;
                        }

                        if (scr[2] &gt; 20000.0) {
                            scr[2] = 20000.0;
                        } else if (scr[2] &lt; -20000.0) {
                            scr[2] = -20000.0;
                        }

                        if (nextSymb === symbm) {
                            pStr.push([nextSymb,
                                mround(r * (scr[1])), &#x27; &#x27;, mround(r * (scr[2]))].join(&#x27;&#x27;));
                        } else {
                            k = 2 * j;
                            pStr.push([nextSymb,
                                mround(r * (lx + (scr[1] - lx) * 0.333 + f * (k * Math.random() - j))), &#x27; &#x27;,
                                mround(r * (ly + (scr[2] - ly) * 0.333 + f * (k * Math.random() - j))), &#x27; &#x27;,
                                mround(r * (lx + (scr[1] - lx) * 0.666 + f * (k * Math.random() - j))), &#x27; &#x27;,
                                mround(r * (ly + (scr[2] - ly) * 0.666 + f * (k * Math.random() - j))), &#x27; &#x27;,
                                mround(r * scr[1]), &#x27; &#x27;,
                                mround(r * scr[2])].join(&#x27;&#x27;));
                        }
                        nextSymb = symbl;
                        lx = scr[1];
                        ly = scr[2];
                    }
                }
            }
            pStr.push(&#x27; e&#x27;);
            return pStr;
        },

        // already documented in JXG.AbstractRenderer
        updatePolygonPrim: function (node, el) {
            var i,
                len = el.vertices.length,
                r = this.resolution,
                scr,
                pStr = [];

            this._setAttr(node, &#x27;stroked&#x27;, &#x27;false&#x27;);
            scr = el.vertices[0].coords.scrCoords;

            if (isNaN(scr[1] + scr[2])) {
                return;
            }

            pStr.push([&quot;m &quot;, Math.floor(r * scr[1]), &quot;,&quot;, Math.floor(r * scr[2]), &quot; l &quot;].join(&#x27;&#x27;));

            for (i = 1; i &lt; len - 1; i++) {
                if (el.vertices[i].isReal) {
                    scr = el.vertices[i].coords.scrCoords;

                    if (isNaN(scr[1] + scr[2])) {
                        return;
                    }

                    pStr.push(Math.floor(r * scr[1]) + &quot;,&quot; + Math.floor(r * scr[2]));
                } else {
                    this.updatePathPrim(node, &#x27;&#x27;, el.board);
                    return;
                }
                if (i &lt; len - 2) {
                    pStr.push(&quot;, &quot;);
                }
            }
            pStr.push(&quot; x e&quot;);
            this.updatePathPrim(node, pStr, el.board);
        },

        // already documented in JXG.AbstractRenderer
        updateRectPrim: function (node, x, y, w, h) {
            node.style.left = Math.floor(x) + &#x27;px&#x27;;
            node.style.top = Math.floor(y) + &#x27;px&#x27;;

            if (w &gt;= 0) {
                node.style.width = w + &#x27;px&#x27;;
            }

            if (h &gt;= 0) {
                node.style.height = h + &#x27;px&#x27;;
            }
        },

        /* **************************
         *  Set Attributes
         * **************************/

        // already documented in JXG.AbstractRenderer
        setPropertyPrim: function (node, key, val) {
            var keyVml = &#x27;&#x27;,
                v;

            switch (key) {
            case &#x27;stroke&#x27;:
                keyVml = &#x27;strokecolor&#x27;;
                break;
            case &#x27;stroke-width&#x27;:
                keyVml = &#x27;strokeweight&#x27;;
                break;
            case &#x27;stroke-dasharray&#x27;:
                keyVml = &#x27;dashstyle&#x27;;
                break;
            }

            if (keyVml !== &#x27;&#x27;) {
                v = Type.evaluate(val);
                this._setAttr(node, keyVml, v);
            }
        },

        // already documented in JXG.AbstractRenderer
        show: function (el) {
            if (el &amp;&amp; el.rendNode) {
                el.rendNode.style.visibility = &quot;inherit&quot;;
            }
        },

        // already documented in JXG.AbstractRenderer
        hide: function (el) {
            if (el &amp;&amp; el.rendNode) {
                el.rendNode.style.visibility = &quot;hidden&quot;;
            }
        },

        // already documented in JXG.AbstractRenderer
        setDashStyle: function (el, visProp) {
            var node;
            if (visProp.dash &gt;= 0) {
                node = el.rendNodeStroke;
                this._setAttr(node, &#x27;dashstyle&#x27;, this.dashArray[visProp.dash]);
            }
        },

        // already documented in JXG.AbstractRenderer
        setGradient: function (el) {
            var nodeFill = el.rendNodeFill;

            if (el.visProp.gradient === &#x27;linear&#x27;) {
                this._setAttr(nodeFill, &#x27;type&#x27;, &#x27;gradient&#x27;);
                this._setAttr(nodeFill, &#x27;color2&#x27;, el.visProp.gradientsecondcolor);
                this._setAttr(nodeFill, &#x27;opacity2&#x27;, el.visProp.gradientsecondopacity);
                this._setAttr(nodeFill, &#x27;angle&#x27;, el.visProp.gradientangle);
            } else if (el.visProp.gradient === &#x27;radial&#x27;) {
                this._setAttr(nodeFill, &#x27;type&#x27;, &#x27;gradientradial&#x27;);
                this._setAttr(nodeFill, &#x27;color2&#x27;, el.visProp.gradientsecondcolor);
                this._setAttr(nodeFill, &#x27;opacity2&#x27;, el.visProp.gradientsecondopacity);
                this._setAttr(nodeFill, &#x27;focusposition&#x27;, el.visProp.gradientpositionx * 100 + &#x27;%,&#x27; + el.visProp.gradientpositiony * 100 + &#x27;%&#x27;);
                this._setAttr(nodeFill, &#x27;focussize&#x27;, &#x27;0,0&#x27;);
            } else {
                this._setAttr(nodeFill, &#x27;type&#x27;, &#x27;solid&#x27;);
            }
        },

        // already documented in JXG.AbstractRenderer
        setObjectFillColor: function (el, color, opacity) {
            var rgba = Type.evaluate(color), c, rgbo,
                o = Type.evaluate(opacity), oo,
                node = el.rendNode,
                t;

            o = (o &gt; 0) ? o : 0;

            if (el.visPropOld.fillcolor === rgba &amp;&amp; el.visPropOld.fillopacity === o) {
                return;
            }

            if (Type.exists(rgba) &amp;&amp; rgba !== false) {
                // RGB, not RGBA
                if (rgba.length !== 9) {
                    c = rgba;
                    oo = o;
                // True RGBA, not RGB
                } else {
                    rgbo = Color.rgba2rgbo(rgba);
                    c = rgbo[0];
                    oo = o * rgbo[1];
                }
                if (c === &#x27;none&#x27; || c === false) {
                    this._setAttr(el.rendNode, &#x27;filled&#x27;, &#x27;false&#x27;);
                } else {
                    this._setAttr(el.rendNode, &#x27;filled&#x27;, &#x27;true&#x27;);
                    this._setAttr(el.rendNode, &#x27;fillcolor&#x27;, c);

                    if (Type.exists(oo) &amp;&amp; el.rendNodeFill) {
                        this._setAttr(el.rendNodeFill, &#x27;opacity&#x27;, (oo * 100) + &#x27;%&#x27;);
                    }
                }
                if (el.type === Const.OBJECT_TYPE_IMAGE) {
                    /*
                    t = el.rendNode.style.filter.toString();
                    if (t.match(/alpha/)) {
                        el.rendNode.style.filter = t.replace(/alpha\(opacity *= *[0-9\.]+\)/, &#x27;alpha(opacity = &#x27; + (oo * 100) + &#x27;)&#x27;);
                    } else {
                        el.rendNode.style.filter += &#x27; alpha(opacity = &#x27; + (oo * 100) + &#x27;)&#x27;;
                    }
                    */
                    if (node.filters.length &gt; 1) {
                        // Why am I sometimes seeing node.filters.length==0 here when I move the pointer around near [0,0]? 
                        // Setting axes:true shows text labels!
                        node.filters.item(1).opacity = Math.round(oo * 100); // Why does setObjectFillColor not use Math.round?
                        node.filters.item(1).enabled = true;
                    }
                }
            }
            el.visPropOld.fillcolor = rgba;
            el.visPropOld.fillopacity = o;
        },

        // already documented in JXG.AbstractRenderer
        setObjectStrokeColor: function (el, color, opacity) {
            var rgba = Type.evaluate(color), c, rgbo, t,
                o = Type.evaluate(opacity), oo,
                node = el.rendNode, nodeStroke;

            o = (o &gt; 0) ? o : 0;

            if (el.visPropOld.strokecolor === rgba &amp;&amp; el.visPropOld.strokeopacity === o) {
                return;
            }

            // this looks like it could be merged with parts of VMLRenderer.setObjectFillColor

            if (Type.exists(rgba) &amp;&amp; rgba !== false) {
                // RGB, not RGBA
                if (rgba.length !== 9) {
                    c = rgba;
                    oo = o;
                // True RGBA, not RGB
                } else {
                    rgbo = color.rgba2rgbo(rgba);
                    c = rgbo[0];
                    oo = o * rgbo[1];
                }
                if (el.elementClass === Const.OBJECT_CLASS_TEXT) {
                    //node.style.filter = &#x27; alpha(opacity = &#x27; + oo + &#x27;)&#x27;;
                    /*
                    t = node.style.filter.toString();
                    if (t.match(/alpha/)) {
                        node.style.filter = 
                        t.replace(/alpha\(opacity *= *[0-9\.]+\)/, &#x27;alpha(opacity = &#x27; + oo + &#x27;)&#x27;);
                    } else {
                        node.style.filter += &#x27; alpha(opacity = &#x27; + oo + &#x27;)&#x27;;
                    }
                    */
                    if (node.filters.length &gt; 1) {
                        // Why am I sometimes seeing node.filters.length==0 here when I move the pointer around near [0,0]? 
                        // Setting axes:true shows text labels!
                        node.filters.item(1).opacity = Math.round(oo * 100);
                        node.filters.item(1).enabled = true;
                    }

                    node.style.color = c;
                } else {
                    if (c !== false) {
                        this._setAttr(node, &#x27;stroked&#x27;, &#x27;true&#x27;);
                        this._setAttr(node, &#x27;strokecolor&#x27;, c);
                    }

                    nodeStroke = el.rendNodeStroke;
                    if (Type.exists(oo) &amp;&amp; el.type !== Const.OBJECT_TYPE_IMAGE) {
                        this._setAttr(nodeStroke, &#x27;opacity&#x27;, (oo * 100) + &#x27;%&#x27;);
                    }
                }
            }
            el.visPropOld.strokecolor = rgba;
            el.visPropOld.strokeopacity = o;
        },

        // already documented in JXG.AbstractRenderer
        setObjectStrokeWidth: function (el, width) {
            var w = Type.evaluate(width),
                node;

            if (isNaN(w) || el.visPropOld.strokewidth === w) {
                return;
            }

            node = el.rendNode;
            this.setPropertyPrim(node, &#x27;stroked&#x27;, &#x27;true&#x27;);

            if (Type.exists(w)) {

                this.setPropertyPrim(node, &#x27;stroke-width&#x27;, w);
                if (w === 0 &amp;&amp; Type.exists(el.rendNodeStroke)) {
                    this._setAttr(node, &#x27;stroked&#x27;, &#x27;false&#x27;);
                }
            }

            el.visPropOld.strokewidth = w;

        },

        // already documented in JXG.AbstractRenderer
        setShadow: function (el) {
            var nodeShadow = el.rendNodeShadow;

            if (!nodeShadow || el.visPropOld.shadow === el.visProp.shadow) {
                return;
            }

            if (el.visProp.shadow) {
                this._setAttr(nodeShadow, &#x27;On&#x27;, &#x27;True&#x27;);
                this._setAttr(nodeShadow, &#x27;Offset&#x27;, &#x27;3pt,3pt&#x27;);
                this._setAttr(nodeShadow, &#x27;Opacity&#x27;, &#x27;60%&#x27;);
                this._setAttr(nodeShadow, &#x27;Color&#x27;, &#x27;#aaaaaa&#x27;);
            } else {
                this._setAttr(nodeShadow, &#x27;On&#x27;, &#x27;False&#x27;);
            }

            el.visPropOld.shadow = el.visProp.shadow;
        },

        /* **************************
         * renderer control
         * **************************/

        // already documented in JXG.AbstractRenderer
        suspendRedraw: function () {
            this.container.style.display = &#x27;none&#x27;;
        },

        // already documented in JXG.AbstractRenderer
        unsuspendRedraw: function () {
            this.container.style.display = &#x27;&#x27;;
        }
    });

    return JXG.VMLRenderer;
});

    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>

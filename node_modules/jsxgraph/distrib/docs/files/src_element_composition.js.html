<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src/element/composition.js - JSXGraph</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="../assets/js/jsxgraphcore.js"></script>
    <link rel="stylesheet" href="../assets/css/jsxgraph.css">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../assets/css/logo_blue.png" title="JSXGraph" width="117" height="52"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.99.4</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/Angle.html">Angle</a> </li>
                                <li><a href="../classes/Arc.html">Arc</a> </li>
                                <li><a href="../classes/Arrow.html">Arrow</a> </li>
                                <li><a href="../classes/Arrowparallel.html">Arrowparallel</a> </li>
                                <li><a href="../classes/Axis.html">Axis</a> </li>
                                <li><a href="../classes/Bisector.html">Bisector</a> </li>
                                <li><a href="../classes/Bisectorlines.html">Bisectorlines</a> </li>
                                <li><a href="../classes/Button.html">Button</a> </li>
                                <li><a href="../classes/Checkbox.html">Checkbox</a> </li>
                                <li><a href="../classes/Circle.html">Circle</a> </li>
                                <li><a href="../classes/Circumcenter.html">Circumcenter</a> </li>
                                <li><a href="../classes/Circumcircle.html">Circumcircle</a> </li>
                                <li><a href="../classes/CircumcircleArc.html">CircumcircleArc</a> </li>
                                <li><a href="../classes/CircumcircleSector.html">CircumcircleSector</a> </li>
                                <li><a href="../classes/Conic.html">Conic</a> </li>
                                <li><a href="../classes/Curve.html">Curve</a> </li>
                                <li><a href="../classes/Ellipse.html">Ellipse</a> </li>
                                <li><a href="../classes/EventEmitter.html">EventEmitter</a> </li>
                                <li><a href="../classes/Functiongraph.html">Functiongraph</a> </li>
                                <li><a href="../classes/Glider.html">Glider</a> </li>
                                <li><a href="../classes/Grid.html">Grid</a> </li>
                                <li><a href="../classes/Group.html">Group</a> </li>
                                <li><a href="../classes/Hatch.html">Hatch</a> </li>
                                <li><a href="../classes/Hyperbola.html">Hyperbola</a> </li>
                                <li><a href="../classes/Image.html">Image</a> </li>
                                <li><a href="../classes/Incenter.html">Incenter</a> </li>
                                <li><a href="../classes/Incircle.html">Incircle</a> </li>
                                <li><a href="../classes/Inequality.html">Inequality</a> </li>
                                <li><a href="../classes/Input.html">Input</a> </li>
                                <li><a href="../classes/Integral.html">Integral</a> </li>
                                <li><a href="../classes/Intersection.html">Intersection</a> </li>
                                <li><a href="../classes/JXG.html">JXG</a> </li>
                                <li><a href="../classes/JXG.AbstractRenderer.html">JXG.AbstractRenderer</a> </li>
                                <li><a href="../classes/JXG.Board.html">JXG.Board</a> </li>
                                <li><a href="../classes/JXG.C.html">JXG.C</a> </li>
                                <li><a href="../classes/JXG.CanvasRenderer.html">JXG.CanvasRenderer</a> </li>
                                <li><a href="../classes/JXG.Chart.html">JXG.Chart</a> </li>
                                <li><a href="../classes/JXG.Circle.html">JXG.Circle</a> </li>
                                <li><a href="../classes/JXG.Complex.html">JXG.Complex</a> </li>
                                <li><a href="../classes/JXG.Composition.html">JXG.Composition</a> </li>
                                <li><a href="../classes/JXG.Coords.html">JXG.Coords</a> </li>
                                <li><a href="../classes/JXG.CoordsElement.html">JXG.CoordsElement</a> </li>
                                <li><a href="../classes/JXG.Curve.html">JXG.Curve</a> </li>
                                <li><a href="../classes/JXG.GeometryElement.html">JXG.GeometryElement</a> </li>
                                <li><a href="../classes/JXG.Group.html">JXG.Group</a> </li>
                                <li><a href="../classes/JXG.Image.html">JXG.Image</a> </li>
                                <li><a href="../classes/JXG.JSXGraph.html">JXG.JSXGraph</a> </li>
                                <li><a href="../classes/JXG.Line.html">JXG.Line</a> </li>
                                <li><a href="../classes/JXG.Math.html">JXG.Math</a> </li>
                                <li><a href="../classes/JXG.Math.Geometry.html">JXG.Math.Geometry</a> </li>
                                <li><a href="../classes/JXG.Math.Numerics.html">JXG.Math.Numerics</a> </li>
                                <li><a href="../classes/JXG.Math.Poly.html">JXG.Math.Poly</a> </li>
                                <li><a href="../classes/JXG.Math.Poly.Monomial.html">JXG.Math.Poly.Monomial</a> </li>
                                <li><a href="../classes/JXG.Math.Poly.Polynomial.html">JXG.Math.Poly.Polynomial</a> </li>
                                <li><a href="../classes/JXG.Math.Poly.Ring.html">JXG.Math.Poly.Ring</a> </li>
                                <li><a href="../classes/JXG.Math.Quadtree.html">JXG.Math.Quadtree</a> </li>
                                <li><a href="../classes/JXG.Math.Statistics.html">JXG.Math.Statistics</a> </li>
                                <li><a href="../classes/JXG.Math.Symbolic.html">JXG.Math.Symbolic</a> </li>
                                <li><a href="../classes/JXG.NoRenderer.html">JXG.NoRenderer</a> </li>
                                <li><a href="../classes/JXG.Options.html">JXG.Options</a> </li>
                                <li><a href="../classes/JXG.Point.html">JXG.Point</a> </li>
                                <li><a href="../classes/JXG.Polygon.html">JXG.Polygon</a> </li>
                                <li><a href="../classes/JXG.SVGRenderer.html">JXG.SVGRenderer</a> </li>
                                <li><a href="../classes/JXG.Text.html">JXG.Text</a> </li>
                                <li><a href="../classes/JXG.Ticks.html">JXG.Ticks</a> </li>
                                <li><a href="../classes/JXG.Transformation.html">JXG.Transformation</a> </li>
                                <li><a href="../classes/JXG.Turtle.html">JXG.Turtle</a> </li>
                                <li><a href="../classes/JXG.Util.Base64.html">JXG.Util.Base64</a> </li>
                                <li><a href="../classes/JXG.Util.Unzip.html">JXG.Util.Unzip</a> </li>
                                <li><a href="../classes/JXG.VMLRenderer.html">JXG.VMLRenderer</a> </li>
                                <li><a href="../classes/Line.html">Line</a> </li>
                                <li><a href="../classes/Locus.html">Locus</a> </li>
                                <li><a href="../classes/MajorArc.html">MajorArc</a> </li>
                                <li><a href="../classes/Midpoint.html">Midpoint</a> </li>
                                <li><a href="../classes/MinorArc.html">MinorArc</a> </li>
                                <li><a href="../classes/MinorSector.html">MinorSector</a> </li>
                                <li><a href="../classes/Mirrorpoint.html">Mirrorpoint</a> </li>
                                <li><a href="../classes/NonReflexAngle.html">NonReflexAngle</a> </li>
                                <li><a href="../classes/Normal.html">Normal</a> </li>
                                <li><a href="../classes/Orthogonalprojection.html">Orthogonalprojection</a> </li>
                                <li><a href="../classes/OtherIntersection.html">OtherIntersection</a> </li>
                                <li><a href="../classes/Parabola.html">Parabola</a> </li>
                                <li><a href="../classes/Parallel.html">Parallel</a> </li>
                                <li><a href="../classes/Parallelpoint.html">Parallelpoint</a> </li>
                                <li><a href="../classes/Perpendicular.html">Perpendicular</a> </li>
                                <li><a href="../classes/PerpendicularPoint.html">PerpendicularPoint</a> </li>
                                <li><a href="../classes/PerpendicularSegment.html">PerpendicularSegment</a> </li>
                                <li><a href="../classes/Point.html">Point</a> </li>
                                <li><a href="../classes/PolarLine.html">PolarLine</a> </li>
                                <li><a href="../classes/PolePoint.html">PolePoint</a> </li>
                                <li><a href="../classes/Polygon.html">Polygon</a> </li>
                                <li><a href="../classes/RadicalAxis.html">RadicalAxis</a> </li>
                                <li><a href="../classes/Reflection.html">Reflection</a> </li>
                                <li><a href="../classes/ReflexAngle.html">ReflexAngle</a> </li>
                                <li><a href="../classes/registerReader.html">registerReader</a> </li>
                                <li><a href="../classes/RegularPolygon.html">RegularPolygon</a> </li>
                                <li><a href="../classes/Riemannsum.html">Riemannsum</a> </li>
                                <li><a href="../classes/Sector.html">Sector</a> </li>
                                <li><a href="../classes/Segment.html">Segment</a> </li>
                                <li><a href="../classes/Semicircle.html">Semicircle</a> </li>
                                <li><a href="../classes/Slider.html">Slider</a> </li>
                                <li><a href="../classes/Slopetriangle.html">Slopetriangle</a> </li>
                                <li><a href="../classes/Spline.html">Spline</a> </li>
                                <li><a href="../classes/Stepfunction.html">Stepfunction</a> </li>
                                <li><a href="../classes/Tangent.html">Tangent</a> </li>
                                <li><a href="../classes/Tapemeasure.html">Tapemeasure</a> </li>
                                <li><a href="../classes/Text.html">Text</a> </li>
                                <li><a href="../classes/Ticks.html">Ticks</a> </li>
                                <li><a href="../classes/Tracecurve.html">Tracecurve</a> </li>
                                <li><a href="../classes/Transformation.html">Transformation</a> </li>
                                <li><a href="../classes/Turtle.html">Turtle</a> </li>
                            </ul>
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="../modules/JXG.html">JXG</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: src/element/composition.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/*
    Copyright 2008-2015
        Matthias Ehmann,
        Michael Gerhaeuser,
        Carsten Miller,
        Bianca Valentin,
        Alfred Wassermann,
        Peter Wilfahrt

    This file is part of JSXGraph.

    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.

    You can redistribute it and/or modify it under the terms of the

      * GNU Lesser General Public License as published by
        the Free Software Foundation, either version 3 of the License, or
        (at your option) any later version
      OR
      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT

    JSXGraph is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License and
    the MIT License along with JSXGraph. If not, see &lt;http://www.gnu.org/licenses/&gt;
    and &lt;http://opensource.org/licenses/MIT/&gt;.
 */


/*global JXG: true, define: true*/
/*jslint nomen: true, plusplus: true*/

/* depends:
 jxg
 math/math
 math/geometry
 math/numerics
 math/statistics
 math/symbolic
 base/composition
 base/coords
 base/constants
 utils/type
  elements:
   line
   circle
   transform
   point
   glider
   text
   curve
 */

/**
 * @fileoverview This file contains our composition elements, i.e. these elements are mostly put together
 * from one or more {@link JXG.GeometryElement} but with a special meaning. E.g. the midpoint element is contained here
 * and this is just a {@link JXG.Point} with coordinates dependent from two other points. Currently in this file the
 * following compositions can be found: &lt;ul&gt;
 *   &lt;li&gt;{@link Arrowparallel} (currently private)&lt;/li&gt;
 *   &lt;li&gt;{@link Bisector}&lt;/li&gt;
 *   &lt;li&gt;{@link Circumcircle}&lt;/li&gt;
 *   &lt;li&gt;{@link Circumcirclemidpoint}&lt;/li&gt;
 *   &lt;li&gt;{@link Integral}&lt;/li&gt;
 *   &lt;li&gt;{@link Midpoint}&lt;/li&gt;
 *   &lt;li&gt;{@link Mirrorpoint}&lt;/li&gt;
 *   &lt;li&gt;{@link Normal}&lt;/li&gt;
 *   &lt;li&gt;{@link Orthogonalprojection}&lt;/li&gt;
 *   &lt;li&gt;{@link Parallel}&lt;/li&gt;
 *   &lt;li&gt;{@link Perpendicular}&lt;/li&gt;
 *   &lt;li&gt;{@link Perpendicularpoint}&lt;/li&gt;
 *   &lt;li&gt;{@link Perpendicularsegment}&lt;/li&gt;
 *   &lt;li&gt;{@link Reflection}&lt;/li&gt;&lt;/ul&gt;
 */

define([
    &#x27;jxg&#x27;, &#x27;math/math&#x27;, &#x27;math/geometry&#x27;, &#x27;math/numerics&#x27;, &#x27;math/statistics&#x27;, &#x27;base/coords&#x27;, &#x27;utils/type&#x27;, &#x27;base/constants&#x27;,
    &#x27;base/point&#x27;, &#x27;base/line&#x27;, &#x27;base/circle&#x27;, &#x27;base/transformation&#x27;, &#x27;base/composition&#x27;, &#x27;base/curve&#x27;, &#x27;base/text&#x27;
], function (JXG, Mat, Geometry, Numerics, Statistics, Coords, Type, Const, Point, Line, Circle, Transform, Composition, Curve, Text) {

    &quot;use strict&quot;;

    /**
     * Construct a point that is the orthogonal projection of a point to a line.
     *
     * An orthogonal projection is given by a point and a line. It is determined by projecting the given point
     * orthogonal onto the given line.
     *
     * @pseudo
     * @constructor
     * @class Orthogonalprojection
     * @type JXG.Point
     * @extends JXG.Point
     * @throws {Error} If the element cannot be constructed with the given parent objects an exception is thrown.
     * @param {JXG.Line_JXG.Point} p,l The constructed point is the orthogonal projection of p onto l.
     * @example
     *     var p1 = board.create(&#x27;point&#x27;, [0.0, 4.0]);
     *     var p2 = board.create(&#x27;point&#x27;, [6.0, 1.0]);
     *     var l1 = board.create(&#x27;line&#x27;, [p1, p2]);
     *     var p3 = board.create(&#x27;point&#x27;, [3.0, 3.0]);
     *
     *     var pp1 = board.create(&#x27;orthogonalprojection&#x27;, [p3, l1]);
     * &lt;div id=&quot;7708b215-39fa-41b6-b972-19d73d77d791&quot; style=&quot;width: 400px; height: 400px;&quot;&gt;&lt;/div&gt;
     * &lt;script type=&quot;text/javascript&quot;&gt;
     * (function(){
     *   var board = JXG.JSXGraph.initBoard(&#x27;7708b215-39fa-41b6-b972-19d73d77d791&#x27;, {boundingbox: [-1, 9, 9, -1], axis: true, showcopyright: false, shownavigation: false});
     *   var p1 = board.create(&#x27;point&#x27;, [0.0, 4.0]);
     *   var p2 = board.create(&#x27;point&#x27;, [6.0, 1.0]);
     *   var l1 = board.create(&#x27;line&#x27;, [p1, p2]);
     *   var p3 = board.create(&#x27;point&#x27;, [3.0, 3.0]);
     *   var pp1 = board.create(&#x27;orthogonalprojection&#x27;, [p3, l1]);
     * })();
     * &lt;/script&gt;
     */
    JXG.createOrthogonalProjection = function (board, parents, attributes) {
        var l, p, t, attr;

        parents[0] = board.select(parents[0]);
        parents[1] = board.select(parents[1]);

        if (Type.isPointType(board, parents[0]) &amp;&amp; parents[1].elementClass === Const.OBJECT_CLASS_LINE) {
            p = Type.providePoints(board, [parents[0]], attributes, &#x27;point&#x27;)[0];
            l = parents[1];
        } else if (Type.isPointType(board, parents[1]) &amp;&amp; parents[0].elementClass === Const.OBJECT_CLASS_LINE) {
            p = Type.providePoints(board, [parents[1]], attributes, &#x27;point&#x27;)[0];
            l = parents[0];
        } else {
            throw new Error(&quot;JSXGraph: Can&#x27;t create perpendicular point with parent types &#x27;&quot; +
                (typeof parents[0]) + &quot;&#x27; and &#x27;&quot; + (typeof parents[1]) + &quot;&#x27;.&quot; +
                &quot;\nPossible parent types: [point,line]&quot;);
        }

        attr = Type.copyAttributes(attributes, board.options, &#x27;orthogonalprojection&#x27;);

        t = board.create(&#x27;point&#x27;, [
            function () {
                return Geometry.projectPointToLine(p, l, board);
            }
        ], attr);

        p.addChild(t);
        l.addChild(t);

        t.elType = &#x27;orthogonalprojection&#x27;;
        t.setParents([p.id, t.id]);

        t.update();

        t.generatePolynomial = function () {
            /*
             *  Perpendicular takes point P and line L and creates point T and line M:
             *
             *                          | M
             *                          |
             *                          x P (p1,p2)
             *                          |
             *                          |
             *  L                       |
             *  ----------x-------------x------------------------x--------
             *            A (a1,a2)     |T (t1,t2)               B (b1,b2)
             *                          |
             *                          |
             *
             * So we have two conditions:
             *
             *   (a)  AT  || TB          (collinearity condition)
             *   (b)  PT _|_ AB          (orthogonality condition)
             *
             *      a2-t2       t2-b2
             *     -------  =  -------           (1)
             *      a1-t1       t1-b1
             *
             *      p2-t2         a1-b1
             *     -------  =  - -------         (2)
             *      p1-t1         a2-b2
             *
             * Multiplying (1) and (2) with denominators and simplifying gives
             *
             *    a2t1 - a2b1 + t2b1 - a1t2 + a1b2 - t1b2 = 0                  (1&#x27;)
             *
             *    p2a2 - p2b2 - t2a2 + t2b2 + p1a1 - p1b1 - t1a1 + t1b1 = 0    (2&#x27;)
             *
             */

            var a1 = l.point1.symbolic.x,
                a2 = l.point1.symbolic.y,
                b1 = l.point2.symbolic.x,
                b2 = l.point2.symbolic.y,

                p1 = p.symbolic.x,
                p2 = p.symbolic.y,
                t1 = t.symbolic.x,
                t2 = t.symbolic.y,

                poly1 = &#x27;(&#x27; + a2 + &#x27;)*(&#x27; + t1 + &#x27;)-(&#x27; + a2 + &#x27;)*(&#x27; + b1 + &#x27;)+(&#x27; + t2 + &#x27;)*(&#x27; + b1 + &#x27;)-(&#x27; +
                    a1 + &#x27;)*(&#x27; + t2 + &#x27;)+(&#x27; + a1 + &#x27;)*(&#x27; + b2 + &#x27;)-(&#x27; + t1 + &#x27;)*(&#x27; + b2 + &#x27;)&#x27;,
                poly2 = &#x27;(&#x27; + p2 + &#x27;)*(&#x27; + a2 + &#x27;)-(&#x27; + p2 + &#x27;)*(&#x27; + b2 + &#x27;)-(&#x27; + t2 + &#x27;)*(&#x27; + a2 + &#x27;)+(&#x27; +
                    t2 + &#x27;)*(&#x27; + b2 + &#x27;)+(&#x27; + p1 + &#x27;)*(&#x27; + a1 + &#x27;)-(&#x27; + p1 + &#x27;)*(&#x27; + b1 + &#x27;)-(&#x27; + t1 + &#x27;)*(&#x27; +
                    a1 + &#x27;)+(&#x27; + t1 + &#x27;)*(&#x27; + b1 + &#x27;)&#x27;;

            return [poly1, poly2];
        };

        return t;
    };

    /**
     * Constructor for a perpendicular line.
     * 
     * A perpendicular is a composition of two elements: a line and a point. The line is orthogonal
     * to a given line and contains a given point.
     *
     * @pseudo
     * @class Perpendicular
     * @constructor
     * @type JXG.Line
     * @extends Segment
     * @return A {@link JXG.Line} object through the given point that is orthogonal to the given line.
     * @throws {Error} If the elements cannot be constructed with the given parent objects an exception is thrown.
     * @param {JXG.Line_JXG.Point} l,p The perpendicular line will be orthogonal to l and
     * will contain p.
     * @example
     *     // Create a perpendicular
     *     var p1 = board.create(&#x27;point&#x27;, [0.0, 2.0]);
     *     var p2 = board.create(&#x27;point&#x27;, [2.0, 1.0]);
     *     var l1 = board.create(&#x27;line&#x27;, [p1, p2]);
     *
     *     var p3 = board.create(&#x27;point&#x27;, [3.0, 3.0]);
     *     var perp1 = board.create(&#x27;perpendicular&#x27;, [l1, p3]);
     * &lt;div id=&quot;d5b78842-7b27-4d37-b608-d02519e6cd03&quot; style=&quot;width: 400px; height: 400px;&quot;&gt;&lt;/div&gt;
     * &lt;script type=&quot;text/javascript&quot;&gt;
     * (function(){
     *   var board = JXG.JSXGraph.initBoard(&#x27;d5b78842-7b27-4d37-b608-d02519e6cd03&#x27;, {boundingbox: [-1, 9, 9, -1], axis: true, showcopyright: false, shownavigation: false});
     *   var p1 = board.create(&#x27;point&#x27;, [0.0, 2.0]);
     *   var p2 = board.create(&#x27;point&#x27;, [2.0, 1.0]);
     *   var l1 = board.create(&#x27;line&#x27;, [p1, p2]);
     *   var p3 = board.create(&#x27;point&#x27;, [3.0, 3.0]);
     *   var perp1 = board.create(&#x27;perpendicular&#x27;, [l1, p3]);
     * })();
     * &lt;/script&gt;
     */
    JXG.createPerpendicular = function (board, parents, attributes) {
        var p, l, pd, attr;

        parents[0] = board.select(parents[0]);
        parents[1] = board.select(parents[1]);

        if (Type.isPointType(board, parents[0]) &amp;&amp; parents[1].elementClass === Const.OBJECT_CLASS_LINE) {
            l = parents[1];
            p = Type.providePoints(board, [parents[0]], attributes, &#x27;point&#x27;)[0];
        } else if (Type.isPointType(board, parents[1]) &amp;&amp; parents[0].elementClass === Const.OBJECT_CLASS_LINE) {
            l = parents[0];
            p = Type.providePoints(board, [parents[1]], attributes, &#x27;point&#x27;)[0];
        } else {
            throw new Error(&quot;JSXGraph: Can&#x27;t create perpendicular with parent types &#x27;&quot; +
                (typeof parents[0]) + &quot;&#x27; and &#x27;&quot; + (typeof parents[1]) + &quot;&#x27;.&quot; +
                &quot;\nPossible parent types: [line,point]&quot;);
        }

        attr = Type.copyAttributes(attributes, board.options, &#x27;perpendicular&#x27;);
        pd = Line.createLine(board, [
            function () {
                return l.stdform[2] * p.X() - l.stdform[1] * p.Y();
            },
            function () {
                return -l.stdform[2] * p.Z();
            },
            function () {
                return l.stdform[1] * p.Z();
            }
        ], attr);

        pd.elType = &#x27;perpendicular&#x27;;
        pd.setParents([l.id, p.id]);

        return pd;
    };

    /**
     * Construct a perpendicular point.
     *
     * A perpendicular point is given by a point and a line. It is determined by projecting the given point
     * orthogonal onto the given line. This element should be used in GEONExTReader only. All other applications should
     * use orthogonal projection {@link Orthogonalprojection}.
     *
     * This construction may differ from Orthogonalprojection if the point lies on the line.
     * @pseudo
     * @constructor
     * @class PerpendicularPoint
     * @type JXG.Point
     * @extends JXG.Point
     * @throws {Error} If the element cannot be constructed with the given parent objects an exception is thrown.
     * @param {JXG.Line_JXG.Point} p,l The constructed point is the orthogonal projection of p onto l.
     * @example
     *     var p1 = board.create(&#x27;point&#x27;, [0.0, 4.0]);
     *     var p2 = board.create(&#x27;point&#x27;, [6.0, 1.0]);
     *     var l1 = board.create(&#x27;line&#x27;, [p1, p2]);
     *     var p3 = board.create(&#x27;point&#x27;, [3.0, 3.0]);
     *
     *     var pp1 = board.create(&#x27;perpendicularpoint&#x27;, [p3, l1]);
     * &lt;div id=&quot;ded148c9-3536-44c0-ab81-1bb8fa48f3f4&quot; style=&quot;width: 400px; height: 400px;&quot;&gt;&lt;/div&gt;
     * &lt;script type=&quot;text/javascript&quot;&gt;
     * (function(){
     *   var board = JXG.JSXGraph.initBoard(&#x27;ded148c9-3536-44c0-ab81-1bb8fa48f3f4&#x27;, {boundingbox: [-1, 9, 9, -1], axis: true, showcopyright: false, shownavigation: false});
     *   var p1 = board.create(&#x27;point&#x27;, [0.0, 4.0]);
     *   var p2 = board.create(&#x27;point&#x27;, [6.0, 1.0]);
     *   var l1 = board.create(&#x27;line&#x27;, [p1, p2]);
     *   var p3 = board.create(&#x27;point&#x27;, [3.0, 3.0]);
     *   var pp1 = board.create(&#x27;perpendicularpoint&#x27;, [p3, l1]);
     * })();
     * &lt;/script&gt;
     */
    JXG.createPerpendicularPoint = function (board, parents, attributes) {
        var l, p, t;

        parents[0] = board.select(parents[0]);
        parents[1] = board.select(parents[1]);
        if (Type.isPointType(board, parents[0]) &amp;&amp; parents[1].elementClass === Const.OBJECT_CLASS_LINE) {
            p = Type.providePoints(board, [parents[0]], attributes, &#x27;point&#x27;)[0];
            l = parents[1];
        } else if (Type.isPointType(board, parents[1]) &amp;&amp; parents[0].elementClass === Const.OBJECT_CLASS_LINE) {
            p = Type.providePoints(board, [parents[1]], attributes, &#x27;point&#x27;)[0];
            l = parents[0];
        } else {
            throw new Error(&quot;JSXGraph: Can&#x27;t create perpendicular point with parent types &#x27;&quot; +
                (typeof parents[0]) + &quot;&#x27; and &#x27;&quot; + (typeof parents[1]) + &quot;&#x27;.&quot; +
                &quot;\nPossible parent types: [point,line]&quot;);
        }

        t = board.create(&#x27;point&#x27;, [
            function () {
                return Geometry.perpendicular(l, p, board)[0];
            }
        ], attributes);

        p.addChild(t);
        l.addChild(t);

        t.elType = &#x27;perpendicularpoint&#x27;;
        t.setParents([p.id, l.id]);

        t.update();

        t.generatePolynomial = function () {
            /*
             *  Perpendicular takes point P and line L and creates point T and line M:
             *
             *                          | M
             *                          |
             *                          x P (p1,p2)
             *                          |
             *                          |
             *  L                       |
             *  ----------x-------------x------------------------x--------
             *            A (a1,a2)     |T (t1,t2)               B (b1,b2)
             *                          |
             *                          |
             *
             * So we have two conditions:
             *
             *   (a)  AT  || TB          (collinearity condition)
             *   (b)  PT _|_ AB          (orthogonality condition)
             *
             *      a2-t2       t2-b2
             *     -------  =  -------           (1)
             *      a1-t1       t1-b1
             *
             *      p2-t2         a1-b1
             *     -------  =  - -------         (2)
             *      p1-t1         a2-b2
             *
             * Multiplying (1) and (2) with denominators and simplifying gives
             *
             *    a2t1 - a2b1 + t2b1 - a1t2 + a1b2 - t1b2 = 0                  (1&#x27;)
             *
             *    p2a2 - p2b2 - t2a2 + t2b2 + p1a1 - p1b1 - t1a1 + t1b1 = 0    (2&#x27;)
             *
             */
            var a1 = l.point1.symbolic.x,
                a2 = l.point1.symbolic.y,
                b1 = l.point2.symbolic.x,
                b2 = l.point2.symbolic.y,
                p1 = p.symbolic.x,
                p2 = p.symbolic.y,
                t1 = t.symbolic.x,
                t2 = t.symbolic.y,

                poly1 = &#x27;(&#x27; + a2 + &#x27;)*(&#x27; + t1 + &#x27;)-(&#x27; + a2 + &#x27;)*(&#x27; + b1 + &#x27;)+(&#x27; + t2 + &#x27;)*(&#x27; + b1 + &#x27;)-(&#x27; +
                    a1 + &#x27;)*(&#x27; + t2 + &#x27;)+(&#x27; + a1 + &#x27;)*(&#x27; + b2 + &#x27;)-(&#x27; + t1 + &#x27;)*(&#x27; + b2 + &#x27;)&#x27;,
                poly2 = &#x27;(&#x27; + p2 + &#x27;)*(&#x27; + a2 + &#x27;)-(&#x27; + p2 + &#x27;)*(&#x27; + b2 + &#x27;)-(&#x27; + t2 + &#x27;)*(&#x27; + a2 + &#x27;)+(&#x27; +
                    t2 + &#x27;)*(&#x27; + b2 + &#x27;)+(&#x27; + p1 + &#x27;)*(&#x27; + a1 + &#x27;)-(&#x27; + p1 + &#x27;)*(&#x27; + b1 + &#x27;)-(&#x27; + t1 + &#x27;)*(&#x27; +
                    a1 + &#x27;)+(&#x27; + t1 + &#x27;)*(&#x27; + b1 + &#x27;)&#x27;;

            return [poly1, poly2];
        };

        return t;
    };

    /**
     * This element is used to provide a constructor for a perpendicular segment.
     *
     * A perpendicular is a composition of two elements: a line segment and a point. The line segment is orthogonal
     * to a given line and contains a given point and meets the given line in the perpendicular point.
     *
     * @pseudo
     * @class PerpendicularSegment
     * @constructor
     * @type JXG.Line
     * @extends Segment
     * @return An array containing two elements: A {@link JXG.Line} object in the first component and a
     * {@link JXG.Point} element in the second component. The line segment is orthogonal to the given line and meets it
     * in the returned point.
     * @throws {Error} If the elements cannot be constructed with the given parent objects an exception is thrown.
     * @param {JXG.Line_JXG.Point} l,p The perpendicular line will be orthogonal to l and
     * will contain p. The perpendicular point is the intersection point of the two lines.
     * @example
     *     // Create a perpendicular
     *     var p1 = board.create(&#x27;point&#x27;, [0.0, 2.0]);
     *     var p2 = board.create(&#x27;point&#x27;, [2.0, 1.0]);
     *     var l1 = board.create(&#x27;line&#x27;, [p1, p2]);
     *
     *     var p3 = board.create(&#x27;point&#x27;, [3.0, 3.0]);
     *     var perp1 = board.create(&#x27;perpendicularsegment&#x27;, [l1, p3]);
     * &lt;div id=&quot;037a6eb2-781d-4b71-b286-763619a63f22&quot; style=&quot;width: 400px; height: 400px;&quot;&gt;&lt;/div&gt;
     * &lt;script type=&quot;text/javascript&quot;&gt;
     * (function(){
     *   var board = JXG.JSXGraph.initBoard(&#x27;037a6eb2-781d-4b71-b286-763619a63f22&#x27;, {boundingbox: [-1, 9, 9, -1], axis: true, showcopyright: false, shownavigation: false});
     *   var p1 = board.create(&#x27;point&#x27;, [0.0, 2.0]);
     *   var p2 = board.create(&#x27;point&#x27;, [2.0, 1.0]);
     *   var l1 = board.create(&#x27;line&#x27;, [p1, p2]);
     *   var p3 = board.create(&#x27;point&#x27;, [3.0, 3.0]);
     *   var perp1 = board.create(&#x27;perpendicularsegment&#x27;, [l1, p3]);
     * })();
     * &lt;/script&gt;
     */
    JXG.createPerpendicularSegment = function (board, parents, attributes) {
        var p, l, pd, t, attr;

        parents[0] = board.select(parents[0]);
        parents[1] = board.select(parents[1]);
        if (Type.isPointType(board, parents[0]) &amp;&amp; parents[1].elementClass === Const.OBJECT_CLASS_LINE) {
            l = parents[1];
            p = Type.providePoints(board, [parents[0]], attributes, &#x27;point&#x27;)[0];
        } else if (Type.isPointType(board, parents[1]) &amp;&amp; parents[0].elementClass === Const.OBJECT_CLASS_LINE) {
            l = parents[0];
            p = Type.providePoints(board, [parents[1]], attributes, &#x27;point&#x27;)[0];
        } else {
            throw new Error(&quot;JSXGraph: Can&#x27;t create perpendicular with parent types &#x27;&quot; +
                (typeof parents[0]) + &quot;&#x27; and &#x27;&quot; + (typeof parents[1]) + &quot;&#x27;.&quot; +
                &quot;\nPossible parent types: [line,point]&quot;);
        }
        attr = Type.copyAttributes(attributes, board.options, &#x27;perpendicularsegment&#x27;, &#x27;point&#x27;);
        t = JXG.createPerpendicularPoint(board, [l, p], attr);

        t.dump = false;

        if (!Type.exists(attributes.layer)) {
            attributes.layer = board.options.layer.line;
        }

        attr = Type.copyAttributes(attributes, board.options, &#x27;perpendicularsegment&#x27;);
        pd = Line.createLine(board, [
            function () {
                return (Geometry.perpendicular(l, p, board)[1] ? [t, p] : [p, t]);
            }
        ], attr);

        /**
         * Helper point
         *
         * @property point
         * @memberOf PerpendicularSegment.prototype
         * @type PerpendicularPoint
         */
        pd.point = t;

        pd.elType = &#x27;perpendicularsegment&#x27;;
        pd.setParents([p.id, l.id]);
        pd.subs = {
            point: t
        };

        return pd;
    };

    /**
     * The midpoint element constructs a point in the middle of two given points.
     *
     * A midpoint is given by two points. It is collinear to the given points and the distance
     * is the same to each of the given points, i.e. it is in the middle of the given points.
     *
     * @pseudo
     * @constructor
     * @class Midpoint
     * @type JXG.Point
     * @extends JXG.Point
     * @throws {Error} If the element cannot be constructed with the given parent objects an exception is thrown.
     * @param {JXG.Point_JXG.Point} p1,p2 The constructed point will be in the middle of p1 and p2.
     * @param {JXG.Line} l The midpoint will be in the middle of {@link JXG.Line#point1} and {@link JXG.Line#point2} of
     * the given line l.
     * @example
     *     // Create base elements: 2 points and 1 line
     *     var p1 = board.create(&#x27;point&#x27;, [0.0, 2.0]);
     *     var p2 = board.create(&#x27;point&#x27;, [2.0, 1.0]);
     *     var l1 = board.create(&#x27;segment&#x27;, [[0.0, 3.0], [3.0, 3.0]]);
     *
     *     var mp1 = board.create(&#x27;midpoint&#x27;, [p1, p2]);
     *     var mp2 = board.create(&#x27;midpoint&#x27;, [l1]);
     * &lt;div id=&quot;7927ef86-24ae-40cc-afb0-91ff61dd0de7&quot; style=&quot;width: 400px; height: 400px;&quot;&gt;&lt;/div&gt;
     * &lt;script type=&quot;text/javascript&quot;&gt;
     * (function(){
     *   var mboard = JXG.JSXGraph.initBoard(&#x27;7927ef86-24ae-40cc-afb0-91ff61dd0de7&#x27;, {boundingbox: [-1, 9, 9, -1], axis: true, showcopyright: false, shownavigation: false});
     *   var mp1 = mboard.create(&#x27;point&#x27;, [0.0, 2.0]);
     *   var mp2 = mboard.create(&#x27;point&#x27;, [2.0, 1.0]);
     *   var ml1 = mboard.create(&#x27;segment&#x27;, [[0.0, 3.0], [3.0, 3.0]]);
     *   var mmp1 = mboard.create(&#x27;midpoint&#x27;, [mp1, mp2]);
     *   var mmp2 = mboard.create(&#x27;midpoint&#x27;, [ml1]);
     * })();
     * &lt;/script&gt;
     */
    JXG.createMidpoint = function (board, parents, attributes) {
        var a, b, t, i;

        for (i = 0; i &lt; parents.length; ++i) {
            parents[i] = board.select(parents[i]);
        }
        if (parents.length === 2 &amp;&amp; Type.isPointType(board, parents[0]) &amp;&amp; Type.isPointType(board, parents[1])) {
            parents = Type.providePoints(board, parents, attributes, &#x27;point&#x27;);
            a = parents[0];
            b = parents[1];
        } else if (parents.length === 1 &amp;&amp; parents[0].elementClass === Const.OBJECT_CLASS_LINE) {
            a = parents[0].point1;
            b = parents[0].point2;
        } else {
            throw new Error(&quot;JSXGraph: Can&#x27;t create midpoint.&quot; +
                &quot;\nPossible parent types: [point,point], [line]&quot;);
        }

        t = board.create(&#x27;point&#x27;, [
            function () {
                var x = a.coords.usrCoords[1] + b.coords.usrCoords[1];
                if (isNaN(x) || Math.abs(a.coords.usrCoords[0]) &lt; Mat.eps || Math.abs(b.coords.usrCoords[0]) &lt; Mat.eps) {
                    return NaN;
                }

                return x * 0.5;
            },
            function () {
                var y = a.coords.usrCoords[2] + b.coords.usrCoords[2];
                if (isNaN(y) || Math.abs(a.coords.usrCoords[0]) &lt; Mat.eps || Math.abs(b.coords.usrCoords[0]) &lt; Mat.eps) {
                    return NaN;
                }

                return y * 0.5;
            }], attributes);
        a.addChild(t);
        b.addChild(t);

        t.elType = &#x27;midpoint&#x27;;
        t.setParents([a.id, b.id]);

        t.prepareUpdate().update();

        t.generatePolynomial = function () {
            /*
             *  Midpoint takes two point A and B or line L (with points P and Q) and creates point T:
             *
             *  L (not necessarily)
             *  ----------x------------------x------------------x--------
             *            A (a1,a2)          T (t1,t2)          B (b1,b2)
             *
             * So we have two conditions:
             *
             *   (a)   AT  ||  TB           (collinearity condition)
             *   (b)  [AT] == [TB]          (equidistant condition)
             *
             *      a2-t2       t2-b2
             *     -------  =  -------                                         (1)
             *      a1-t1       t1-b1
             *
             *     (a1 - t1)^2 + (a2 - t2)^2 = (b1 - t1)^2 + (b2 - t2)^2       (2)
             *
             *
             * Multiplying (1) with denominators and simplifying (1) and (2) gives
             *
             *    a2t1 - a2b1 + t2b1 - a1t2 + a1b2 - t1b2 = 0                      (1&#x27;)
             *
             *    a1^2 - 2a1t1 + a2^2 - 2a2t2 - b1^2 + 2b1t1 - b2^2 + 2b2t2 = 0    (2&#x27;)
             *
             */
            var a1 = a.symbolic.x,
                a2 = a.symbolic.y,
                b1 = b.symbolic.x,
                b2 = b.symbolic.y,
                t1 = t.symbolic.x,
                t2 = t.symbolic.y,

                poly1 = &#x27;(&#x27; + a2 + &#x27;)*(&#x27; + t1 + &#x27;)-(&#x27; + a2 + &#x27;)*(&#x27; + b1 + &#x27;)+(&#x27; + t2 + &#x27;)*(&#x27; + b1 + &#x27;)-(&#x27; +
                    a1 + &#x27;)*(&#x27; + t2 + &#x27;)+(&#x27; + a1 + &#x27;)*(&#x27; + b2 + &#x27;)-(&#x27; + t1 + &#x27;)*(&#x27; + b2 + &#x27;)&#x27;,
                poly2 = &#x27;(&#x27; + a1 + &#x27;)^2 - 2*(&#x27; + a1 + &#x27;)*(&#x27; + t1 + &#x27;)+(&#x27; + a2 + &#x27;)^2-2*(&#x27; + a2 + &#x27;)*(&#x27; +
                    t2 + &#x27;)-(&#x27; + b1 + &#x27;)^2+2*(&#x27; + b1 + &#x27;)*(&#x27; + t1 + &#x27;)-(&#x27; + b2 + &#x27;)^2+2*(&#x27; + b2 + &#x27;)*(&#x27; + t2 + &#x27;)&#x27;;

            return [poly1, poly2];
        };

        return t;
    };

    /**
     * This element is used to construct a parallel point.
     *
     * A parallel point is given by three points. Taking the euclidean vector from the first to the
     * second point, the parallel point is determined by adding that vector to the third point.
     * The line determined by the first two points is parallel to the line determined by the third point and the constructed point.
     *
     * @pseudo
     * @constructor
     * @class Parallelpoint
     * @type JXG.Point
     * @extends JXG.Point
     * @throws {Error} If the element cannot be constructed with the given parent objects an exception is thrown.
     * @param {JXG.Point_JXG.Point_JXG.Point} p1,p2,p3 Taking the euclidean vector &lt;tt&gt;v=p2-p1&lt;/tt&gt; the parallel point is determined by
     * &lt;tt&gt;p4 = p3+v&lt;/tt&gt;
     * @param {JXG.Line_JXG.Point} l,p The resulting point will together with p specify a line which is parallel to l.
     * @example
     *     var p1 = board.create(&#x27;point&#x27;, [0.0, 2.0]);
     *     var p2 = board.create(&#x27;point&#x27;, [2.0, 1.0]);
     *     var p3 = board.create(&#x27;point&#x27;, [3.0, 3.0]);
     *
     *     var pp1 = board.create(&#x27;parallelpoint&#x27;, [p1, p2, p3]);
     * &lt;div id=&quot;488c4be9-274f-40f0-a469-c5f70abe1f0e&quot; style=&quot;width: 400px; height: 400px;&quot;&gt;&lt;/div&gt;
     * &lt;script type=&quot;text/javascript&quot;&gt;
     * (function(){
     *   var board = JXG.JSXGraph.initBoard(&#x27;488c4be9-274f-40f0-a469-c5f70abe1f0e&#x27;, {boundingbox: [-1, 9, 9, -1], axis: true, showcopyright: false, shownavigation: false});
     *   var p1 = board.create(&#x27;point&#x27;, [0.0, 2.0]);
     *   var p2 = board.create(&#x27;point&#x27;, [2.0, 1.0]);
     *   var p3 = board.create(&#x27;point&#x27;, [3.0, 3.0]);
     *   var pp1 = board.create(&#x27;parallelpoint&#x27;, [p1, p2, p3]);
     * })();
     * &lt;/script&gt;
     */
    JXG.createParallelPoint = function (board, parents, attributes) {
        var a, b, c, p, i;

        for (i = 0; i &lt; parents.length; ++i) {
            parents[i] = board.select(parents[i]);
        }
        if (parents.length === 3 &amp;&amp;
                Type.isPointType(board, parents[0]) &amp;&amp;
                Type.isPointType(board, parents[1]) &amp;&amp;
                Type.isPointType(board, parents[2])) {
            parents = Type.providePoints(board, parents, attributes, &#x27;point&#x27;);
            a = parents[0];
            b = parents[1];
            c = parents[2];
        } else if (Type.isPointType(board, parents[0]) &amp;&amp;
                parents[1].elementClass === Const.OBJECT_CLASS_LINE) {
            c = Type.providePoints(board, [parents[0]], attributes, &#x27;point&#x27;)[0];
            a = parents[1].point1;
            b = parents[1].point2;
        } else if (Type.isPointType(board, parents[1]) &amp;&amp;
                parents[0].elementClass === Const.OBJECT_CLASS_LINE) {
            c = Type.providePoints(board, [parents[1]], attributes, &#x27;point&#x27;)[0];
            a = parents[0].point1;
            b = parents[0].point2;
        } else {
            throw new Error(&quot;JSXGraph: Can&#x27;t create parallel point with parent types &#x27;&quot; +
                (typeof parents[0]) + &quot;&#x27;, &#x27;&quot; + (typeof parents[1]) + &quot;&#x27; and &#x27;&quot; + (typeof parents[2]) + &quot;&#x27;.&quot; +
                &quot;\nPossible parent types: [line,point], [point,point,point]&quot;);
        }

        p = board.create(&#x27;point&#x27;, [
            function () {
                return c.coords.usrCoords[1] + b.coords.usrCoords[1] - a.coords.usrCoords[1];
            },
            function () {
                return c.coords.usrCoords[2] + b.coords.usrCoords[2] - a.coords.usrCoords[2];
            }
        ], attributes);

        // required for algorithms requiring dependencies between elements
        a.addChild(p);
        b.addChild(p);
        c.addChild(p);

        p.elType = &#x27;parallelpoint&#x27;;
        p.setParents([a.id, b.id, c.id]);

        // required to set the coordinates because functions are considered as constraints. hence, the coordinates get set first after an update.
        // can be removed if the above issue is resolved.
        p.prepareUpdate().update();

        p.generatePolynomial = function () {
            /*
             *  Parallelpoint takes three points A, B and C or line L (with points B and C) and creates point T:
             *
             *
             *                     C (c1,c2)                             T (t1,t2)
             *                      x                                     x
             *                     /                                     /
             *                    /                                     /
             *                   /                                     /
             *                  /                                     /
             *                 /                                     /
             *                /                                     /
             *               /                                     /
             *              /                                     /
             *  L (opt)    /                                     /
             *  ----------x-------------------------------------x--------
             *            A (a1,a2)                             B (b1,b2)
             *
             * So we have two conditions:
             *
             *   (a)   CT  ||  AB           (collinearity condition I)
             *   (b)   BT  ||  AC           (collinearity condition II)
             *
             * The corresponding equations are
             *
             *    (b2 - a2)(t1 - c1) - (t2 - c2)(b1 - a1) = 0         (1)
             *    (t2 - b2)(a1 - c1) - (t1 - b1)(a2 - c2) = 0         (2)
             *
             * Simplifying (1) and (2) gives
             *
             *    b2t1 - b2c1 - a2t1 + a2c1 - t2b1 + t2a1 + c2b1 - c2a1 = 0      (1&#x27;)
             *    t2a1 - t2c1 - b2a1 + b2c1 - t1a2 + t1c2 + b1a2 - b1c2 = 0      (2&#x27;)
             *
             */
            var a1 = a.symbolic.x,
                a2 = a.symbolic.y,
                b1 = b.symbolic.x,
                b2 = b.symbolic.y,
                c1 = c.symbolic.x,
                c2 = c.symbolic.y,
                t1 = p.symbolic.x,
                t2 = p.symbolic.y,

                poly1 =  &#x27;(&#x27; + b2 + &#x27;)*(&#x27; + t1 + &#x27;)-(&#x27; + b2 + &#x27;)*(&#x27; + c1 + &#x27;)-(&#x27; + a2 + &#x27;)*(&#x27; + t1 + &#x27;)+(&#x27; +
                    a2 + &#x27;)*(&#x27; + c1 + &#x27;)-(&#x27; + t2 + &#x27;)*(&#x27; + b1 + &#x27;)+(&#x27; + t2 + &#x27;)*(&#x27; + a1 + &#x27;)+(&#x27; + c2 + &#x27;)*(&#x27; +
                    b1 + &#x27;)-(&#x27; + c2 + &#x27;)*(&#x27; + a1 + &#x27;)&#x27;,
                poly2 =  &#x27;(&#x27; + t2 + &#x27;)*(&#x27; + a1 + &#x27;)-(&#x27; + t2 + &#x27;)*(&#x27; + c1 + &#x27;)-(&#x27; + b2 + &#x27;)*(&#x27; + a1 + &#x27;)+(&#x27; +
                    b2 + &#x27;)*(&#x27; + c1 + &#x27;)-(&#x27; + t1 + &#x27;)*(&#x27; + a2 + &#x27;)+(&#x27; + t1 + &#x27;)*(&#x27; + c2 + &#x27;)+(&#x27; + b1 + &#x27;)*(&#x27; +
                    a2 + &#x27;)-(&#x27; + b1 + &#x27;)*(&#x27; + c2 + &#x27;)&#x27;;

            return [poly1, poly2];
        };

        return p;
    };

    /**
     * A parallel is a line through a given point with the same slope as a given line.
     *
     * @pseudo
     * @class Parallel
     * @extends Line
     * @constructor
     * @type JXG.Line
     * @throws {Error} If the element cannot be constructed with the given parent objects an exception is thrown.
     * @param {JXG.Line_JXG.Point} l,p The constructed line contains p and has the same slope as l.
     * @example
     *     // Create a parallel
     *     var p1 = board.create(&#x27;point&#x27;, [0.0, 2.0]);
     *     var p2 = board.create(&#x27;point&#x27;, [2.0, 1.0]);
     *     var l1 = board.create(&#x27;line&#x27;, [p1, p2]);
     *
     *     var p3 = board.create(&#x27;point&#x27;, [3.0, 3.0]);
     *     var pl1 = board.create(&#x27;parallel&#x27;, [l1, p3]);
     * &lt;div id=&quot;24e54f9e-5c4e-4afb-9228-0ef27a59d627&quot; style=&quot;width: 400px; height: 400px;&quot;&gt;&lt;/div&gt;
     * &lt;script type=&quot;text/javascript&quot;&gt;
     * (function(){
     *   var board = JXG.JSXGraph.initBoard(&#x27;24e54f9e-5c4e-4afb-9228-0ef27a59d627&#x27;, {boundingbox: [-1, 9, 9, -1], axis: true, showcopyright: false, shownavigation: false});
     *   var p1 = board.create(&#x27;point&#x27;, [0.0, 2.0]);
     *   var p2 = board.create(&#x27;point&#x27;, [2.0, 1.0]);
     *   var l1 = board.create(&#x27;line&#x27;, [p1, p2]);
     *   var p3 = board.create(&#x27;point&#x27;, [3.0, 3.0]);
     *   var pl1 = board.create(&#x27;parallel&#x27;, [l1, p3]);
     * })();
     * &lt;/script&gt;
     */
    JXG.createParallel = function (board, parents, attributes) {
        var p, pp, pl, li, i, attr;

        for (i = 0; i &lt; parents.length; ++i) {
            parents[i] = board.select(parents[i]);
        }
        p = null;
        if (parents.length === 3) {
            parents = Type.providePoints(board, parents, attributes, &#x27;point&#x27;);
            // line through point parents[2] which is parallel to line through parents[0] and parents[1]
            p = parents[2];
            /** @ignore */
            li = function () {
                return Mat.crossProduct(parents[0].coords.usrCoords, parents[1].coords.usrCoords);
            };
        } else if (Type.isPointType(board, parents[0])) {
            // Parallel to line parents[1] through point parents[0]
            p = Type.providePoints(board, [parents[0]], attributes, &#x27;point&#x27;)[0];
            /** @ignore */
            li = function () {
                return parents[1].stdform;
            };
        } else if (Type.isPointType(board, parents[1])) {
            // Parallel to line parents[0] through point parents[1]
            p = Type.providePoints(board, [parents[1]], attributes, &#x27;point&#x27;)[0];
            /** @ignore */
            li = function () {
                return parents[0].stdform;
            };
        }

        if (!Type.exists(attributes.layer)) {
            attributes.layer = board.options.layer.line;
        }

        attr = Type.copyAttributes(attributes, board.options, &#x27;parallel&#x27;, &#x27;point&#x27;);
        pp = board.create(&#x27;point&#x27;, [
            function () {
                return Mat.crossProduct([1, 0, 0], li());
            }
        ], attr);

        pp.isDraggable = true;

        attr = Type.copyAttributes(attributes, board.options, &#x27;parallel&#x27;);
        pl = board.create(&#x27;line&#x27;, [p, pp], attr);

        pl.elType = &#x27;parallel&#x27;;
        pl.setParents([parents[0].id, parents[1].id]);
        if (parents.length === 3) {
            pl.addParents(parents[2].id);
        }

        /**
         * Helper point used to create the parallel line. This point lies on the line at infinity, hence it&#x27;s not visible,
         * not even with visible set to &lt;tt&gt;true&lt;/tt&gt;. Creating another line through this point would make that other line
         * parallel to the create parallel.
         * @memberOf Parallel.prototype
         * @property point
         * @type JXG.Point
         */
        pl.point = pp;

        return pl;
    };

    /**
     * An arrow parallel is a parallel segment with an arrow attached.
     *
     * @pseudo
     * @constructor
     * @class Arrowparallel
     * @type Parallel
     * @extends Parallel
     * @throws {Error} If the element cannot be constructed with the given parent objects an exception is thrown.
     * @param {JXG.Line_JXG.Point} l,p The constructed arrow contains p and has the same slope as l.
     * @example
     *     // Create a parallel
     *     var p1 = board.create(&#x27;point&#x27;, [0.0, 2.0]);
     *     var p2 = board.create(&#x27;point&#x27;, [2.0, 1.0]);
     *     var l1 = board.create(&#x27;line&#x27;, [p1, p2]);
     *
     *     var p3 = board.create(&#x27;point&#x27;, [3.0, 3.0]);
     *     var pl1 = board.create(&#x27;arrowparallel&#x27;, [l1, p3]);
     * &lt;div id=&quot;eeacdf99-036f-4e83-aeb6-f7388423e369&quot; style=&quot;width: 400px; height: 400px;&quot;&gt;&lt;/div&gt;
     * &lt;script type=&quot;text/javascript&quot;&gt;
     * (function () {
     *   var board = JXG.JSXGraph.initBoard(&#x27;eeacdf99-036f-4e83-aeb6-f7388423e369&#x27;, {boundingbox: [-1, 9, 9, -1], axis: true, showcopyright: false, shownavigation: false});
     *   var p1 = board.create(&#x27;point&#x27;, [0.0, 2.0]);
     *   var p2 = board.create(&#x27;point&#x27;, [2.0, 1.0]);
     *   var l1 = board.create(&#x27;line&#x27;, [p1, p2]);
     *   var p3 = board.create(&#x27;point&#x27;, [3.0, 3.0]);
     *   var pl1 = board.create(&#x27;arrowparallel&#x27;, [l1, p3]);
     * })();
     * &lt;/script&gt;
     */
    JXG.createArrowParallel = function (board, parents, attributes) {
        var p;

        /* parallel arrow point polynomials are done in createParallelPoint */
        try {
            attributes.firstArrow = false;
            attributes.lastArrow = true;
            p = JXG.createParallel(board, parents, attributes).setAttribute({straightFirst: false, straightLast: false});
            p.elType = &#x27;arrowparallel&#x27;;

            // parents are set in createParallel

            return p;
        } catch (e) {
            throw new Error(&quot;JSXGraph: Can&#x27;t create arrowparallel with parent types &#x27;&quot; +
                (typeof parents[0]) + &quot;&#x27; and &#x27;&quot; + (typeof parents[1]) + &quot;&#x27;.&quot; +
                &quot;\nPossible parent types: [line,point], [point,point,point]&quot;);
        }
    };

    /**
     * Constructs a normal.
     *
     * A normal is a line through a given point on a element of type line, circle, curve, or turtle and orthogonal to that object.
     *
     * @pseudo
     * @constructor
     * @class Normal
     * @type JXG.Line
     * @extends JXG.Line
     * @throws {Error} If the element cannot be constructed with the given parent objects an exception is thrown.
     * @param {JXG.Line,JXG.Circle,JXG.Curve,JXG.Turtle_JXG.Point} o,p The constructed line contains p which lies on the object and is orthogonal
     * to the tangent to the object in the given point.
     * @param {Glider} p Works like above, however the object is given by {@link Glider#slideObject}.
     * @example
     *     // Create a normal to a circle.
     *     var p1 = board.create(&#x27;point&#x27;, [2.0, 2.0]);
     *     var p2 = board.create(&#x27;point&#x27;, [3.0, 2.0]);
     *     var c1 = board.create(&#x27;circle&#x27;, [p1, p2]);
     *
     *     var norm1 = board.create(&#x27;normal&#x27;, [c1, p2]);
     * &lt;div id=&quot;4154753d-3d29-40fb-a860-0b08aa4f3743&quot; style=&quot;width: 400px; height: 400px;&quot;&gt;&lt;/div&gt;
     * &lt;script type=&quot;text/javascript&quot;&gt;
     * (function(){
     *   var board = JXG.JSXGraph.initBoard(&#x27;4154753d-3d29-40fb-a860-0b08aa4f3743&#x27;, {boundingbox: [-1, 9, 9, -1], axis: true, showcopyright: false, shownavigation: false});
     *   var p1 = board.create(&#x27;point&#x27;, [2.0, 2.0]);
     *   var p2 = board.create(&#x27;point&#x27;, [3.0, 2.0]);
     *   var c1 = board.create(&#x27;circle&#x27;, [p1, p2]);
     *   // var p3 = board.create(&#x27;point&#x27;, [1.0, 2.0]);
     *   var norm1 = board.create(&#x27;normal&#x27;, [c1, p2]);
     * })();
     * &lt;/script&gt;
     */
    JXG.createNormal = function (board, parents, attributes) {
        var p, c, l, i, g, f, attr, pp, attrp;

        for (i = 0; i &lt; parents.length; ++i) {
            parents[i] = board.select(parents[i]);
        }
        // One arguments: glider on line, circle or curve
        if (parents.length === 1) {
            p = parents[0];
            c = p.slideObject;
        // Two arguments: (point,line), (point,circle), (line,point) or (circle,point)
        } else if (parents.length === 2) {
            if (Type.isPointType(board, parents[0])) {
                p = Type.providePoints(board, [parents[0]], attributes, &#x27;point&#x27;)[0];
                c = parents[1];
            } else if (Type.isPointType(board, parents[1])) {
                c = parents[0];
                p = Type.providePoints(board, [parents[1]], attributes, &#x27;point&#x27;)[0];
            } else {
                throw new Error(&quot;JSXGraph: Can&#x27;t create normal with parent types &#x27;&quot; +
                    (typeof parents[0]) + &quot;&#x27; and &#x27;&quot; + (typeof parents[1]) + &quot;&#x27;.&quot; +
                    &quot;\nPossible parent types: [point,line], [point,circle], [glider]&quot;);
            }
        } else {
            throw new Error(&quot;JSXGraph: Can&#x27;t create normal with parent types &#x27;&quot; +
                (typeof parents[0]) + &quot;&#x27; and &#x27;&quot; + (typeof parents[1]) + &quot;&#x27;.&quot; +
                &quot;\nPossible parent types: [point,line], [point,circle], [glider]&quot;);
        }

        attr = Type.copyAttributes(attributes, board.options, &#x27;normal&#x27;);
        if (c.elementClass === Const.OBJECT_CLASS_LINE) {
            // Private point
            attrp = Type.copyAttributes(attributes, board.options, &#x27;normal&#x27;, &#x27;point&#x27;);
            pp = board.create(&#x27;point&#x27;, [
                function () {
                    var p = Mat.crossProduct([1, 0, 0], c.stdform);
                    return [p[0], -p[2], p[1]];
                }
            ], attrp);
            pp.isDraggable = true;

            l = board.create(&#x27;line&#x27;, [p, pp], attr);

            /**
             * A helper point used to create a normal to a {@link JXG.Line} object. For normals to circles or curves this
             * element is &lt;tt&gt;undefined&lt;/tt&gt;.
             * @type JXG.Point
             * @property point
             * @memberOf Normal.prototype
             */
            l.point = pp;
        } else if (c.elementClass === Const.OBJECT_CLASS_CIRCLE) {
            l = board.create(&#x27;line&#x27;, [c.midpoint, p], attr);
        } else if (c.elementClass === Const.OBJECT_CLASS_CURVE) {
            if (c.visProp.curvetype !== &#x27;plot&#x27;) {
                g = c.X;
                f = c.Y;
                l = board.create(&#x27;line&#x27;, [
                    function () {
                        return -p.X() * Numerics.D(g)(p.position) - p.Y() * Numerics.D(f)(p.position);
                    },
                    function () {
                        return Numerics.D(g)(p.position);
                    },
                    function () {
                        return Numerics.D(f)(p.position);
                    }
                ], attr);
            } else {                         // curveType &#x27;plot&#x27;
                l = board.create(&#x27;line&#x27;, [
                    function () {
                        var i = Math.floor(p.position),
                            lbda = p.position - i;

                        if (i === c.numberPoints - 1) {
                            i -= 1;
                            lbda = 1;
                        }

                        if (i &lt; 0) {
                            return 1;
                        }

                        return (c.Y(i) + lbda * (c.Y(i + 1) - c.Y(i))) * (c.Y(i) - c.Y(i + 1)) - (c.X(i) + lbda * (c.X(i + 1) - c.X(i))) * (c.X(i + 1) - c.X(i));
                    },
                    function () {
                        var i = Math.floor(p.position);

                        if (i === c.numberPoints - 1) {
                            i -= 1;
                        }

                        if (i &lt; 0) {
                            return 0;
                        }

                        return c.X(i + 1) - c.X(i);
                    },
                    function () {
                        var i = Math.floor(p.position);

                        if (i === c.numberPoints - 1) {
                            i -= 1;
                        }

                        if (i &lt; 0) {
                            return 0;
                        }

                        return c.Y(i + 1) - c.Y(i);
                    }
                ], attr);
            }
        } else if (c.type === Const.OBJECT_TYPE_TURTLE) {
            l = board.create(&#x27;line&#x27;, [
                function () {
                    var el, j,
                        i = Math.floor(p.position),
                        lbda = p.position - i;

                    // run through all curves of this turtle
                    for (j = 0; j &lt; c.objects.length; j++) {
                        el = c.objects[j];

                        if (el.type === Const.OBJECT_TYPE_CURVE) {
                            if (i &lt; el.numberPoints) {
                                break;
                            }

                            i -= el.numberPoints;
                        }
                    }

                    if (i === el.numberPoints - 1) {
                        i -= 1;
                        lbda = 1;
                    }

                    if (i &lt; 0) {
                        return 1;
                    }

                    return (el.Y(i) + lbda * (el.Y(i + 1) - el.Y(i))) * (el.Y(i) - el.Y(i + 1)) - (el.X(i) + lbda * (el.X(i + 1) - el.X(i))) * (el.X(i + 1) - el.X(i));
                },
                function () {
                    var el, j,
                        i = Math.floor(p.position);

                    // run through all curves of this turtle
                    for (j = 0; j &lt; c.objects.length; j++) {
                        el = c.objects[j];
                        if (el.type === Const.OBJECT_TYPE_CURVE) {
                            if (i &lt; el.numberPoints) {
                                break;
                            }

                            i -= el.numberPoints;
                        }
                    }

                    if (i === el.numberPoints - 1) {
                        i -=  1;
                    }

                    if (i &lt; 0) {
                        return 0;
                    }

                    return el.X(i + 1) - el.X(i);
                },
                function () {
                    var el, j,
                        i = Math.floor(p.position);

                    // run through all curves of this turtle
                    for (j = 0; j &lt; c.objects.length; j++) {
                        el = c.objects[j];
                        if (el.type === Const.OBJECT_TYPE_CURVE) {
                            if (i &lt; el.numberPoints) {
                                break;
                            }

                            i -= el.numberPoints;
                        }
                    }

                    if (i === el.numberPoints - 1) {
                        i -= 1;
                    }

                    if (i &lt; 0) {
                        return 0;
                    }

                    return el.Y(i + 1) - el.Y(i);
                }
            ], attr);
        } else {
            throw new Error(&quot;JSXGraph: Can&#x27;t create normal with parent types &#x27;&quot; +
                (typeof parents[0]) + &quot;&#x27; and &#x27;&quot; + (typeof parents[1]) + &quot;&#x27;.&quot; +
                &quot;\nPossible parent types: [point,line], [point,circle], [glider]&quot;);
        }

        l.elType = &#x27;normal&#x27;;
        l.setParents(parents);

        return l;
    };

    /**
     * A bisector is a line which divides an angle into two equal angles. It is given by three points A, B, and
     * C and divides the angle ABC into two equal sized parts.
     *
     * @pseudo
     * @constructor
     * @class Bisector
     * @type JXG.Line
     * @extends JXG.Line
     * @throws {Error} If the element cannot be constructed with the given parent objects an exception is thrown.
     * @param {JXG.Point_JXG.Point_JXG.Point} p1,p2,p3 The angle described by &lt;tt&gt;p1&lt;/tt&gt;, &lt;tt&gt;p2&lt;/tt&gt; and &lt;tt&gt;p3&lt;/tt&gt; will
     * be divided into two equal angles.
     * @example
     *     var p1 = board.create(&#x27;point&#x27;, [6.0, 4.0]);
     *     var p2 = board.create(&#x27;point&#x27;, [3.0, 2.0]);
     *     var p3 = board.create(&#x27;point&#x27;, [1.0, 7.0]);
     *
     *     var bi1 = board.create(&#x27;bisector&#x27;, [p1, p2, p3]);
     * &lt;div id=&quot;0d58cea8-b06a-407c-b27c-0908f508f5a4&quot; style=&quot;width: 400px; height: 400px;&quot;&gt;&lt;/div&gt;
     * &lt;script type=&quot;text/javascript&quot;&gt;
     * (function () {
     *   var board = JXG.JSXGraph.initBoard(&#x27;0d58cea8-b06a-407c-b27c-0908f508f5a4&#x27;, {boundingbox: [-1, 9, 9, -1], axis: true, showcopyright: false, shownavigation: false});
     *   var p1 = board.create(&#x27;point&#x27;, [6.0, 4.0]);
     *   var p2 = board.create(&#x27;point&#x27;, [3.0, 2.0]);
     *   var p3 = board.create(&#x27;point&#x27;, [1.0, 7.0]);
     *   var bi1 = board.create(&#x27;bisector&#x27;, [p1, p2, p3]);
     * })();
     * &lt;/script&gt;
     */
    JXG.createBisector = function (board, parents, attributes) {
        var p, l, i, attr;

        parents = Type.providePoints(board, parents, attributes, &#x27;point&#x27;);
        if (Type.isPoint(parents[0]) &amp;&amp; Type.isPoint(parents[1]) &amp;&amp; Type.isPoint(parents[2])) {
            // hidden and fixed helper
            attr = Type.copyAttributes(attributes, board.options, &#x27;bisector&#x27;, &#x27;point&#x27;);
            attr.snapToGrid = false;

            p = board.create(&#x27;point&#x27;, [
                function () {
                    return Geometry.angleBisector(parents[0], parents[1], parents[2], board);
                }
            ], attr);
            p.dump = false;

            for (i = 0; i &lt; 3; i++) {
                // required for algorithm requiring dependencies between elements
                parents[i].addChild(p);
            }

            if (!Type.exists(attributes.layer)) {
                attributes.layer = board.options.layer.line;
            }

            attr = Type.copyAttributes(attributes, board.options, &#x27;bisector&#x27;);
            l = Line.createLine(board, [parents[1], p], attr);

            /**
             * Helper point
             * @memberOf Bisector.prototype
             * @type JXG.Point
             * @property point
             */
            l.point = p;

            l.elType = &#x27;bisector&#x27;;
            l.setParents(parents);
            l.subs = {
                point: p
            };

            return l;
        }

        throw new Error(&quot;JSXGraph: Can&#x27;t create angle bisector with parent types &#x27;&quot; +
            (typeof parents[0]) + &quot;&#x27; and &#x27;&quot; + (typeof parents[1]) + &quot;&#x27;.&quot; +
            &quot;\nPossible parent types: [point,point,point]&quot;);
    };

    /**
     * Bisector lines are similar to {@link Bisector} but takes two lines as parent elements. The resulting element is
     * a composition of two lines.
     * @pseudo
     * @constructor
     * @class Bisectorlines
     * @type JXG.Composition
     * @extends JXG.Composition
     * @throws {Error} If the element cannot be constructed with the given parent objects an exception is thrown.
     * @param {JXG.Line_JXG.Line} l1,l2 The four angles described by the lines &lt;tt&gt;l1&lt;/tt&gt; and &lt;tt&gt;l2&lt;/tt&gt; will each
     * be divided into two equal angles.
     * @example
     *     var p1 = board.create(&#x27;point&#x27;, [6.0, 4.0]);
     *     var p2 = board.create(&#x27;point&#x27;, [3.0, 2.0]);
     *     var p3 = board.create(&#x27;point&#x27;, [1.0, 7.0]);
     *     var p4 = board.create(&#x27;point&#x27;, [3.0, 0.0]);
     *     var l1 = board.create(&#x27;line&#x27;, [p1, p2]);
     *     var l2 = board.create(&#x27;line&#x27;, [p3, p4]);
     *
     *     var bi1 = board.create(&#x27;bisectorlines&#x27;, [l1, l2]);
     * &lt;div id=&quot;3121ff67-44f0-4dda-bb10-9cda0b80bf18&quot; style=&quot;width: 400px; height: 400px;&quot;&gt;&lt;/div&gt;
     * &lt;script type=&quot;text/javascript&quot;&gt;
     * (function () {
     *   var board = JXG.JSXGraph.initBoard(&#x27;3121ff67-44f0-4dda-bb10-9cda0b80bf18&#x27;, {boundingbox: [-1, 9, 9, -1], axis: true, showcopyright: false, shownavigation: false});
     *   var p1 = board.create(&#x27;point&#x27;, [6.0, 4.0]);
     *   var p2 = board.create(&#x27;point&#x27;, [3.0, 2.0]);
     *   var p3 = board.create(&#x27;point&#x27;, [1.0, 7.0]);
     *   var p4 = board.create(&#x27;point&#x27;, [3.0, 0.0]);
     *   var l1 = board.create(&#x27;line&#x27;, [p1, p2]);
     *   var l2 = board.create(&#x27;line&#x27;, [p3, p4]);
     *   var bi1 = board.create(&#x27;bisectorlines&#x27;, [l1, l2]);
     * })();
     * &lt;/script&gt;
     */
    JXG.createAngularBisectorsOfTwoLines = function (board, parents, attributes) {
        // The angular bisectors of two line [c1,a1,b1] and [c2,a2,b2] are determined by the equation:
        // (a1*x+b1*y+c1*z)/sqrt(a1^2+b1^2) = +/- (a2*x+b2*y+c2*z)/sqrt(a2^2+b2^2)

        var g1, g2, attr, ret,
            l1 = board.select(parents[0]),
            l2 = board.select(parents[1]);

        if (l1.elementClass !== Const.OBJECT_CLASS_LINE || l2.elementClass !== Const.OBJECT_CLASS_LINE) {
            throw new Error(&quot;JSXGraph: Can&#x27;t create angle bisectors of two lines with parent types &#x27;&quot; +
                (typeof parents[0]) + &quot;&#x27; and &#x27;&quot; + (typeof parents[1]) + &quot;&#x27;.&quot; +
                &quot;\nPossible parent types: [line,line]&quot;);
        }

        if (!Type.exists(attributes.layer)) {
            attributes.layer = board.options.layer.line;
        }

        attr = Type.copyAttributes(attributes, board.options, &#x27;bisectorlines&#x27;, &#x27;line1&#x27;);
        g1 = board.create(&#x27;line&#x27;, [
            function () {
                var d1 = Math.sqrt(l1.stdform[1] * l1.stdform[1] + l1.stdform[2] * l1.stdform[2]),
                    d2 = Math.sqrt(l2.stdform[1] * l2.stdform[1] + l2.stdform[2] * l2.stdform[2]);

                return l1.stdform[0] / d1 - l2.stdform[0] / d2;
            },
            function () {
                var d1 = Math.sqrt(l1.stdform[1] * l1.stdform[1] + l1.stdform[2] * l1.stdform[2]),
                    d2 = Math.sqrt(l2.stdform[1] * l2.stdform[1] + l2.stdform[2] * l2.stdform[2]);

                return l1.stdform[1] / d1 - l2.stdform[1] / d2;
            },
            function () {
                var d1 = Math.sqrt(l1.stdform[1] * l1.stdform[1] + l1.stdform[2] * l1.stdform[2]),
                    d2 = Math.sqrt(l2.stdform[1] * l2.stdform[1] + l2.stdform[2] * l2.stdform[2]);

                return l1.stdform[2] / d1 - l2.stdform[2] / d2;
            }
        ], attr);

        if (!Type.exists(attributes.layer)) {
            attributes.layer = board.options.layer.line;
        }
        attr = Type.copyAttributes(attributes, board.options, &#x27;bisectorlines&#x27;, &#x27;line2&#x27;);
        g2 = board.create(&#x27;line&#x27;, [
            function () {
                var d1 = Math.sqrt(l1.stdform[1] * l1.stdform[1] + l1.stdform[2] * l1.stdform[2]),
                    d2 = Math.sqrt(l2.stdform[1] * l2.stdform[1] + l2.stdform[2] * l2.stdform[2]);

                return l1.stdform[0] / d1 + l2.stdform[0] / d2;
            },
            function () {
                var d1 = Math.sqrt(l1.stdform[1] * l1.stdform[1] + l1.stdform[2] * l1.stdform[2]),
                    d2 = Math.sqrt(l2.stdform[1] * l2.stdform[1] + l2.stdform[2] * l2.stdform[2]);

                return l1.stdform[1] / d1 + l2.stdform[1] / d2;
            },
            function () {
                var d1 = Math.sqrt(l1.stdform[1] * l1.stdform[1] + l1.stdform[2] * l1.stdform[2]),
                    d2 = Math.sqrt(l2.stdform[1] * l2.stdform[1] + l2.stdform[2] * l2.stdform[2]);

                return l1.stdform[2] / d1 + l2.stdform[2] / d2;
            }
        ], attr);

        // documentation
        /**
         * First line.
         * @memberOf Bisectorlines.prototype
         * @property line1
         * @type JXG.Line
         */

        /**
         * Second line.
         * @memberOf Bisectorlines.prototype
         * @property line2
         * @type JXG.Line
         */

        ret = new Composition({line1: g1, line2: g2});

        g1.dump = false;
        g2.dump = false;

        ret.elType = &#x27;bisectorlines&#x27;;
        ret.setParents([l1.id, l2.id]);
        ret.subs = {
            line1: g1,
            line2: g2
        };

        return ret;
    };

    /**
     * Constructs the midpoint of a {@link Circumcircle}. Like the circumcircle the circumcenter
     * is constructed by providing three points.
     *
     * A circumcenter is given by three points which are all lying on the circle with the
     * constructed circumcenter as the midpoint.
     *
     * @pseudo
     * @constructor
     * @class Circumcenter
     * @type JXG.Point
     * @extends JXG.Point
     * @throws {Error} If the element cannot be constructed with the given parent objects an exception is thrown.
     * @param {JXG.Point_JXG.Point_JXG.Point} p1,p2,p3 The constructed point is the midpoint of the circle determined
     * by p1, p2, and p3.
     * @example
     *     var p1 = board.create(&#x27;point&#x27;, [0.0, 2.0]);
     *     var p2 = board.create(&#x27;point&#x27;, [2.0, 1.0]);
     *     var p3 = board.create(&#x27;point&#x27;, [3.0, 3.0]);
     *
     *     var cc1 = board.create(&#x27;circumcenter&#x27;, [p1, p2, p3]);
     * &lt;div id=&quot;e8a40f95-bf30-4eb4-88a8-f4d5495261fd&quot; style=&quot;width: 400px; height: 400px;&quot;&gt;&lt;/div&gt;
     * &lt;script type=&quot;text/javascript&quot;&gt;
     * (function(){
     *   var ccmex1_board = JXG.JSXGraph.initBoard(&#x27;e8a40f95-bf30-4eb4-88a8-f4d5495261fd&#x27;, {boundingbox: [-1, 9, 9, -1], axis: true, showcopyright: false, shownavigation: false});
     *   var ccmex1_p1 = ccmex1_board.create(&#x27;point&#x27;, [0.0, 2.0]);
     *   var ccmex1_p2 = ccmex1_board.create(&#x27;point&#x27;, [6.0, 1.0]);
     *   var ccmex1_p3 = ccmex1_board.create(&#x27;point&#x27;, [3.0, 7.0]);
     *   var ccmex1_cc1 = ccmex1_board.create(&#x27;circumcenter&#x27;, [ccmex1_p1, ccmex1_p2, ccmex1_p3]);
     * })();
     * &lt;/script&gt;
     */
    JXG.createCircumcenter = function (board, parents, attributes) {
        var p, i, a, b, c;

        parents = Type.providePoints(board, parents, attributes, &#x27;point&#x27;);
        if (Type.isPoint(parents[0]) &amp;&amp; Type.isPoint(parents[1]) &amp;&amp; Type.isPoint(parents[2])) {

            a = parents[0];
            b = parents[1];
            c = parents[2];

            p = Point.createPoint(board, [
                function () {
                    return Geometry.circumcenter(a, b, c, board);
                }
            ], attributes);

            for (i = 0; i &lt; 3; i++) {
                parents[i].addChild(p);
            }

            p.elType = &#x27;circumcenter&#x27;;
            p.setParents(parents);

            p.generatePolynomial = function () {
                /*
                 *  CircumcircleMidpoint takes three points A, B and C  and creates point M, which is the circumcenter of A, B, and C.
                 *
                 *
                 * So we have two conditions:
                 *
                 *   (a)   CT  ==  AT           (distance condition I)
                 *   (b)   BT  ==  AT           (distance condition II)
                 *
                 */
                var a1 = a.symbolic.x,
                    a2 = a.symbolic.y,
                    b1 = b.symbolic.x,
                    b2 = b.symbolic.y,
                    c1 = c.symbolic.x,
                    c2 = c.symbolic.y,
                    t1 = p.symbolic.x,
                    t2 = p.symbolic.y,

                    poly1 = [&#x27;((&#x27;, t1, &#x27;)-(&#x27;, a1, &#x27;))^2+((&#x27;, t2, &#x27;)-(&#x27;, a2, &#x27;))^2-((&#x27;, t1, &#x27;)-(&#x27;, b1, &#x27;))^2-((&#x27;, t2, &#x27;)-(&#x27;, b2, &#x27;))^2&#x27;].join(&#x27;&#x27;),
                    poly2 = [&#x27;((&#x27;, t1, &#x27;)-(&#x27;, a1, &#x27;))^2+((&#x27;, t2, &#x27;)-(&#x27;, a2, &#x27;))^2-((&#x27;, t1, &#x27;)-(&#x27;, c1, &#x27;))^2-((&#x27;, t2, &#x27;)-(&#x27;, c2, &#x27;))^2&#x27;].join(&#x27;&#x27;);

                return [poly1, poly2];
            };

            return p;
        }

        throw new Error(&quot;JSXGraph: Can&#x27;t create circumcircle midpoint with parent types &#x27;&quot; +
            (typeof parents[0]) + &quot;&#x27;, &#x27;&quot; + (typeof parents[1]) + &quot;&#x27; and &#x27;&quot; + (typeof parents[2]) + &quot;&#x27;.&quot; +
            &quot;\nPossible parent types: [point,point,point]&quot;);
    };

    /**
     * Constructs the incenter of the triangle described by the three given points.{@link http://mathworld.wolfram.com/Incenter.html}
     *
     * @pseudo
     * @constructor
     * @class Incenter
     * @type JXG.Point
     * @extends JXG.Point
     * @throws {Error} If the element cannot be constructed with the given parent objects an exception is thrown.
     * @param {JXG.Point_JXG.Point_JXG.Point} p1,p2,p3 The constructed point is the incenter of the triangle described
     * by p1, p2, and p3.
     * @example
     *     var p1 = board.create(&#x27;point&#x27;, [0.0, 2.0]);
     *     var p2 = board.create(&#x27;point&#x27;, [2.0, 1.0]);
     *     var p3 = board.create(&#x27;point&#x27;, [3.0, 3.0]);
     *
     *     var ic1 = board.create(&#x27;incenter&#x27;, [p1, p2, p3]);
     * &lt;div id=&quot;e8a40f95-bf30-4eb4-88a8-a2d5495261fd&quot; style=&quot;width: 400px; height: 400px;&quot;&gt;&lt;/div&gt;
     * &lt;script type=&quot;text/javascript&quot;&gt;
     * (function(){
     *   var board = JXG.JSXGraph.initBoard(&#x27;e8a40f95-bf30-4eb4-88a8-a2d5495261fd&#x27;, {boundingbox: [-1, 9, 9, -1], axis: true, showcopyright: false, shownavigation: false});
     *   var p1 = board.create(&#x27;point&#x27;, [0.0, 2.0]);
     *   var p2 = board.create(&#x27;point&#x27;, [6.0, 1.0]);
     *   var p3 = board.create(&#x27;point&#x27;, [3.0, 7.0]);
     *   var ic1 = board.create(&#x27;incenter&#x27;, [p1, p2, p3]);
     * })();
     * &lt;/script&gt;
     */
    JXG.createIncenter = function (board, parents, attributes) {
        var p, A, B, C;

        parents = Type.providePoints(board, parents, attributes, &#x27;point&#x27;);
        if (parents.length &gt;= 3 &amp;&amp; Type.isPoint(parents[0]) &amp;&amp; Type.isPoint(parents[1]) &amp;&amp; Type.isPoint(parents[2])) {
            A = parents[0];
            B = parents[1];
            C = parents[2];

            p = board.create(&#x27;point&#x27;, [function () {
                var a, b, c;

                a = Math.sqrt((B.X() - C.X()) * (B.X() - C.X()) + (B.Y() - C.Y()) * (B.Y() - C.Y()));
                b = Math.sqrt((A.X() - C.X()) * (A.X() - C.X()) + (A.Y() - C.Y()) * (A.Y() - C.Y()));
                c = Math.sqrt((B.X() - A.X()) * (B.X() - A.X()) + (B.Y() - A.Y()) * (B.Y() - A.Y()));

                return new Coords(Const.COORDS_BY_USER, [(a * A.X() + b * B.X() + c * C.X()) / (a + b + c), (a * A.Y() + b * B.Y() + c * C.Y()) / (a + b + c)], board);
            }], attributes);

            p.elType = &#x27;incenter&#x27;;
            p.setParents(parents);

        } else {
            throw new Error(&quot;JSXGraph: Can&#x27;t create incenter with parent types &#x27;&quot; +
                (typeof parents[0]) + &quot;&#x27;, &#x27;&quot; + (typeof parents[1]) + &quot;&#x27; and &#x27;&quot; + (typeof parents[2]) + &quot;&#x27;.&quot; +
                &quot;\nPossible parent types: [point,point,point]&quot;);
        }

        return p;
    };

    /**
     * A circumcircle is circle through three given points.
     *
     * @pseudo
     * @constructor
     * @class Circumcircle
     * @type JXG.Circle
     * @extends JXG.Circle
     * @throws {Error} If the element cannot be constructed with the given parent objects an exception is thrown.
     * @param {JXG.Point_JXG.Point_JXG.Point} p1,p2,p3 The constructed element is the circle determined by &lt;tt&gt;p1&lt;/tt&gt;, &lt;tt&gt;p2&lt;/tt&gt;, and &lt;tt&gt;p3&lt;/tt&gt;.
     * @example
     *     var p1 = board.create(&#x27;point&#x27;, [0.0, 2.0]);
     *     var p2 = board.create(&#x27;point&#x27;, [2.0, 1.0]);
     *     var p3 = board.create(&#x27;point&#x27;, [3.0, 3.0]);
     *
     *     var cc1 = board.create(&#x27;circumcircle&#x27;, [p1, p2, p3]);
     * &lt;div id=&quot;e65c9861-0bf0-402d-af57-3ab11962f5ac&quot; style=&quot;width: 400px; height: 400px;&quot;&gt;&lt;/div&gt;
     * &lt;script type=&quot;text/javascript&quot;&gt;
     * (function(){
     *   var board = JXG.JSXGraph.initBoard(&#x27;e65c9861-0bf0-402d-af57-3ab11962f5ac&#x27;, {boundingbox: [-1, 9, 9, -1], axis: true, showcopyright: false, shownavigation: false});
     *   var p1 = board.create(&#x27;point&#x27;, [0.0, 2.0]);
     *   var p2 = board.create(&#x27;point&#x27;, [6.0, 1.0]);
     *   var p3 = board.create(&#x27;point&#x27;, [3.0, 7.0]);
     *   var cc1 = board.create(&#x27;circumcircle&#x27;, [p1, p2, p3]);
     * })();
     * &lt;/script&gt;
     */
    JXG.createCircumcircle = function (board, parents, attributes) {
        var p, c, attr;

        parents = Type.providePoints(board, parents, attributes, &#x27;point&#x27;);
        if (parents === false) {
            throw new Error(&quot;JSXGraph: Can&#x27;t create circumcircle with parent types &#x27;&quot; +
                (typeof parents[0]) + &quot;&#x27;, &#x27;&quot; + (typeof parents[1]) + &quot;&#x27; and &#x27;&quot; + (typeof parents[2]) + &quot;&#x27;.&quot; +
                &quot;\nPossible parent types: [point,point,point]&quot;);
        }

        try {
            attr = Type.copyAttributes(attributes, board.options, &#x27;circumcircle&#x27;, &#x27;center&#x27;);
            p = JXG.createCircumcenter(board, parents, attr);

            p.dump = false;

            if (!Type.exists(attributes.layer)) {
                attributes.layer = board.options.layer.circle;
            }
            attr = Type.copyAttributes(attributes, board.options, &#x27;circumcircle&#x27;);
            c = Circle.createCircle(board, [p, parents[0]], attr);

            c.elType = &#x27;circumcircle&#x27;;
            c.setParents(parents);
            c.subs = {
                center: p
            };
        } catch (e) {
            throw new Error(&quot;JSXGraph: Can&#x27;t create circumcircle with parent types &#x27;&quot; +
                (typeof parents[0]) + &quot;&#x27;, &#x27;&quot; + (typeof parents[1]) + &quot;&#x27; and &#x27;&quot; + (typeof parents[2]) + &quot;&#x27;.&quot; +
                &quot;\nPossible parent types: [point,point,point]&quot;);
        }

        // p is already stored as midpoint in c so there&#x27;s no need to store it explicitly.

        return c;
    };

    /**
     * An incircle is given by three points and is the incenter of
     * the triangle spanned by these three points.
     *
     * @pseudo
     * @constructor
     * @class Incircle
     * @type JXG.Circle
     * @extends JXG.Circle
     * @throws {Error} If the element cannot be constructed with the given parent objects an exception is thrown.
     * @param {JXG.Point_JXG.Point_JXG.Point} p1,p2,p3 The constructed point is the midpoint of the incircle of
     * &lt;tt&gt;p1&lt;/tt&gt;, &lt;tt&gt;p2&lt;/tt&gt;, and &lt;tt&gt;p3&lt;/tt&gt;.
     * @example
     *     var p1 = board.create(&#x27;point&#x27;, [0.0, 2.0]);
     *     var p2 = board.create(&#x27;point&#x27;, [2.0, 1.0]);
     *     var p3 = board.create(&#x27;point&#x27;, [3.0, 3.0]);
     *
     *     var ic1 = board.create(&#x27;incircle&#x27;, [p1, p2, p3]);
     * &lt;div id=&quot;e65c9861-0bf0-402d-af57-2ab12962f8ac&quot; style=&quot;width: 400px; height: 400px;&quot;&gt;&lt;/div&gt;
     * &lt;script type=&quot;text/javascript&quot;&gt;
     * (function(){
     *   var board = JXG.JSXGraph.initBoard(&#x27;e65c9861-0bf0-402d-af57-2ab12962f8ac&#x27;, {boundingbox: [-1, 9, 9, -1], axis: true, showcopyright: false, shownavigation: false});
     *   var p1 = board.create(&#x27;point&#x27;, [0.0, 2.0]);
     *   var p2 = board.create(&#x27;point&#x27;, [6.0, 1.0]);
     *   var p3 = board.create(&#x27;point&#x27;, [3.0, 7.0]);
     *   var ic1 = board.create(&#x27;incircle&#x27;, [p1, p2, p3]);
     * })();
     * &lt;/script&gt;
     */
    JXG.createIncircle = function (board, parents, attributes) {
        var p, c, attr;

        parents = Type.providePoints(board, parents, attributes, &#x27;point&#x27;);
        if (parents === false) {
            throw new Error(&quot;JSXGraph: Can&#x27;t create circumcircle with parent types &#x27;&quot; +
                (typeof parents[0]) + &quot;&#x27;, &#x27;&quot; + (typeof parents[1]) + &quot;&#x27; and &#x27;&quot; + (typeof parents[2]) + &quot;&#x27;.&quot; +
                &quot;\nPossible parent types: [point,point,point]&quot;);
        }
        try {
            attr = Type.copyAttributes(attributes, board.options, &#x27;incircle&#x27;, &#x27;center&#x27;);
            p = JXG.createIncenter(board, parents, attr);

            p.dump = false;

            if (!Type.exists(attributes.layer)) {
                attributes.layer = board.options.layer.circle;
            }
            attr = Type.copyAttributes(attributes, board.options, &#x27;incircle&#x27;);
            c = Circle.createCircle(board, [p, function () {
                var a = Math.sqrt((parents[1].X() - parents[2].X()) * (parents[1].X() - parents[2].X()) + (parents[1].Y() - parents[2].Y()) * (parents[1].Y() - parents[2].Y())),
                    b = Math.sqrt((parents[0].X() - parents[2].X()) * (parents[0].X() - parents[2].X()) + (parents[0].Y() - parents[2].Y()) * (parents[0].Y() - parents[2].Y())),
                    c = Math.sqrt((parents[1].X() - parents[0].X()) * (parents[1].X() - parents[0].X()) + (parents[1].Y() - parents[0].Y()) * (parents[1].Y() - parents[0].Y())),
                    s = (a + b + c) / 2;

                return Math.sqrt(((s - a) * (s - b) * (s - c)) / s);
            }], attr);

            c.elType = &#x27;incircle&#x27;;
            c.setParents(parents);

            /**
             * The center of the incircle
             * @memberOf Incircle.prototype
             * @type Incenter
             * @property center
             */
            c.center = p;

            c.subs = {
                center: p
            };
        } catch (e) {
            throw new Error(&quot;JSXGraph: Can&#x27;t create circumcircle with parent types &#x27;&quot; +
                (typeof parents[0]) + &quot;&#x27;, &#x27;&quot; + (typeof parents[1]) + &quot;&#x27; and &#x27;&quot; + (typeof parents[2]) + &quot;&#x27;.&quot; +
                &quot;\nPossible parent types: [point,point,point]&quot;);
        }

        // p is already stored as midpoint in c so there&#x27;s no need to store it explicitly.

        return c;
    };

    /**
     * This element is used to construct a reflected point.
     *
     * A reflected point is given by a point and a line. It is determined by the reflection of the given point
     * against the given line.
     *
     * @pseudo
     * @constructor
     * @class Reflection
     * @type JXG.Point
     * @extends JXG.Point
     * @throws {Error} If the element cannot be constructed with the given parent objects an exception is thrown.
     * @param {JXG.Point_JXG.Line} p,l The reflection point is the reflection of p against l.
     * @example
     *     var p1 = board.create(&#x27;point&#x27;, [0.0, 4.0]);
     *     var p2 = board.create(&#x27;point&#x27;, [6.0, 1.0]);
     *     var l1 = board.create(&#x27;line&#x27;, [p1, p2]);
     *     var p3 = board.create(&#x27;point&#x27;, [3.0, 3.0]);
     *
     *     var rp1 = board.create(&#x27;reflection&#x27;, [p3, l1]);
     * &lt;div id=&quot;087a798e-a36a-4f52-a2b4-29a23a69393b&quot; style=&quot;width: 400px; height: 400px;&quot;&gt;&lt;/div&gt;
     * &lt;script type=&quot;text/javascript&quot;&gt;
     * (function(){
     *   var rboard = JXG.JSXGraph.initBoard(&#x27;087a798e-a36a-4f52-a2b4-29a23a69393b&#x27;, {boundingbox: [-1, 9, 9, -1], axis: true, showcopyright: false, shownavigation: false});
     *   var rp1 = rboard.create(&#x27;point&#x27;, [0.0, 4.0]);
     *   var rp2 = rboard.create(&#x27;point&#x27;, [6.0, 1.0]);
     *   var rl1 = rboard.create(&#x27;line&#x27;, [rp1, rp2]);
     *   var rp3 = rboard.create(&#x27;point&#x27;, [3.0, 3.0]);
     *   var rrp1 = rboard.create(&#x27;reflection&#x27;, [rp3, rl1]);
     * })();
     * &lt;/script&gt;
     */
    JXG.createReflection = function (board, parents, attributes) {
        var l, p, r, t, i;

        for (i = 0; i &lt; parents.length; ++i) {
            parents[i] = board.select(parents[i]);
        }
        if (Type.isPoint(parents[0]) &amp;&amp; parents[1].elementClass === Const.OBJECT_CLASS_LINE) {
            p = Type.providePoints(board, [parents[0]], attributes, &#x27;point&#x27;)[0];
            l = parents[1];
        } else if (Type.isPoint(parents[1]) &amp;&amp; parents[0].elementClass === Const.OBJECT_CLASS_LINE) {
            p = Type.providePoints(board, [parents[1]], attributes, &#x27;point&#x27;)[0];
            l = parents[0];
        } else {
            throw new Error(&quot;JSXGraph: Can&#x27;t create reflection point with parent types &#x27;&quot; +
                (typeof parents[0]) + &quot;&#x27; and &#x27;&quot; + (typeof parents[1]) + &quot;&#x27;.&quot; +
                &quot;\nPossible parent types: [line,point]&quot;);
        }

        t = Transform.createTransform(board, [l], {type: &#x27;reflect&#x27;});
        r = Point.createPoint(board, [p, t], attributes);
        p.addChild(r);
        l.addChild(r);

        r.elType = &#x27;reflection&#x27;;
        r.setParents(parents);

        r.prepareUpdate().update();

        r.generatePolynomial = function () {
            /*
             *  Reflection takes a point R and a line L and creates point P, which is the reflection of R on L.
             *  L is defined by two points A and B.
             *
             * So we have two conditions:
             *
             *   (a)   RP  _|_  AB            (orthogonality condition)
             *   (b)   AR  ==   AP            (distance condition)
             *
             */
            var a1 = l.point1.symbolic.x,
                a2 = l.point1.symbolic.y,
                b1 = l.point2.symbolic.x,
                b2 = l.point2.symbolic.y,
                p1 = p.symbolic.x,
                p2 = p.symbolic.y,
                r1 = r.symbolic.x,
                r2 = r.symbolic.y,

                poly1 = [&#x27;((&#x27;, r2, &#x27;)-(&#x27;, p2, &#x27;))*((&#x27;, a2, &#x27;)-(&#x27;, b2, &#x27;))+((&#x27;, a1, &#x27;)-(&#x27;, b1, &#x27;))*((&#x27;, r1, &#x27;)-(&#x27;, p1, &#x27;))&#x27;].join(&#x27;&#x27;),
                poly2 = [&#x27;((&#x27;, r1, &#x27;)-(&#x27;, a1, &#x27;))^2+((&#x27;, r2, &#x27;)-(&#x27;, a2, &#x27;))^2-((&#x27;, p1, &#x27;)-(&#x27;, a1, &#x27;))^2-((&#x27;, p2, &#x27;)-(&#x27;, a2, &#x27;))^2&#x27;].join(&#x27;&#x27;);

            return [poly1, poly2];
        };

        return r;
    };

    /**
     * A mirror point will be constructed.
     *
     * A mirror point is determined by the reflection of a given point against another given point.
     *
     * @pseudo
     * @constructor
     * @class Mirrorpoint
     * @type JXG.Point
     * @extends JXG.Point
     * @throws {Error} If the element cannot be constructed with the given parent objects an exception is thrown.
     * @param {JXG.Point_JXG.Point} p1,p2 The constructed point is the reflection of p2 against p1.
     * @example
     *     var p1 = board.create(&#x27;point&#x27;, [3.0, 3.0]);
     *     var p2 = board.create(&#x27;point&#x27;, [6.0, 1.0]);
     *
     *     var mp1 = board.create(&#x27;mirrorpoint&#x27;, [p1, p2]);
     * &lt;div id=&quot;7eb2a814-6c4b-4caa-8cfa-4183a948d25b&quot; style=&quot;width: 400px; height: 400px;&quot;&gt;&lt;/div&gt;
     * &lt;script type=&quot;text/javascript&quot;&gt;
     * (function(){
     *   var mboard = JXG.JSXGraph.initBoard(&#x27;7eb2a814-6c4b-4caa-8cfa-4183a948d25b&#x27;, {boundingbox: [-1, 9, 9, -1], axis: true, showcopyright: false, shownavigation: false});
     *   var mp1 = mboard.create(&#x27;point&#x27;, [3.0, 3.0]);
     *   var mp2 = mboard.create(&#x27;point&#x27;, [6.0, 1.0]);
     *   var mmp1 = mboard.create(&#x27;mirrorpoint&#x27;, [mp1, mp2]);
     * })();
     * &lt;/script&gt;
     */
    JXG.createMirrorPoint = function (board, parents, attributes) {
        var p, i;

        parents = Type.providePoints(board, parents, attributes, &#x27;point&#x27;);
        if (Type.isPoint(parents[0]) &amp;&amp; Type.isPoint(parents[1])) {
            p = Point.createPoint(board, [
                function () {
                    return Geometry.rotation(parents[0], parents[1], Math.PI, board);
                }
            ], attributes);

            for (i = 0; i &lt; 2; i++) {
                parents[i].addChild(p);
            }

            p.elType = &#x27;mirrorpoint&#x27;;
            p.setParents(parents);

        } else {
            throw new Error(&quot;JSXGraph: Can&#x27;t create mirror point with parent types &#x27;&quot; +
                (typeof parents[0]) + &quot;&#x27; and &#x27;&quot; + (typeof parents[1]) + &quot;&#x27;.&quot; +
                &quot;\nPossible parent types: [point,point]&quot;);
        }

        p.prepareUpdate().update();

        return p;
    };

    /**
     * This element is used to visualize the integral of a given curve over a given interval.
     *
     * The Integral element is used to visualize the area under a given curve over a given interval
     * and to calculate the area&#x27;s value. For that a polygon and gliders are used. The polygon displays the area,
     * the gliders are used to change the interval dynamically.
     *
     * @pseudo
     * @constructor
     * @class Integral
     * @type JXG.Curve
     * @extends JXG.Curve
     * @throws {Error} If the element cannot be constructed with the given parent objects an exception is thrown.
     * @param {Array_JXG.Curve} i,c The constructed element covers the area between the curve &lt;tt&gt;c&lt;/tt&gt; and the x-axis
     * within the interval &lt;tt&gt;i&lt;/tt&gt;.
     * @example
     *     var c1 = board.create(&#x27;functiongraph&#x27;, [function (t) { return t*t*t; }]);
     *     var i1 = board.create(&#x27;integral&#x27;, [[-1.0, 4.0], c1]);
     * &lt;div id=&quot;d45d7188-6624-4d6e-bebb-1efa2a305c8a&quot; style=&quot;width: 400px; height: 400px;&quot;&gt;&lt;/div&gt;
     * &lt;script type=&quot;text/javascript&quot;&gt;
     * (function(){
     *   var intex1_board = JXG.JSXGraph.initBoard(&#x27;d45d7188-6624-4d6e-bebb-1efa2a305c8a&#x27;, {boundingbox: [-5, 5, 5, -5], axis: true, showcopyright: false, shownavigation: false});
     *   var intex1_c1 = intex1_board.create(&#x27;functiongraph&#x27;, [function (t) { return Math.cos(t)*t; }]);
     *   var intex1_i1 = intex1_board.create(&#x27;integral&#x27;, [[-2.0, 2.0], intex1_c1]);
     * })();
     * &lt;/script&gt;
     */
    JXG.createIntegral = function (board, parents, attributes) {
        var interval, curve, attr,
            start, end, startx, starty, endx, endy,
            pa_on_curve, pa_on_axis, pb_on_curve, pb_on_axis,
            t = null, p;

        if (Type.isArray(parents[0]) &amp;&amp; parents[1].elementClass === Const.OBJECT_CLASS_CURVE) {
            interval = parents[0];
            curve = parents[1];
        } else if (Type.isArray(parents[1]) &amp;&amp; parents[0].elementClass === Const.OBJECT_CLASS_CURVE) {
            interval = parents[1];
            curve = parents[0];
        } else {
            throw new Error(&quot;JSXGraph: Can&#x27;t create integral with parent types &#x27;&quot; +
                (typeof parents[0]) + &quot;&#x27; and &#x27;&quot; + (typeof parents[1]) + &quot;&#x27;.&quot; +
                &quot;\nPossible parent types: [[number|function,number|function],curve]&quot;);
        }

        attr = Type.copyAttributes(attributes, board.options, &#x27;integral&#x27;);
        attr.withLabel = false;  // There is a custom &#x27;label&#x27; below.
        p = board.create(&#x27;curve&#x27;, [[0], [0]], attr);

        // Correct the interval if necessary - NOT ANYMORE, GGB&#x27;s fault
        start = interval[0];
        end = interval[1];

        if (Type.isFunction(start)) {
            startx = start;
            starty = function () { return curve.Y(startx()); };
            start = startx();
        } else {
            startx = start;
            starty = curve.Y(start);
        }

        if (Type.isFunction(end)) {
            endx = end;
            endy = function () { return curve.Y(endx()); };
            end = endx();
        } else {
            endx = end;
            endy = curve.Y(end);
        }

        attr = Type.copyAttributes(attributes, board.options, &#x27;integral&#x27;, &#x27;curveLeft&#x27;);
        pa_on_curve = board.create(&#x27;glider&#x27;, [startx, starty, curve], attr);
        if (Type.isFunction(startx)) {
            pa_on_curve.hideElement();
        }

        attr = Type.copyAttributes(attributes, board.options, &#x27;integral&#x27;, &#x27;baseLeft&#x27;);
        pa_on_axis = board.create(&#x27;point&#x27;, [
            function () {
                if (p.visProp.axis === &#x27;y&#x27;) {
                    return 0;
                }

                return pa_on_curve.X();
            },
            function () {
                if (p.visProp.axis === &#x27;y&#x27;) {
                    return pa_on_curve.Y();
                }

                return 0;
            }
        ], attr);

        attr = Type.copyAttributes(attributes, board.options, &#x27;integral&#x27;, &#x27;curveRight&#x27;);
        pb_on_curve = board.create(&#x27;glider&#x27;, [endx, endy, curve], attr);
        if (Type.isFunction(endx)) {
            pb_on_curve.hideElement();
        }

        attr = Type.copyAttributes(attributes, board.options, &#x27;integral&#x27;, &#x27;baseRight&#x27;);
        pb_on_axis = board.create(&#x27;point&#x27;, [
            function () {
                if (p.visProp.axis === &#x27;y&#x27;) {
                    return 0;
                }
                return pb_on_curve.X();
            },
            function () {
                if (p.visProp.axis === &#x27;y&#x27;) {
                    return pb_on_curve.Y();
                }

                return 0;
            }
        ], attr);

        attr = Type.copyAttributes(attributes, board.options, &#x27;integral&#x27;);
        if (attr.withlabel !== false &amp;&amp; attr.axis !== &#x27;y&#x27;) {
            attr = Type.copyAttributes(attributes, board.options, &#x27;integral&#x27;, &#x27;label&#x27;);
            attr = Type.copyAttributes(attr, board.options, &#x27;label&#x27;);

            t = board.create(&#x27;text&#x27;, [
                function () {
                    var off = new Coords(Const.COORDS_BY_SCREEN, [
                            this.visProp.offset[0] + this.board.origin.scrCoords[1],
                            0
                        ], this.board, false),
                        bb = this.board.getBoundingBox(),
                        dx = (bb[2] - bb[0]) * 0.1,
                        x = pb_on_curve.X();

                    if (x &lt; bb[0]) {
                        x = bb[0] + dx;
                    } else if (x &gt; bb[2]) {
                        x = bb[2] - dx;
                    }

                    return x + off.usrCoords[1];
                },
                function () {
                    var off = new Coords(Const.COORDS_BY_SCREEN, [
                            0,
                            this.visProp.offset[1] + this.board.origin.scrCoords[2]
                        ], this.board, false),
                        bb = this.board.getBoundingBox(),
                        dy = (bb[1] - bb[3]) * 0.1,
                        y = pb_on_curve.Y();

                    if (y &gt; bb[1]) {
                        y = bb[1] - dy;
                    } else if (y &lt; bb[3]) {
                        y = bb[3] + dy;
                    }

                    return y + off.usrCoords[2];
                },
                function () {
                    var Int = Numerics.NewtonCotes([pa_on_axis.X(), pb_on_axis.X()], curve.Y);
                    return &#x27;&amp;int; = &#x27; + Int.toFixed(4);
                }
            ], attr);

            t.dump = false;

            pa_on_curve.addChild(t);
            pb_on_curve.addChild(t);
        }

        // dump stuff
        pa_on_curve.dump = false;
        pa_on_axis.dump = false;

        pb_on_curve.dump = false;
        pb_on_axis.dump = false;

        p.elType = &#x27;integral&#x27;;
        p.setParents([curve.id, interval]);
        p.subs = {
            curveLeft: pa_on_curve,
            baseLeft: pa_on_axis,
            curveRight: pb_on_curve,
            baseRight: pb_on_axis
        };

        if (attr.withLabel) {
            p.subs.label = t;
        }

        /** @ignore */
        p.Value = function () {
            return Numerics.I([pa_on_axis.X(), pb_on_axis.X()], curve.Y);
        };

        /**
         * documented in JXG.Curve
         * @ignore
         */
        p.updateDataArray = function () {
            var x, y,
                i, left, right,
                lowx, upx,
                lowy, upy;

            if (this.visProp.axis === &#x27;y&#x27;) {
                if (pa_on_curve.Y() &lt; pb_on_curve.Y()) {
                    lowx = pa_on_curve.X();
                    lowy = pa_on_curve.Y();
                    upx = pb_on_curve.X();
                    upy = pb_on_curve.Y();
                } else {
                    lowx = pb_on_curve.X();
                    lowy = pb_on_curve.Y();
                    upx = pa_on_curve.X();
                    upy = pa_on_curve.Y();
                }
                left = Math.min(lowx, upx);
                right = Math.max(lowx, upx);

                x = [0, lowx];
                y = [lowy, lowy];

                for (i = 0; i &lt; curve.numberPoints; i++) {
                    if (lowy &lt;= curve.points[i].usrCoords[2] &amp;&amp;
                            left &lt;= curve.points[i].usrCoords[1] &amp;&amp;
                            curve.points[i].usrCoords[2] &lt;= upy  &amp;&amp;
                            curve.points[i].usrCoords[1] &lt;= right) {
                        x.push(curve.points[i].usrCoords[1]);
                        y.push(curve.points[i].usrCoords[2]);
                    }
                }
                x.push(upx);
                y.push(upy);
                x.push(0);
                y.push(upy);

                // close the curve
                x.push(0);
                y.push(lowy);
            } else {
                if (pa_on_axis.X() &lt; pb_on_axis.X()) {
                    left = pa_on_axis.X();
                    right = pb_on_axis.X();
                } else {
                    left = pb_on_axis.X();
                    right = pa_on_axis.X();
                }

                x = [left, left];
                y = [0, curve.Y(left)];

                for (i = 0; i &lt; curve.numberPoints; i++) {
                    if ((left &lt;= curve.points[i].usrCoords[1]) &amp;&amp; (curve.points[i].usrCoords[1] &lt;= right)) {
                        x.push(curve.points[i].usrCoords[1]);
                        y.push(curve.points[i].usrCoords[2]);
                    }
                }
                x.push(right);
                y.push(curve.Y(right));
                x.push(right);
                y.push(0);

                // close the curve
                x.push(left);
                y.push(0);
            }

            this.dataX = x;
            this.dataY = y;
        };

        pa_on_curve.addChild(p);
        pb_on_curve.addChild(p);
        pa_on_axis.addChild(p);
        pb_on_axis.addChild(p);

        /**
         * The point on the axis initially corresponding to the lower value of the interval.
         * @memberOf Integral.prototype
         * @property baseLeft
         * @type JXG.Point
         */
        p.baseLeft = pa_on_axis;

        /**
         * The point on the axis initially corresponding to the higher value of the interval.
         * @memberOf Integral.prototype
         * @property baseRight
         * @type JXG.Point
         */
        p.baseRight = pb_on_axis;

        /**
         * The glider on the curve corresponding to the lower value of the interval.
         * @memberOf Integral.prototype
         * @property curveLeft
         * @type Glider
         */
        p.curveLeft = pa_on_curve;

        /**
         * The glider on the axis corresponding to the higher value of the interval.
         * @memberOf Integral.prototype
         * @property curveRight
         * @type Glider
         */
        p.curveRight = pb_on_curve;

        p.methodMap = JXG.deepCopy(p.methodMap, {
            curveLeft: &#x27;curveLeft&#x27;,
            baseLeft: &#x27;baseLeft&#x27;,
            curveRight: &#x27;curveRight&#x27;,
            baseRight: &#x27;baseRight&#x27;,
            Value: &#x27;Value&#x27;
        });

        /**
         * documented in GeometryElement
         * @ignore
         */
        p.label = t;

        return p;
    };

    /**
     * Creates a grid to support the user with element placement.
     *
     * A grid is a set of vertical and horizontal lines to support the user with element placement. This method
     * draws such a grid on the given board. It uses options given in {@link JXG.Options#grid}. This method does not
     * take any parent elements. It is usually instantiated on the board&#x27;s creation via the attribute &lt;tt&gt;grid&lt;/tt&gt; set
     * to true.
     *
     * @pseudo
     * @constructor
     * @class Grid
     * @type JXG.Curve
     * @extends JXG.Curve
     * @throws {Error} If the element cannot be constructed with the given parent objects an exception is thrown.
     * @example
     *     grid = board.create(&#x27;grid&#x27;, []);
     * &lt;div id=&quot;a9a0671f-7a51-4fa2-8697-241142c00940&quot; style=&quot;width: 400px; height: 400px;&quot;&gt;&lt;/div&gt;
     * &lt;script type=&quot;text/javascript&quot;&gt;
     * (function () {
     *  board = JXG.JSXGraph.initBoard(&#x27;a9a0671f-7a51-4fa2-8697-241142c00940&#x27;, {boundingbox:[-4, 6, 10, -6], axis: false, grid: false, keepaspectratio: true});
     *  grid = board.create(&#x27;grid&#x27;, []);
     * })();
     * &lt;/script&gt;
     */
    JXG.createGrid = function (board, parents, attributes) {
        var c, attr;

        attr = Type.copyAttributes(attributes, board.options, &#x27;grid&#x27;);
        c = board.create(&#x27;curve&#x27;, [[null], [null]], attr);

        c.elType = &#x27;grid&#x27;;
        c.type = Const.OBJECT_TYPE_GRID;

        c.updateDataArray = function () {
            var start, end, i, topLeft, bottomRight,
                gridX = this.visProp.gridx,
                gridY = this.visProp.gridy;

            if (Type.isArray(this.visProp.topleft)) {
                topLeft = new Coords(this.visProp.tltype || Const.COORDS_BY_USER, this.visProp.topleft, board);
            } else {
                topLeft = new Coords(Const.COORDS_BY_SCREEN, [0, 0], board);
            }

            if (Type.isArray(this.visProp.bottomright)) {
                bottomRight = new Coords(this.visProp.brtype || Const.COORDS_BY_USER, this.visProp.bottomright, board);
            } else {
                bottomRight = new Coords(Const.COORDS_BY_SCREEN, [board.canvasWidth, board.canvasHeight], board);
            }


            //
            //      |         |         |
            //  ----+---------+---------+-----
            //      |        /|         |
            //      |    gridY|     &lt;---+------   Grid Cell
            //      |        \|         |
            //  ----+---------+---------+-----
            //      |         |\ gridX /|
            //      |         |         |
            //
            // uc: usercoordinates
            //
            // currently one grid cell is 1/JXG.Options.grid.gridX uc wide and 1/JXG.Options.grid.gridY uc high.
            // this may work perfectly with GeonextReader (#readGeonext, initialization of gridX and gridY) but it
            // is absolutely not user friendly when it comes to use it as an API interface.
            // i changed this to use gridX and gridY as the actual width and height of the grid cell. for this i
            // had to refactor these methods:
            //
            //  DONE JXG.Board.calculateSnapSizes (init p1, p2)
            //  DONE JXG.GeonextReader.readGeonext (init gridX, gridY)
            //

            board.options.grid.hasGrid = true;

            topLeft.setCoordinates(Const.COORDS_BY_USER, [Math.floor(topLeft.usrCoords[1] / gridX) * gridX, Math.ceil(topLeft.usrCoords[2] / gridY) * gridY]);
            bottomRight.setCoordinates(Const.COORDS_BY_USER, [Math.ceil(bottomRight.usrCoords[1] / gridX) * gridX, Math.floor(bottomRight.usrCoords[2] / gridY) * gridY]);

            c.dataX = [];
            c.dataY = [];

            // Sometimes the bounding box is used to invert the axis. We have to take this into account here.
            start = topLeft.usrCoords[2];
            end = bottomRight.usrCoords[2];

            if (topLeft.usrCoords[2] &lt; bottomRight.usrCoords[2]) {
                start = bottomRight.usrCoords[2];
                end = topLeft.usrCoords[2];
            }

            // start with the horizontal grid:
            for (i = start; i &gt; end - gridY; i -= gridY) {
                c.dataX.push(topLeft.usrCoords[1], bottomRight.usrCoords[1], NaN);
                c.dataY.push(i, i, NaN);
            }

            start = topLeft.usrCoords[1];
            end = bottomRight.usrCoords[1];

            if (topLeft.usrCoords[1] &gt; bottomRight.usrCoords[1]) {
                start = bottomRight.usrCoords[1];
                end = topLeft.usrCoords[1];
            }

            // build vertical grid
            for (i = start; i &lt; end + gridX; i += gridX) {
                c.dataX.push(i, i, NaN);
                c.dataY.push(topLeft.usrCoords[2], bottomRight.usrCoords[2], NaN);
            }

        };

        // we don&#x27;t care about highlighting so we turn it off completely to save a lot of
        // time on every mouse move
        c.hasPoint = function () {
            return false;
        };

        board.grids.push(c);

        return c;
    };

    /**
     * Creates an area indicating the solution of a linear inequality.
     *
     * Display the solution set of a linear inequality (less than or equal to).
     *
     * @pseudo
     * @param {JXG.Line} l The area drawn will be the area below this line. With the attribute
     * inverse:true, the inequality &#x27;greater than or equal to&#x27; is shown.
     * @constructor
     * @class Inequality
     * @type JXG.Curve
     * @extends JXG.Curve
     * @throws {Error} If the element cannot be constructed with the given parent objects an exception is thrown.
     * @example
     *     var p = board.create(&#x27;point&#x27;, [1, 3]),
     *         q = board.create(&#x27;point&#x27;, [-2, -4]),
     *         l = board.create(&#x27;line&#x27;, [p, q]),
     *         ineq = board.create(&#x27;inequality&#x27;, [l]);
     *     ineq = board.create(&#x27;inequality&#x27;, [l]);
     * &lt;div id=&quot;2b703006-fd98-11e1-b79e-ef9e591c002e&quot; style=&quot;width: 400px; height: 400px;&quot;&gt;&lt;/div&gt;
     * &lt;script type=&quot;text/javascript&quot;&gt;
     * (function () {
     *  var board = JXG.JSXGraph.initBoard(&#x27;2b703006-fd98-11e1-b79e-ef9e591c002e&#x27;, {boundingbox:[-4, 6, 10, -6], axis: true, grid: false, keepaspectratio: true}),
     *      p = board.create(&#x27;point&#x27;, [1, 3]),
     *      q = board.create(&#x27;point&#x27;, [-2, -4]),
     *      l = board.create(&#x27;line&#x27;, [p, q]),
     *      ineq = board.create(&#x27;inequality&#x27;, [l]);
     * })();
     * &lt;/script&gt;
     *
     * @example
     *     // Plot the inequality
     *     //     y &gt;= 2/3 x + 1
     *     // or
     *     //     0 &gt;= -3y + 2x +1
     *     var l = board.create(&#x27;line&#x27;, [1, 2, -3]),
     *         ineq = board.create(&#x27;inequality&#x27;, [l], {inverse:true});
     * &lt;div id=&quot;1ded3812-2da4-4323-abaf-1db4bad1bfbd&quot; style=&quot;width: 400px; height: 400px;&quot;&gt;&lt;/div&gt;
     * &lt;script type=&quot;text/javascript&quot;&gt;
     * (function () {
     *  var board = JXG.JSXGraph.initBoard(&#x27;1ded3812-2da4-4323-abaf-1db4bad1bfbd&#x27;, {boundingbox:[-4, 6, 10, -6], axis: true, grid: false, keepaspectratio: true}),
     *      l = board.create(&#x27;line&#x27;, [1, 2, -3]),
     *      ineq = board.create(&#x27;inequality&#x27;, [l], {inverse:true});
     * })();
     * &lt;/script&gt;
     */
    JXG.createInequality = function (board, parents, attributes) {
        var f, a, attr;

        attr = Type.copyAttributes(attributes, board.options, &#x27;inequality&#x27;);
        if (parents[0].elementClass === Const.OBJECT_CLASS_LINE) {
            a = board.create(&#x27;curve&#x27;, [[], []], attr);
            a.hasPoint = function () {
                return false;
            };
            a.updateDataArray = function () {
                var i1, i2,
                    // this will be the height of the area. We mustn&#x27;t rely upon the board height because if we pan the view
                    // such that the line is not visible anymore, the borders of the area will get visible in some cases.
                    h,
                    bb = board.getBoundingBox(),
                    factor = attr.inverse ? -1 : 1,
                    expansion = 1.5,
                    w = expansion * Math.max(bb[2] - bb[0], bb[1] - bb[3]),
                    // fake a point (for Math.Geometry.perpendicular)
                    dp = {
                        coords: {
                            usrCoords: [1, (bb[0] + bb[2]) / 2, attr.inverse ? bb[1] : bb[3]]
                        }
                    },

                    slope1 = parents[0].stdform.slice(1),
                    slope2 = slope1;

                if (slope1[1] &gt; 0) {
                    slope1 = Statistics.multiply(slope1, -1);
                    slope2 = slope1;
                }

                // calculate the area height = 2* the distance of the line to the point in the middle of the top/bottom border.
                h = expansion * Math.max(Geometry.perpendicular(parents[0], dp, board)[0].distance(Const.COORDS_BY_USER, dp.coords), w);
                h *= factor;

                // reuse dp
                dp = {
                    coords: {
                        usrCoords: [1, (bb[0] + bb[2]) / 2, (bb[1] + bb[3]) / 2]
                    }
                };

                // If dp is on the line, Geometry.perpendicular will return a point not on the line.
                // Since this somewhat odd behavior of Geometry.perpendicular is needed in GEONExT,
                // it is circumvented here.
                if (Math.abs(Mat.innerProduct(dp.coords.usrCoords, parents[0].stdform, 3)) &gt;= Mat.eps) {
                    dp = Geometry.perpendicular(parents[0], dp, board)[0].usrCoords;
                } else {
                    dp = dp.coords.usrCoords;
                }
                i1 = [1, dp[1] + slope1[1] * w, dp[2] - slope1[0] * w];
                i2 = [1, dp[1] - slope2[1] * w, dp[2] + slope2[0] * w];

                // One of the vectors based in i1 and orthogonal to the parent line has the direction d1 = (slope1, -1)
                // We will go from i1 to to i1 + h*d1, from there to i2 + h*d2 (with d2 calculated equivalent to d1) and
                // end up in i2.
                this.dataX = [i1[1], i1[1] + slope1[0] * h, i2[1] + slope2[0] * h, i2[1], i1[1]];
                this.dataY = [i1[2], i1[2] + slope1[1] * h, i2[2] + slope2[1] * h, i2[2], i1[2]];
            };
        } else {
            f = Type.createFunction(parents[0]);
            if (!Type.exists(f)) {
                throw new Error(&quot;JSXGraph: Can&#x27;t create area with the given parents.&quot; +
                    &quot;\nPossible parent types: [line], [function]&quot;);
            }
        }

        return a;
    };


    JXG.registerElement(&#x27;arrowparallel&#x27;, JXG.createArrowParallel);
    JXG.registerElement(&#x27;bisector&#x27;, JXG.createBisector);
    JXG.registerElement(&#x27;bisectorlines&#x27;, JXG.createAngularBisectorsOfTwoLines);
    JXG.registerElement(&#x27;circumcircle&#x27;, JXG.createCircumcircle);
    JXG.registerElement(&#x27;circumcirclemidpoint&#x27;, JXG.createCircumcenter);
    JXG.registerElement(&#x27;circumcenter&#x27;, JXG.createCircumcenter);
    JXG.registerElement(&#x27;incenter&#x27;, JXG.createIncenter);
    JXG.registerElement(&#x27;incircle&#x27;, JXG.createIncircle);
    JXG.registerElement(&#x27;integral&#x27;, JXG.createIntegral);
    JXG.registerElement(&#x27;midpoint&#x27;, JXG.createMidpoint);
    JXG.registerElement(&#x27;mirrorpoint&#x27;, JXG.createMirrorPoint);
    JXG.registerElement(&#x27;normal&#x27;, JXG.createNormal);
    JXG.registerElement(&#x27;orthogonalprojection&#x27;, JXG.createOrthogonalProjection);
    JXG.registerElement(&#x27;parallel&#x27;, JXG.createParallel);
    JXG.registerElement(&#x27;parallelpoint&#x27;, JXG.createParallelPoint);
    JXG.registerElement(&#x27;perpendicular&#x27;, JXG.createPerpendicular);
    JXG.registerElement(&#x27;perpendicularpoint&#x27;, JXG.createPerpendicularPoint);
    JXG.registerElement(&#x27;perpendicularsegment&#x27;, JXG.createPerpendicularSegment);
    JXG.registerElement(&#x27;reflection&#x27;, JXG.createReflection);
    JXG.registerElement(&#x27;grid&#x27;, JXG.createGrid);
    JXG.registerElement(&#x27;inequality&#x27;, JXG.createInequality);

    return {
        createArrowParallel: JXG.createArrowParallel,
        createBisector: JXG.createBisector,
        createAngularBisectorOfTwoLines: JXG.createAngularBisectorsOfTwoLines,
        createCircumcircle: JXG.createCircumcircle,
        createCircumcenter: JXG.createCircumcenter,
        createIncenter: JXG.createIncenter,
        createIncircle: JXG.createIncircle,
        createIntegral: JXG.createIntegral,
        createMidpoint: JXG.createMidpoint,
        createMirrorPoint: JXG.createMirrorPoint,
        createNormal: JXG.createNormal,
        createOrthogonalProjection: JXG.createOrthogonalProjection,
        createParallel: JXG.createParallel,
        createParallelPoint: JXG.createParallelPoint,
        createPerpendicular: JXG.createPerpendicular,
        createPerpendicularPoint: JXG.createPerpendicularPoint,
        createPerpendicularSegmen: JXG.createPerpendicularSegment,
        createReflection: JXG.createReflection,
        createGrid: JXG.createGrid,
        createInequality: JXG.createInequality
    };
});

    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>

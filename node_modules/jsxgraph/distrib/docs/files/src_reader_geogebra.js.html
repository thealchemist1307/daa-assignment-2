<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src/reader/geogebra.js - JSXGraph</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="../assets/js/jsxgraphcore.js"></script>
    <link rel="stylesheet" href="../assets/css/jsxgraph.css">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../assets/css/logo_blue.png" title="JSXGraph" width="117" height="52"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.99.4</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/Angle.html">Angle</a> </li>
                                <li><a href="../classes/Arc.html">Arc</a> </li>
                                <li><a href="../classes/Arrow.html">Arrow</a> </li>
                                <li><a href="../classes/Arrowparallel.html">Arrowparallel</a> </li>
                                <li><a href="../classes/Axis.html">Axis</a> </li>
                                <li><a href="../classes/Bisector.html">Bisector</a> </li>
                                <li><a href="../classes/Bisectorlines.html">Bisectorlines</a> </li>
                                <li><a href="../classes/Button.html">Button</a> </li>
                                <li><a href="../classes/Checkbox.html">Checkbox</a> </li>
                                <li><a href="../classes/Circle.html">Circle</a> </li>
                                <li><a href="../classes/Circumcenter.html">Circumcenter</a> </li>
                                <li><a href="../classes/Circumcircle.html">Circumcircle</a> </li>
                                <li><a href="../classes/CircumcircleArc.html">CircumcircleArc</a> </li>
                                <li><a href="../classes/CircumcircleSector.html">CircumcircleSector</a> </li>
                                <li><a href="../classes/Conic.html">Conic</a> </li>
                                <li><a href="../classes/Curve.html">Curve</a> </li>
                                <li><a href="../classes/Ellipse.html">Ellipse</a> </li>
                                <li><a href="../classes/EventEmitter.html">EventEmitter</a> </li>
                                <li><a href="../classes/Functiongraph.html">Functiongraph</a> </li>
                                <li><a href="../classes/Glider.html">Glider</a> </li>
                                <li><a href="../classes/Grid.html">Grid</a> </li>
                                <li><a href="../classes/Group.html">Group</a> </li>
                                <li><a href="../classes/Hatch.html">Hatch</a> </li>
                                <li><a href="../classes/Hyperbola.html">Hyperbola</a> </li>
                                <li><a href="../classes/Image.html">Image</a> </li>
                                <li><a href="../classes/Incenter.html">Incenter</a> </li>
                                <li><a href="../classes/Incircle.html">Incircle</a> </li>
                                <li><a href="../classes/Inequality.html">Inequality</a> </li>
                                <li><a href="../classes/Input.html">Input</a> </li>
                                <li><a href="../classes/Integral.html">Integral</a> </li>
                                <li><a href="../classes/Intersection.html">Intersection</a> </li>
                                <li><a href="../classes/JXG.html">JXG</a> </li>
                                <li><a href="../classes/JXG.AbstractRenderer.html">JXG.AbstractRenderer</a> </li>
                                <li><a href="../classes/JXG.Board.html">JXG.Board</a> </li>
                                <li><a href="../classes/JXG.C.html">JXG.C</a> </li>
                                <li><a href="../classes/JXG.CanvasRenderer.html">JXG.CanvasRenderer</a> </li>
                                <li><a href="../classes/JXG.Chart.html">JXG.Chart</a> </li>
                                <li><a href="../classes/JXG.Circle.html">JXG.Circle</a> </li>
                                <li><a href="../classes/JXG.Complex.html">JXG.Complex</a> </li>
                                <li><a href="../classes/JXG.Composition.html">JXG.Composition</a> </li>
                                <li><a href="../classes/JXG.Coords.html">JXG.Coords</a> </li>
                                <li><a href="../classes/JXG.CoordsElement.html">JXG.CoordsElement</a> </li>
                                <li><a href="../classes/JXG.Curve.html">JXG.Curve</a> </li>
                                <li><a href="../classes/JXG.GeometryElement.html">JXG.GeometryElement</a> </li>
                                <li><a href="../classes/JXG.Group.html">JXG.Group</a> </li>
                                <li><a href="../classes/JXG.Image.html">JXG.Image</a> </li>
                                <li><a href="../classes/JXG.JSXGraph.html">JXG.JSXGraph</a> </li>
                                <li><a href="../classes/JXG.Line.html">JXG.Line</a> </li>
                                <li><a href="../classes/JXG.Math.html">JXG.Math</a> </li>
                                <li><a href="../classes/JXG.Math.Geometry.html">JXG.Math.Geometry</a> </li>
                                <li><a href="../classes/JXG.Math.Numerics.html">JXG.Math.Numerics</a> </li>
                                <li><a href="../classes/JXG.Math.Poly.html">JXG.Math.Poly</a> </li>
                                <li><a href="../classes/JXG.Math.Poly.Monomial.html">JXG.Math.Poly.Monomial</a> </li>
                                <li><a href="../classes/JXG.Math.Poly.Polynomial.html">JXG.Math.Poly.Polynomial</a> </li>
                                <li><a href="../classes/JXG.Math.Poly.Ring.html">JXG.Math.Poly.Ring</a> </li>
                                <li><a href="../classes/JXG.Math.Quadtree.html">JXG.Math.Quadtree</a> </li>
                                <li><a href="../classes/JXG.Math.Statistics.html">JXG.Math.Statistics</a> </li>
                                <li><a href="../classes/JXG.Math.Symbolic.html">JXG.Math.Symbolic</a> </li>
                                <li><a href="../classes/JXG.NoRenderer.html">JXG.NoRenderer</a> </li>
                                <li><a href="../classes/JXG.Options.html">JXG.Options</a> </li>
                                <li><a href="../classes/JXG.Point.html">JXG.Point</a> </li>
                                <li><a href="../classes/JXG.Polygon.html">JXG.Polygon</a> </li>
                                <li><a href="../classes/JXG.SVGRenderer.html">JXG.SVGRenderer</a> </li>
                                <li><a href="../classes/JXG.Text.html">JXG.Text</a> </li>
                                <li><a href="../classes/JXG.Ticks.html">JXG.Ticks</a> </li>
                                <li><a href="../classes/JXG.Transformation.html">JXG.Transformation</a> </li>
                                <li><a href="../classes/JXG.Turtle.html">JXG.Turtle</a> </li>
                                <li><a href="../classes/JXG.Util.Base64.html">JXG.Util.Base64</a> </li>
                                <li><a href="../classes/JXG.Util.Unzip.html">JXG.Util.Unzip</a> </li>
                                <li><a href="../classes/JXG.VMLRenderer.html">JXG.VMLRenderer</a> </li>
                                <li><a href="../classes/Line.html">Line</a> </li>
                                <li><a href="../classes/Locus.html">Locus</a> </li>
                                <li><a href="../classes/MajorArc.html">MajorArc</a> </li>
                                <li><a href="../classes/Midpoint.html">Midpoint</a> </li>
                                <li><a href="../classes/MinorArc.html">MinorArc</a> </li>
                                <li><a href="../classes/MinorSector.html">MinorSector</a> </li>
                                <li><a href="../classes/Mirrorpoint.html">Mirrorpoint</a> </li>
                                <li><a href="../classes/NonReflexAngle.html">NonReflexAngle</a> </li>
                                <li><a href="../classes/Normal.html">Normal</a> </li>
                                <li><a href="../classes/Orthogonalprojection.html">Orthogonalprojection</a> </li>
                                <li><a href="../classes/OtherIntersection.html">OtherIntersection</a> </li>
                                <li><a href="../classes/Parabola.html">Parabola</a> </li>
                                <li><a href="../classes/Parallel.html">Parallel</a> </li>
                                <li><a href="../classes/Parallelpoint.html">Parallelpoint</a> </li>
                                <li><a href="../classes/Perpendicular.html">Perpendicular</a> </li>
                                <li><a href="../classes/PerpendicularPoint.html">PerpendicularPoint</a> </li>
                                <li><a href="../classes/PerpendicularSegment.html">PerpendicularSegment</a> </li>
                                <li><a href="../classes/Point.html">Point</a> </li>
                                <li><a href="../classes/PolarLine.html">PolarLine</a> </li>
                                <li><a href="../classes/PolePoint.html">PolePoint</a> </li>
                                <li><a href="../classes/Polygon.html">Polygon</a> </li>
                                <li><a href="../classes/RadicalAxis.html">RadicalAxis</a> </li>
                                <li><a href="../classes/Reflection.html">Reflection</a> </li>
                                <li><a href="../classes/ReflexAngle.html">ReflexAngle</a> </li>
                                <li><a href="../classes/registerReader.html">registerReader</a> </li>
                                <li><a href="../classes/RegularPolygon.html">RegularPolygon</a> </li>
                                <li><a href="../classes/Riemannsum.html">Riemannsum</a> </li>
                                <li><a href="../classes/Sector.html">Sector</a> </li>
                                <li><a href="../classes/Segment.html">Segment</a> </li>
                                <li><a href="../classes/Semicircle.html">Semicircle</a> </li>
                                <li><a href="../classes/Slider.html">Slider</a> </li>
                                <li><a href="../classes/Slopetriangle.html">Slopetriangle</a> </li>
                                <li><a href="../classes/Spline.html">Spline</a> </li>
                                <li><a href="../classes/Stepfunction.html">Stepfunction</a> </li>
                                <li><a href="../classes/Tangent.html">Tangent</a> </li>
                                <li><a href="../classes/Tapemeasure.html">Tapemeasure</a> </li>
                                <li><a href="../classes/Text.html">Text</a> </li>
                                <li><a href="../classes/Ticks.html">Ticks</a> </li>
                                <li><a href="../classes/Tracecurve.html">Tracecurve</a> </li>
                                <li><a href="../classes/Transformation.html">Transformation</a> </li>
                                <li><a href="../classes/Turtle.html">Turtle</a> </li>
                            </ul>
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="../modules/JXG.html">JXG</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: src/reader/geogebra.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/*
 Copyright 2008-2013
 Matthias Ehmann,
 Michael Gerhaeuser,
 Carsten Miller,
 Bianca Valentin,
 Alfred Wassermann,
 Peter Wilfahrt

 This file is part of JSXGraph.

 JSXGraph is free software dual licensed under the GNU LGPL or MIT License.

 You can redistribute it and/or modify it under the terms of the

 * GNU Lesser General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version
 OR
 * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT

 JSXGraph is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU Lesser General Public License for more details.

 You should have received a copy of the GNU Lesser General Public License and
 the MIT License along with JSXGraph. If not, see &lt;http://www.gnu.org/licenses/&gt;
 and &lt;http://opensource.org/licenses/MIT/&gt;.
 */


/*global JXG: true*/
/*jslint nomen: true, plusplus: true*/

/* depends:
 jxg
 base/constants
 base/coords
 math/numerics
 utils/type
 utils/color
 utils/base64
 utils/encoding
 utils/zip
 utils/xml
  elements:
   grid
   axis
   circle
   glider
   point
   line
   normal
   regularpolygon
   polygon
   intersection
   otherintersection
   midpoint
   text
   arrow
   transform
   mirrorpoint
   reflection
   arc
   ellipse
   conic
   sector
   perpendicular
   tangent
   polar
   circumcirclearc
   circumcirclesector
   semicircle
   angle
   bisector
   slider
   functiongraph
   segment
   integral
 */

(function () {

    &quot;use strict&quot;;

    JXG.GeogebraReader = function (board, str) {
        var tree, content;

        content = this.prepareString(str);
        tree = JXG.XML.parse(content);

        this.tree = tree;
        this.board = board;
        this.ggbElements = [];

        // this needs to be accessible from eval&#x27;d strings so we have to keep it in board
        this.board.ggb = {};
        this.format = parseFloat(tree.getElementsByTagName(&#x27;geogebra&#x27;)[0].getAttribute(&#x27;format&#x27;));
        this.decimals = parseInt(tree.getElementsByTagName(&#x27;geogebra&#x27;)[0].getElementsByTagName(&#x27;kernel&#x27;)[0].getElementsByTagName(&#x27;decimals&#x27;)[0].getAttribute(&#x27;val&#x27;), 10);
    };

    JXG.extend(JXG.GeogebraReader.prototype, /** @lends JXG.GeogebraReader.prototype */ {
        /**
         * @param {String} type the type of expression
         * @param {String} m first input value
         * @param {String} n second input value
         * @return {String|Array|Number} return the object, string or calculated value
         */
        ggbAct: function (type, m, n) {
            var s1, s2, a,
                regexValue = new RegExp(&#x27;JXG\\.boards\\[\&#x27;&#x27; + this.board.id + &#x27;\&#x27;\\].select\\(\&quot;(.+?)\&quot;\\)\\.&#x27;),
                regexSelect = new RegExp(&#x27;JXG\\.boards\\[\&#x27;&#x27; + this.board.id + &#x27;\&#x27;\\].select&#x27;),
                v1 = m,
                v2 = n;

            switch (type.toLowerCase()) {
            case &#x27;end&#x27;:
                return v1;
            case &#x27;coord&#x27;:
                s1 = (this.ggbElements[v1]) ? &#x27;JXG.boards[\&#x27;&#x27; + this.board.id + &#x27;\&#x27;].select(\&#x27;&#x27; + v1 + &#x27;\&#x27;)&#x27; : v1;
                s2 = (this.ggbElements[v2]) ? &#x27;JXG.boards[\&#x27;&#x27; + this.board.id + &#x27;\&#x27;].select(\&#x27;&#x27; + v2 + &#x27;\&#x27;)&#x27; : v2;
                return [s1, s2];
            case &#x27;le&#x27;: // smaller than
                return &#x27;( (&#x27; + v1 + &#x27;) &lt;= (&#x27; + v2 + &#x27;) )&#x27;;
            case &#x27;ge&#x27;: // greater than
                return &#x27;( (&#x27; + v1 + &#x27;) &gt;= (&#x27; + v2 + &#x27;) )&#x27;;
            case &#x27;eq&#x27;: // equal
                return &#x27;( (&#x27; + v1 + &#x27;) == (&#x27; + v2 + &#x27;) )&#x27;;
            case &#x27;neq&#x27;: // not equal
                return &#x27;( (&#x27; + v1 + &#x27;) != (&#x27; + v2 + &#x27;) )&#x27;;
            case &#x27;lt&#x27;: // smaller
                return &#x27;( (&#x27; + v1 + &#x27;) &lt; (&#x27; + v2 + &#x27;) )&#x27;;
            case &#x27;gt&#x27;: // greater
                return &#x27;( (&#x27; + v1 + &#x27;) &gt; (&#x27; + v2 + &#x27;) )&#x27;;
            case &#x27;add&#x27;:
                //Add: Vector + Vector
                if (this.isGGBVector(v1) &amp;&amp; this.isGGBVector(v2)) {
                    return [1, v1[1] + &#x27;+&#x27; + v2[1], v1[2] + &#x27;+&#x27; + v2[2]];
                }

                // The first match (which is negated) is to check if we are looking at a blank element or a value from this element
                // If the select() call is followed by a &#x27;.&#x27;, a property or a value is accessed, ergo we must not append .X() and .Y().
                if (JXG.isString(v1) &amp;&amp; !v1.match(regexValue) &amp;&amp; v1.match(regexSelect)) {
                    s1 = [v1 + &#x27;.X()&#x27;, v1 + &#x27;.Y()&#x27;];
                } else {
                    s1 = v1;
                }

                if (JXG.isString(v2) &amp;&amp; !v2.match(regexValue) &amp;&amp; v2.match(regexSelect)) {
                    s2 = [v2 + &#x27;.X()&#x27;, v2 + &#x27;.Y()&#x27;];
                } else {
                    s2 = v2;
                }

                //Add: Vector + Point
                if (this.isGGBVector(s1) &amp;&amp; JXG.isArray(s2)) {
                    return [s1[1] + &#x27;+&#x27; + s2[0], s1[2] + &#x27;+&#x27; + s2[1]];
                }

                //Add: Vector + Point
                if (this.isGGBVector(s2) &amp;&amp; JXG.isArray(s1)) {
                    return [s2[1] + &#x27;+&#x27; + s1[0], s2[2] + &#x27;+&#x27; + s1[1]];
                }

                if (JXG.isArray(s1) &amp;&amp; JXG.isArray(s2)) {
                    return [s1[0] + &#x27; + &#x27; + s2[0], s1[1] + &#x27; + &#x27; + s2[1]];
                }

                if ((JXG.isNumber(s1) || JXG.isString(s1)) &amp;&amp; (JXG.isNumber(s2) || JXG.isString(s2))) {
                    return s1 + &#x27; + &#x27; + s2;
                }

                if ((JXG.isNumber(s1) || JXG.isString(s1)) &amp;&amp; JXG.isArray(s2)) {
                    return [s1 + &#x27; + &#x27; + s2[0], s1 + &#x27; + &#x27; + s2[1]];
                }

                if (JXG.isArray(s1) &amp;&amp; (JXG.isNumber(s2) || JXG.isString(s2))) {
                    return [s1[0] + &#x27; + &#x27; + s2, s1[1] + &#x27; + &#x27; + s2];
                }

                return s1 + &#x27; + &#x27; + s2;
            case &#x27;sub&#x27;:
                if (this.isGGBVector(v1) &amp;&amp; this.isGGBVector(v2)) { //Sub: Vector - Vector
                    return [1, v1[1] + &#x27;-&#x27; + v2[1], v1[2] + &#x27;-&#x27; + v2[2]];
                }

                if (JXG.isString(v1) &amp;&amp; !v1.match(regexValue) &amp;&amp; v1.match(regexSelect)) {
                    s1 = [v1 + &#x27;.X()&#x27;, v1 + &#x27;.Y()&#x27;];
                } else {
                    s1 = v1;
                }

                if (JXG.isString(v2) &amp;&amp; !v2.match(regexValue) &amp;&amp; v2.match(regexSelect)) {
                    s2 = [v2 + &#x27;.X()&#x27;, v2 + &#x27;.Y()&#x27;];
                } else {
                    s2 = v2;
                }

                //Add: Vector - Point
                if (this.isGGBVector(s1) &amp;&amp; JXG.isArray(s2)) {
                    return [s1[1] + &#x27;-&#x27; + s2[0], s1[2] + &#x27;-&#x27; + s2[1]];
                }

                //Add: Punkt - Vector
                if (JXG.isArray(s1) &amp;&amp; this.isGGBVector(s2)) {
                    return [s1[0] + &#x27;-(&#x27; + s2[1] + &#x27;)&#x27;, s1[1] + &#x27;-(&#x27; + s2[2] + &#x27;)&#x27;];
                }

                if (JXG.isArray(s1) &amp;&amp; JXG.isArray(s2)) {
                    return [ s1[0] + &#x27; - &#x27; + s2[0], s1[1] + &#x27; - &#x27; + s2[1] ];
                }

                if ((JXG.isNumber(s1) || JXG.isString(s1)) &amp;&amp; (JXG.isNumber(s2) || JXG.isString(s2))) {
                    return s1 + &#x27; - &#x27; + s2;
                }

                if ((JXG.isNumber(s1) || JXG.isString(s1)) &amp;&amp; JXG.isArray(s2)) {
                    return [s1 + &#x27; - &#x27; + s2[0], s1 + &#x27; - &#x27; + s2[1]];
                }

                if (JXG.isArray(s1) &amp;&amp; (JXG.isNumber(s2) || JXG.isString(s2))) {
                    return [s1[0] + &#x27; - &#x27; + s2, s1[1] + &#x27; - &#x27; + s2];
                }

                return s1 + &#x27; - &#x27; + s2;
            case &#x27;neg&#x27;:
                return &#x27;!(&#x27; + v1 + &#x27;)&#x27;;
            case &#x27;pow&#x27;:
                return &#x27;Math.pow(&#x27; + v1 + &#x27;, &#x27; + v2 + &#x27;)&#x27;;
            case &#x27;or&#x27;:
                return &#x27;(&#x27; + v1 + &#x27;||&#x27; + v2 + &#x27;)&#x27;;
            case &#x27;and&#x27;:
                return &#x27;(&#x27; + v1 + &#x27;&amp;&amp;&#x27; + v2 + &#x27;)&#x27;;
            case &#x27;mul&#x27;:
                if (this.isGGBVector(v1) &amp;&amp; !JXG.isArray(v2)) { // Mult: Vector * Skalar
                    return [1, &#x27;(&#x27; + v1[1] + &#x27;)*&#x27; + v2, &#x27;(&#x27; + v1[2] + &#x27;)*&#x27; + v2];
                }

                if (!JXG.isArray(v1) &amp;&amp; this.isGGBVector(v2)) { // Mult: Skalar * Vector
                    return [1, &#x27;(&#x27; + v2[1] + &#x27;)*&#x27; + v1, &#x27;(&#x27; + v2[2] + &#x27;)*&#x27; + v1];
                }

                if (this.isGGBVector(v1) &amp;&amp; this.isGGBVector(v2)) { //Mult: Vector * Vector
                    return &#x27;((&#x27; + v1[1] + &#x27;)*(&#x27; + v2[1] + &#x27;)+(&#x27; + v1[2] + &#x27;)*(&#x27; + v2[2] + &#x27;))&#x27;;
                }

                if (JXG.isString(v1) &amp;&amp; !v1.match(regexValue) &amp;&amp; v1.match(regexSelect)) {
                    s1 = [v1 + &#x27;.X()&#x27;, v1 + &#x27;.Y()&#x27;];
                } else {
                    s1 = v1;
                }

                if (JXG.isString(v2) &amp;&amp; !v2.match(regexValue) &amp;&amp; v2.match(regexSelect)) {
                    s2 = [v2 + &#x27;.X()&#x27;, v2 + &#x27;.Y()&#x27;];
                } else {
                    s2 = v2;
                }

                if (JXG.isArray(s1) &amp;&amp; JXG.isArray(s2)) {
                    return [s1[0] + &#x27; * &#x27; + s2[0], s1[1] + &#x27; * &#x27; + s2[1]];
                }

                if ((JXG.isNumber(s1) || JXG.isString(s1)) &amp;&amp; (JXG.isNumber(s2) || JXG.isString(s2))) {
                    return s1 + &#x27; * &#x27; + s2;
                }

                if ((JXG.isNumber(s1) || JXG.isString(s1)) &amp;&amp; JXG.isArray(s2)) {
                    return [s1 + &#x27; * &#x27; + s2[0], s1 + &#x27; * &#x27; + s2[1]];
                }

                if (JXG.isArray(s1) &amp;&amp; (JXG.isNumber(s2) || JXG.isString(s2))) {
                    return [s1[0] + &#x27; * &#x27; + s2, s1[1] + &#x27; * &#x27; + s2];
                }

                return s1 + &#x27; * &#x27; + s2;
            case &#x27;div&#x27;:
                if (JXG.isString(v1) &amp;&amp; !v1.match(regexValue) &amp;&amp; v1.match(regexSelect)) {
                    s1 = [v1 + &#x27;.X()&#x27;, v1 + &#x27;.Y()&#x27;];
                } else {
                    s1 = v1;
                }

                if (JXG.isString(v2) &amp;&amp; !v2.match(regexValue) &amp;&amp; v2.match(regexSelect)) {
                    s2 = [v2 + &#x27;.X()&#x27;, v2 + &#x27;.Y()&#x27;];
                } else {
                    s2 = v2;
                }

                if (JXG.isArray(s1) &amp;&amp; JXG.isArray(s2)) {
                    return [s1[0] + &#x27; / &#x27; + s2[0], s1[1] + &#x27; / &#x27; + s2[1]];
                }

                if ((JXG.isNumber(s1) || JXG.isString(s1)) &amp;&amp; (JXG.isNumber(s2) || JXG.isString(s2))) {
                    return s1 + &#x27; / &#x27; + s2;
                }

                if ((JXG.isNumber(s1) || JXG.isString(s1)) &amp;&amp; JXG.isArray(s2)) {
                    return [ s1 + &#x27; / &#x27; + s2[0], s1 + &#x27; / &#x27; + s2[1] ];
                }

                if (JXG.isArray(s1) &amp;&amp; (JXG.isNumber(s2) || JXG.isString(s2))) {
                    return [s1[0] + &#x27; / &#x27; + s2, s1[1] + &#x27; / &#x27; + s2 ];
                }

                return s1 + &#x27; / &#x27; + s2;
            case &#x27;negmult&#x27;:
                if (this.isGGBVector(v1)) {
                    return [1, -1 + &#x27;*&#x27; + v1[1], -1 + &#x27;*&#x27; + v1[2]];
                }

                return -1 + &#x27;*&#x27; + v1;
            case &#x27;bra&#x27;:
                if (this.isGGBVector(v1)) {
                    return [1, &#x27;(&#x27; + v1[1] + &#x27;)&#x27;, &#x27;(&#x27; + v1[2] + &#x27;)&#x27;];
                }

                return &#x27;(&#x27; + v1 + &#x27;)&#x27;;
            case &#x27;int&#x27;:
                return parseInt(v1, 10);
            case &#x27;float&#x27;:
                return parseFloat(v1);
            case &#x27;param&#x27;:
                return v1;
            case &#x27;html&#x27;:
                return v1;
            case &#x27;string&#x27;:
                if (v2) {
                    return [v1, v2];
                }

                return v1;
            case &#x27;command&#x27;:
                v2 = v1.split(&#x27;[&#x27;);
                s1 = v2[0];
                s2 = (v2[1].split(&#x27;]&#x27;))[0];
                if (s1.toLowerCase() === &#x27;name&#x27;) {
                    return &#x27;JXG.boards[\&#x27;&#x27; + this.board.id + &#x27;\&#x27;].select(\&#x27;&#x27; + s2 + &#x27;\&#x27;).getName()&#x27;;
                }
                break;
            case &#x27;var&#x27;:
                if (v2) {
                    switch (v1.toLowerCase()) {
                    case &#x27;x&#x27;:
                        return v2 + &#x27;.X()&#x27;;
                    case &#x27;y&#x27;:
                        return v2 + &#x27;.Y()&#x27;;
                    case &#x27;abs&#x27;:
                    case &#x27;acos&#x27;:
                    case &#x27;asin&#x27;:
                    case &#x27;atan&#x27;:
                    case &#x27;ceil&#x27;:
                    case &#x27;cos&#x27;:
                    case &#x27;exp&#x27;:
                    case &#x27;floor&#x27;:
                    case &#x27;log&#x27;:
                    case &#x27;max&#x27;:
                    case &#x27;min&#x27;:
                    case &#x27;pow&#x27;:
                    case &#x27;random&#x27;:
                    case &#x27;round&#x27;:
                    case &#x27;sin&#x27;:
                    case &#x27;sqrt&#x27;:
                    case &#x27;tan&#x27;:
                        return &#x27;Math.&#x27; + v1.toLowerCase() + &#x27;(&#x27; +  v2 + &#x27;)&#x27;;
                    default:
                        return v1.toLowerCase() + &#x27;*(&#x27; + v2 + &#x27;)&#x27;;
                    }
                } else {
                    if (v1 === &#x27;PI&#x27;) {
                        return &#x27;Math.PI&#x27;;
                    }

                    a = this.checkElement(v1);
                    if (JXG.exists(this.board.ggb[v1])) {
                        return &#x27;JXG.boards[\&#x27;&#x27; + this.board.id + &#x27;\&#x27;].ggb[&quot;&#x27; + v1 + &#x27;&quot;]()&#x27;;
                    }

                    if (JXG.exists(a.Value)) {
                        return &#x27;JXG.boards[\&#x27;&#x27; + this.board.id + &#x27;\&#x27;].select(&quot;&#x27; + v1 + &#x27;&quot;).Value()&#x27;;
                    }

                    if (JXG.exists(a.Area)) {
                        return &#x27;JXG.boards[\&#x27;&#x27; + this.board.id + &#x27;\&#x27;].select(&quot;&#x27; + v1 + &#x27;&quot;).Area()&#x27;;
                    }

                    if (JXG.exists(a.plaintextStr)) {
                        return &#x27;1.0*JXG.boards[\&#x27;&#x27; + this.board.id + &#x27;\&#x27;].select(&quot;&#x27; + v1 + &#x27;&quot;).plaintextStr&#x27;;
                    }

                    if (a.type === JXG.OBJECT_TYPE_VECTOR) {
                        return [1, &#x27;JXG.boards[\&#x27;&#x27; + this.board.id + &#x27;\&#x27;].select(&quot;&#x27; + v1 + &#x27;&quot;).point2.X()-JXG.boards[\&#x27;&#x27; + this.board.id + &#x27;\&#x27;].select(&quot;&#x27; + v1 + &#x27;&quot;).point1.X()&#x27;, &#x27;JXG.boards[\&#x27;&#x27; + this.board.id + &#x27;\&#x27;].select(&quot;&#x27; + v1 + &#x27;&quot;).point2.Y()-JXG.boards[\&#x27;&#x27; + this.board.id + &#x27;\&#x27;].select(&quot;&#x27; + v1 + &#x27;&quot;).point1.Y()&#x27;];
                    }

                    if (a.elementClass === JXG.OBJECT_CLASS_LINE) {
                        return &#x27;JXG.boards[\&#x27;&#x27; + this.board.id + &#x27;\&#x27;].select(&quot;&#x27; + v1 + &#x27;&quot;).point1.Dist(JXG.boards[\&#x27;&#x27; + this.board.id + &#x27;\&#x27;].select(&quot;&#x27; + v1 + &#x27;&quot;).point2)&#x27;;
                    }

                    return &#x27;JXG.boards[\&#x27;&#x27; + this.board.id + &#x27;\&#x27;].select(&quot;&#x27; + v1 + &#x27;&quot;)&#x27;;
                }
            }
        },

        /**
         * JS/CC parser to convert the input expression to a working javascript function.
         * @param {String} exp String which contains the function, expression or information
         * @param {Object} el Element that needs to be updated
         */
        ggbParse: function (exp, el) {
            var i, error_count,
                error_offsets = [],
                error_lookaheads = [],
                errstr = &#x27;&#x27;,
                str = exp,
                dbg_withtrace = false,
                dbg_string = &#x27;&#x27;,
                ggbr = this,
                element = el ? this.board.select(this.ggbElements[el].id) : false;

            if (element) {
                JXG.debug(&quot;Update element: &quot; + element.name + &quot;(&quot; + element.id + &quot;)&quot;);
            }

            /*
             This parser was generated with: The LALR(1) parser and lexical analyzer generator for JavaScript, written in JavaScript
             In the version 0.30 on http://jscc.jmksf.com/

             It is based on the default template driver for JS/CC generated parsers running as
             browser-based JavaScript/ECMAScript applications and was strongly modified.

             The parser was written 2007, 2008 by Jan Max Meyer, J.M.K S.F. Software Technologies
             This is in the public domain.
             */

            /***** begin replace *****/
            function dbg_print(text) {
                dbg_string += text + &#x27;\n&#x27;;
            }

            function lex(info) {
                var state = 0,
                    match = -1,
                    match_pos = 0,
                    start = 0,
                    pos = info.offset + 1;

                do {
                    pos -= 1;
                    state = 0;
                    match = -2;
                    start = pos;

                    if (info.src.length &lt;= start) {
                        return 28;
                    }

                    do {
                        switch (state) {
                        case 0:
                            if (info.src.charCodeAt(pos) === 9 || info.src.charCodeAt(pos) === 32) {
                                state = 1;
                            } else if (info.src.charCodeAt(pos) === 33) {
                                state = 2;
                            } else if (info.src.charCodeAt(pos) === 40) {
                                state = 3;
                            } else if (info.src.charCodeAt(pos) === 41) {
                                state = 4;
                            } else if (info.src.charCodeAt(pos) === 42) {
                                state = 5;
                            } else if (info.src.charCodeAt(pos) === 43) {
                                state = 6;
                            } else if (info.src.charCodeAt(pos) === 44) {
                                state = 7;
                            } else if (info.src.charCodeAt(pos) === 45) {
                                state = 8;
                            } else if (info.src.charCodeAt(pos) === 47) {
                                state = 9;
                            } else if ((info.src.charCodeAt(pos) &gt;= 48 &amp;&amp; info.src.charCodeAt(pos) &lt;= 57)) {
                                state = 10;
                            } else if (info.src.charCodeAt(pos) === 60) {
                                state = 11;
                            } else if (info.src.charCodeAt(pos) === 62) {
                                state = 12;
                            } else if ((info.src.charCodeAt(pos) &gt;= 65 &amp;&amp; info.src.charCodeAt(pos) &lt;= 90) || (info.src.charCodeAt(pos) &gt;= 97 &amp;&amp; info.src.charCodeAt(pos) &lt;= 122)) {
                                state = 13;
                            } else if (info.src.charCodeAt(pos) === 94) {
                                state = 14;
                            } else if (info.src.charCodeAt(pos) === 34) {
                                state = 26;
                            } else if (info.src.charCodeAt(pos) === 38) {
                                state = 28;
                            } else if (info.src.charCodeAt(pos) === 46) {
                                state = 29;
                            } else if (info.src.charCodeAt(pos) === 61) {
                                state = 30;
                            } else if (info.src.charCodeAt(pos) === 95) {
                                state = 31;
                            } else if (info.src.charCodeAt(pos) === 124) {
                                state = 32;
                            } else {
                                state = -1;
                            }
                            break;

                        case 1:
                            state = -1;
                            match = 1;
                            match_pos = pos;
                            break;

                        case 2:
                            if (info.src.charCodeAt(pos) === 61) {
                                state = 15;
                            } else {
                                state = -1;
                            }
                            match = 23;
                            match_pos = pos;
                            break;

                        case 3:
                            state = -1;
                            match = 2;
                            match_pos = pos;
                            break;

                        case 4:
                            state = -1;
                            match = 3;
                            match_pos = pos;
                            break;

                        case 5:
                            state = -1;
                            match = 13;
                            match_pos = pos;
                            break;

                        case 6:
                            state = -1;
                            match = 11;
                            match_pos = pos;
                            break;

                        case 7:
                            state = -1;
                            match = 16;
                            match_pos = pos;
                            break;

                        case 8:
                            state = -1;
                            match = 12;
                            match_pos = pos;
                            break;

                        case 9:
                            state = -1;
                            match = 14;
                            match_pos = pos;
                            break;

                        case 10:
                            if ((info.src.charCodeAt(pos) &gt;= 48 &amp;&amp; info.src.charCodeAt(pos) &lt;= 57)) {
                                state = 10;
                            } else if (info.src.charCodeAt(pos) === 46) {
                                state = 18;
                            } else {
                                state = -1;
                            }
                            match = 4;
                            match_pos = pos;
                            break;

                        case 11:
                            if (info.src.charCodeAt(pos) === 61) {
                                state = 19;
                            } else {
                                state = -1;
                            }
                            match = 21;
                            match_pos = pos;
                            break;

                        case 12:
                            if (info.src.charCodeAt(pos) === 61) {
                                state = 21;
                            } else {
                                state = -1;
                            }
                            match = 22;
                            match_pos = pos;
                            break;

                        case 13:
                            if ((info.src.charCodeAt(pos) &gt;= 65 &amp;&amp; info.src.charCodeAt(pos) &lt;= 90) || (info.src.charCodeAt(pos) &gt;= 97 &amp;&amp; info.src.charCodeAt(pos) &lt;= 122)) {
                                state = 13;
                            } else if ((info.src.charCodeAt(pos) &gt;= 48 &amp;&amp; info.src.charCodeAt(pos) &lt;= 57)) {
                                state = 27;
                            } else if (info.src.charCodeAt(pos) === 91) {
                                state = 34;
                            } else if (info.src.charCodeAt(pos) === 95) {
                                state = 35;
                            } else {
                                state = -1;
                            }
                            match = 7;
                            match_pos = pos;
                            break;

                        case 14:
                            state = -1;
                            match = 15;
                            match_pos = pos;
                            break;

                        case 15:
                            state = -1;
                            match = 20;
                            match_pos = pos;
                            break;

                        case 16:
                            state = -1;
                            match = 9;
                            match_pos = pos;
                            break;

                        case 17:
                            state = -1;
                            match = 25;
                            match_pos = pos;
                            break;

                        case 18:
                            if ((info.src.charCodeAt(pos) &gt;= 48 &amp;&amp; info.src.charCodeAt(pos) &lt;= 57)) {
                                state = 18;
                            } else {
                                state = -1;
                            }
                            match = 5;
                            match_pos = pos;
                            break;

                        case 19:
                            state = -1;
                            match = 17;
                            match_pos = pos;
                            break;

                        case 20:
                            state = -1;
                            match = 19;
                            match_pos = pos;
                            break;

                        case 21:
                            state = -1;
                            match = 18;
                            match_pos = pos;
                            break;

                        case 22:
                            state = -1;
                            match = 24;
                            match_pos = pos;
                            break;

                        case 23:
                            state = -1;
                            match = 8;
                            match_pos = pos;
                            break;

                        case 24:
                            if ((info.src.charCodeAt(pos) &gt;= 48 &amp;&amp; info.src.charCodeAt(pos) &lt;= 57) || (info.src.charCodeAt(pos) &gt;= 65 &amp;&amp; info.src.charCodeAt(pos) &lt;= 90) || (info.src.charCodeAt(pos) &gt;= 97 &amp;&amp; info.src.charCodeAt(pos) &lt;= 122)) {
                                state = 24;
                            } else {
                                state = -1;
                            }
                            match = 6;
                            match_pos = pos;
                            break;

                        case 25:
                            state = -1;
                            match = 10;
                            match_pos = pos;
                            break;

                        case 26:
                            if (info.src.charCodeAt(pos) === 34) {
                                state = 16;
                            } else if (info.src.charCodeAt(pos) === 32 || info.src.charCodeAt(pos) === 46 || (info.src.charCodeAt(pos) &gt;= 48 &amp;&amp; info.src.charCodeAt(pos) &lt;= 57) || info.src.charCodeAt(pos) === 61 || (info.src.charCodeAt(pos) &gt;= 65 &amp;&amp; info.src.charCodeAt(pos) &lt;= 90) || (info.src.charCodeAt(pos) &gt;= 97 &amp;&amp; info.src.charCodeAt(pos) &lt;= 122) || info.src.charCodeAt(pos) === 223 || info.src.charCodeAt(pos) === 228 || info.src.charCodeAt(pos) === 246 || info.src.charCodeAt(pos) === 252) {
                                state = 26;
                            } else {
                                state = -1;
                            }
                            break;

                        case 27:
                            if ((info.src.charCodeAt(pos) &gt;= 48 &amp;&amp; info.src.charCodeAt(pos) &lt;= 57) || (info.src.charCodeAt(pos) &gt;= 65 &amp;&amp; info.src.charCodeAt(pos) &lt;= 90) || (info.src.charCodeAt(pos) &gt;= 97 &amp;&amp; info.src.charCodeAt(pos) &lt;= 122)) {
                                state = 27;
                            } else if (info.src.charCodeAt(pos) === 95) {
                                state = 35;
                            } else {
                                state = -1;
                            }
                            match = 7;
                            match_pos = pos;
                            break;

                        case 28:
                            if (info.src.charCodeAt(pos) === 38) {
                                state = 17;
                            } else if ((info.src.charCodeAt(pos) &gt;= 65 &amp;&amp; info.src.charCodeAt(pos) &lt;= 90) || (info.src.charCodeAt(pos) &gt;= 97 &amp;&amp; info.src.charCodeAt(pos) &lt;= 122)) {
                                state = 33;
                            } else {
                                state = -1;
                            }
                            break;

                        case 29:
                            if ((info.src.charCodeAt(pos) &gt;= 48 &amp;&amp; info.src.charCodeAt(pos) &lt;= 57)) {
                                state = 18;
                            } else {
                                state = -1;
                            }
                            break;

                        case 30:
                            if (info.src.charCodeAt(pos) === 61) {
                                state = 20;
                            } else {
                                state = -1;
                            }
                            break;

                        case 31:
                            if (info.src.charCodeAt(pos) === 95) {
                                state = 36;
                            } else {
                                state = -1;
                            }
                            break;

                        case 32:
                            if (info.src.charCodeAt(pos) === 124) {
                                state = 22;
                            } else {
                                state = -1;
                            }
                            break;

                        case 33:
                            if (info.src.charCodeAt(pos) === 59) {
                                state = 23;
                            } else if ((info.src.charCodeAt(pos) &gt;= 65 &amp;&amp; info.src.charCodeAt(pos) &lt;= 90) || (info.src.charCodeAt(pos) &gt;= 97 &amp;&amp; info.src.charCodeAt(pos) &lt;= 122)) {
                                state = 33;
                            } else {
                                state = -1;
                            }
                            break;

                        case 34:
                            if ((info.src.charCodeAt(pos) &gt;= 65 &amp;&amp; info.src.charCodeAt(pos) &lt;= 90) || (info.src.charCodeAt(pos) &gt;= 97 &amp;&amp; info.src.charCodeAt(pos) &lt;= 122)) {
                                state = 37;
                            } else {
                                state = -1;
                            }
                            break;

                        case 35:
                            if ((info.src.charCodeAt(pos) &gt;= 48 &amp;&amp; info.src.charCodeAt(pos) &lt;= 57) || (info.src.charCodeAt(pos) &gt;= 65 &amp;&amp; info.src.charCodeAt(pos) &lt;= 90) || (info.src.charCodeAt(pos) &gt;= 97 &amp;&amp; info.src.charCodeAt(pos) &lt;= 122)) {
                                state = 27;
                            } else if (info.src.charCodeAt(pos) === 95) {
                                state = 35;
                            } else {
                                state = -1;
                            }
                            break;

                        case 36:
                            if ((info.src.charCodeAt(pos) &gt;= 48 &amp;&amp; info.src.charCodeAt(pos) &lt;= 57) || (info.src.charCodeAt(pos) &gt;= 65 &amp;&amp; info.src.charCodeAt(pos) &lt;= 90) || (info.src.charCodeAt(pos) &gt;= 97 &amp;&amp; info.src.charCodeAt(pos) &lt;= 122)) {
                                state = 24;
                            } else {
                                state = -1;
                            }
                            break;

                        case 37:
                            if (info.src.charCodeAt(pos) === 93) {
                                state = 25;
                            } else if ((info.src.charCodeAt(pos) &gt;= 65 &amp;&amp; info.src.charCodeAt(pos) &lt;= 90) || (info.src.charCodeAt(pos) &gt;= 97 &amp;&amp; info.src.charCodeAt(pos) &lt;= 122)) {
                                state = 37;
                            } else {
                                state = -1;
                            }
                            break;
                        }
                        pos += 1;

                    } while (state &gt; -1);
                } while (1 &gt; -1 &amp;&amp; match === 1);

                if (match &gt; -1) {
                    info.att = info.src.substr(start, match_pos - start);
                    info.offset = match_pos;


                } else {
                    info.att = &#x27;&#x27;;
                    match = -1;
                }

                return match;
            }


            function parse(src, err_off, err_la) {
                var i, act, go, la, rval, rvstack, rsstack, undef,
                    act_tab, pop_tab, goto_tab, labels,
                    sstack = [],
                    vstack = [],
                    err_cnt = 0,
                    info = {};

                // Pop-Table
                pop_tab = [
                    [/* p&#x27; */0, 1],
                    [/* p */27, 1],
                    [/* e */26, 5],
                    [/* e */26, 3],
                    [/* e */26, 3],
                    [/* e */26, 3],
                    [/* e */26, 3],
                    [/* e */26, 3],
                    [/* e */26, 3],
                    [/* e */26, 3],
                    [/* e */26, 3],
                    [/* e */26, 2],
                    [/* e */26, 3],
                    [/* e */26, 3],
                    [/* e */26, 3],
                    [/* e */26, 3],
                    [/* e */26, 3],
                    [/* e */26, 2],
                    [/* e */26, 3],
                    [/* e */26, 3],
                    [/* e */26, 1],
                    [/* e */26, 1],
                    [/* e */26, 1],
                    [/* e */26, 1],
                    [/* e */26, 1],
                    [/* e */26, 1],
                    [/* e */26, 4],
                    [/* e */26, 1]
                ];

                // Action-Table
                act_tab = [
                    /* State 0 */
                    [/* &quot;(&quot; */2, 3, /* &quot;!&quot; */23, 4, /* &quot;-&quot; */12, 5, /* &quot;STRING&quot; */9, 6, /* &quot;INT&quot; */4, 7, /* &quot;FLOAT&quot; */5, 8, /* &quot;PARAM&quot; */6, 9, /* &quot;HTML&quot; */8, 10, /* &quot;COMMAND&quot; */10, 11, /* &quot;VAR&quot; */7, 12],
                    /* State 1 */
                    [/* &quot;$$&quot; */28, 0],
                    /* State 2 */
                    [/* &quot;/&quot; */14, 13, /* &quot;*&quot; */13, 14, /* &quot;&amp;&amp;&quot; */25, 15, /* &quot;||&quot; */24, 16, /* &quot;^&quot; */15, 17, /* &quot;-&quot; */12, 18, /* &quot;+&quot; */11, 19, /* &quot;&gt;&quot; */22, 20, /* &quot;&lt;&quot; */21, 21, /* &quot;!=&quot; */20, 22, /* &quot;==&quot; */19, 23, /* &quot;&gt;=&quot; */18, 24, /* &quot;&lt;=&quot; */17, 25, /* &quot;$$&quot; */28, -1],
                    /* State 3 */
                    [/* &quot;(&quot; */2, 3, /* &quot;!&quot; */23, 4, /* &quot;-&quot; */12, 5, /* &quot;STRING&quot; */9, 6, /* &quot;INT&quot; */4, 7, /* &quot;FLOAT&quot; */5, 8, /* &quot;PARAM&quot; */6, 9, /* &quot;HTML&quot; */8, 10, /* &quot;COMMAND&quot; */10, 11, /* &quot;VAR&quot; */7, 12],
                    /* State 4 */
                    [/* &quot;(&quot; */2, 3, /* &quot;!&quot; */23, 4, /* &quot;-&quot; */12, 5, /* &quot;STRING&quot; */9, 6, /* &quot;INT&quot; */4, 7, /* &quot;FLOAT&quot; */5, 8, /* &quot;PARAM&quot; */6, 9, /* &quot;HTML&quot; */8, 10, /* &quot;COMMAND&quot; */10, 11, /* &quot;VAR&quot; */7, 12],
                    /* State 5 */
                    [/* &quot;(&quot; */2, 3, /* &quot;!&quot; */23, 4, /* &quot;-&quot; */12, 5, /* &quot;STRING&quot; */9, 6, /* &quot;INT&quot; */4, 7, /* &quot;FLOAT&quot; */5, 8, /* &quot;PARAM&quot; */6, 9, /* &quot;HTML&quot; */8, 10, /* &quot;COMMAND&quot; */10, 11, /* &quot;VAR&quot; */7, 12],
                    /* State 6 */
                    [/* &quot;+&quot; */11, 29, /* &quot;$$&quot; */28, -24, /* &quot;&lt;=&quot; */17, -24, /* &quot;&gt;=&quot; */18, -24, /* &quot;==&quot; */19, -24, /* &quot;!=&quot; */20, -24, /* &quot;&lt;&quot; */21, -24, /* &quot;&gt;&quot; */22, -24, /* &quot;-&quot; */12, -24, /* &quot;^&quot; */15, -24, /* &quot;||&quot; */24, -24, /* &quot;&amp;&amp;&quot; */25, -24, /* &quot;*&quot; */13, -24, /* &quot;/&quot; */14, -24, /* &quot;,&quot; */16, -24, /* &quot;)&quot; */3, -24],
                    /* State 7 */
                    [/* &quot;$$&quot; */28, -20, /* &quot;&lt;=&quot; */17, -20, /* &quot;&gt;=&quot; */18, -20, /* &quot;==&quot; */19, -20, /* &quot;!=&quot; */20, -20, /* &quot;&lt;&quot; */21, -20, /* &quot;&gt;&quot; */22, -20, /* &quot;+&quot; */11, -20, /* &quot;-&quot; */12, -20, /* &quot;^&quot; */15, -20, /* &quot;||&quot; */24, -20, /* &quot;&amp;&amp;&quot; */25, -20, /* &quot;*&quot; */13, -20, /* &quot;/&quot; */14, -20, /* &quot;,&quot; */16, -20, /* &quot;)&quot; */3, -20],
                    /* State 8 */
                    [/* &quot;$$&quot; */28, -21, /* &quot;&lt;=&quot; */17, -21, /* &quot;&gt;=&quot; */18, -21, /* &quot;==&quot; */19, -21, /* &quot;!=&quot; */20, -21, /* &quot;&lt;&quot; */21, -21, /* &quot;&gt;&quot; */22, -21, /* &quot;+&quot; */11, -21, /* &quot;-&quot; */12, -21, /* &quot;^&quot; */15, -21, /* &quot;||&quot; */24, -21, /* &quot;&amp;&amp;&quot; */25, -21, /* &quot;*&quot; */13, -21, /* &quot;/&quot; */14, -21, /* &quot;,&quot; */16, -21, /* &quot;)&quot; */3, -21],
                    /* State 9 */
                    [/* &quot;$$&quot; */28, -22, /* &quot;&lt;=&quot; */17, -22, /* &quot;&gt;=&quot; */18, -22, /* &quot;==&quot; */19, -22, /* &quot;!=&quot; */20, -22, /* &quot;&lt;&quot; */21, -22, /* &quot;&gt;&quot; */22, -22, /* &quot;+&quot; */11, -22, /* &quot;-&quot; */12, -22, /* &quot;^&quot; */15, -22, /* &quot;||&quot; */24, -22, /* &quot;&amp;&amp;&quot; */25, -22, /* &quot;*&quot; */13, -22, /* &quot;/&quot; */14, -22, /* &quot;,&quot; */16, -22, /* &quot;)&quot; */3, -22],
                    /* State 10 */
                    [/* &quot;$$&quot; */28, -23, /* &quot;&lt;=&quot; */17, -23, /* &quot;&gt;=&quot; */18, -23, /* &quot;==&quot; */19, -23, /* &quot;!=&quot; */20, -23, /* &quot;&lt;&quot; */21, -23, /* &quot;&gt;&quot; */22, -23, /* &quot;+&quot; */11, -23, /* &quot;-&quot; */12, -23, /* &quot;^&quot; */15, -23, /* &quot;||&quot; */24, -23, /* &quot;&amp;&amp;&quot; */25, -23, /* &quot;*&quot; */13, -23, /* &quot;/&quot; */14, -23, /* &quot;,&quot; */16, -23, /* &quot;)&quot; */3, -23],
                    /* State 11 */
                    [/* &quot;$$&quot; */28, -25, /* &quot;&lt;=&quot; */17, -25, /* &quot;&gt;=&quot; */18, -25, /* &quot;==&quot; */19, -25, /* &quot;!=&quot; */20, -25, /* &quot;&lt;&quot; */21, -25, /* &quot;&gt;&quot; */22, -25, /* &quot;+&quot; */11, -25, /* &quot;-&quot; */12, -25, /* &quot;^&quot; */15, -25, /* &quot;||&quot; */24, -25, /* &quot;&amp;&amp;&quot; */25, -25, /* &quot;*&quot; */13, -25, /* &quot;/&quot; */14, -25, /* &quot;,&quot; */16, -25, /* &quot;)&quot; */3, -25],
                    /* State 12 */
                    [/* &quot;(&quot; */2, 30, /* &quot;$$&quot; */28, -27, /* &quot;&lt;=&quot; */17, -27, /* &quot;&gt;=&quot; */18, -27, /* &quot;==&quot; */19, -27, /* &quot;!=&quot; */20, -27, /* &quot;&lt;&quot; */21, -27, /* &quot;&gt;&quot; */22, -27, /* &quot;+&quot; */11, -27, /* &quot;-&quot; */12, -27, /* &quot;^&quot; */15, -27, /* &quot;||&quot; */24, -27, /* &quot;&amp;&amp;&quot; */25, -27, /* &quot;*&quot; */13, -27, /* &quot;/&quot; */14, -27, /* &quot;,&quot; */16, -27, /* &quot;)&quot; */3, -27],
                    /* State 13 */
                    [/* &quot;(&quot; */2, 3, /* &quot;!&quot; */23, 4, /* &quot;-&quot; */12, 5, /* &quot;STRING&quot; */9, 6, /* &quot;INT&quot; */4, 7, /* &quot;FLOAT&quot; */5, 8, /* &quot;PARAM&quot; */6, 9, /* &quot;HTML&quot; */8, 10, /* &quot;COMMAND&quot; */10, 11, /* &quot;VAR&quot; */7, 12],
                    /* State 14 */
                    [/* &quot;(&quot; */2, 3, /* &quot;!&quot; */23, 4, /* &quot;-&quot; */12, 5, /* &quot;STRING&quot; */9, 6, /* &quot;INT&quot; */4, 7, /* &quot;FLOAT&quot; */5, 8, /* &quot;PARAM&quot; */6, 9, /* &quot;HTML&quot; */8, 10, /* &quot;COMMAND&quot; */10, 11, /* &quot;VAR&quot; */7, 12],
                    /* State 15 */
                    [/* &quot;(&quot; */2, 3, /* &quot;!&quot; */23, 4, /* &quot;-&quot; */12, 5, /* &quot;STRING&quot; */9, 6, /* &quot;INT&quot; */4, 7, /* &quot;FLOAT&quot; */5, 8, /* &quot;PARAM&quot; */6, 9, /* &quot;HTML&quot; */8, 10, /* &quot;COMMAND&quot; */10, 11, /* &quot;VAR&quot; */7, 12],
                    /* State 16 */
                    [/* &quot;(&quot; */2, 3, /* &quot;!&quot; */23, 4, /* &quot;-&quot; */12, 5, /* &quot;STRING&quot; */9, 6, /* &quot;INT&quot; */4, 7, /* &quot;FLOAT&quot; */5, 8, /* &quot;PARAM&quot; */6, 9, /* &quot;HTML&quot; */8, 10, /* &quot;COMMAND&quot; */10, 11, /* &quot;VAR&quot; */7, 12],
                    /* State 17 */
                    [/* &quot;(&quot; */2, 3, /* &quot;!&quot; */23, 4, /* &quot;-&quot; */12, 5, /* &quot;STRING&quot; */9, 6, /* &quot;INT&quot; */4, 7, /* &quot;FLOAT&quot; */5, 8, /* &quot;PARAM&quot; */6, 9, /* &quot;HTML&quot; */8, 10, /* &quot;COMMAND&quot; */10, 11, /* &quot;VAR&quot; */7, 12],
                    /* State 18 */
                    [/* &quot;(&quot; */2, 3, /* &quot;!&quot; */23, 4, /* &quot;-&quot; */12, 5, /* &quot;STRING&quot; */9, 6, /* &quot;INT&quot; */4, 7, /* &quot;FLOAT&quot; */5, 8, /* &quot;PARAM&quot; */6, 9, /* &quot;HTML&quot; */8, 10, /* &quot;COMMAND&quot; */10, 11, /* &quot;VAR&quot; */7, 12],
                    /* State 19 */
                    [/* &quot;(&quot; */2, 3, /* &quot;!&quot; */23, 4, /* &quot;-&quot; */12, 5, /* &quot;STRING&quot; */9, 6, /* &quot;INT&quot; */4, 7, /* &quot;FLOAT&quot; */5, 8, /* &quot;PARAM&quot; */6, 9, /* &quot;HTML&quot; */8, 10, /* &quot;COMMAND&quot; */10, 11, /* &quot;VAR&quot; */7, 12],
                    /* State 20 */
                    [/* &quot;(&quot; */2, 3, /* &quot;!&quot; */23, 4, /* &quot;-&quot; */12, 5, /* &quot;STRING&quot; */9, 6, /* &quot;INT&quot; */4, 7, /* &quot;FLOAT&quot; */5, 8, /* &quot;PARAM&quot; */6, 9, /* &quot;HTML&quot; */8, 10, /* &quot;COMMAND&quot; */10, 11, /* &quot;VAR&quot; */7, 12],
                    /* State 21 */
                    [/* &quot;(&quot; */2, 3, /* &quot;!&quot; */23, 4, /* &quot;-&quot; */12, 5, /* &quot;STRING&quot; */9, 6, /* &quot;INT&quot; */4, 7, /* &quot;FLOAT&quot; */5, 8, /* &quot;PARAM&quot; */6, 9, /* &quot;HTML&quot; */8, 10, /* &quot;COMMAND&quot; */10, 11, /* &quot;VAR&quot; */7, 12],
                    /* State 22 */
                    [/* &quot;(&quot; */2, 3, /* &quot;!&quot; */23, 4, /* &quot;-&quot; */12, 5, /* &quot;STRING&quot; */9, 6, /* &quot;INT&quot; */4, 7, /* &quot;FLOAT&quot; */5, 8, /* &quot;PARAM&quot; */6, 9, /* &quot;HTML&quot; */8, 10, /* &quot;COMMAND&quot; */10, 11, /* &quot;VAR&quot; */7, 12],
                    /* State 23 */
                    [/* &quot;(&quot; */2, 3, /* &quot;!&quot; */23, 4, /* &quot;-&quot; */12, 5, /* &quot;STRING&quot; */9, 6, /* &quot;INT&quot; */4, 7, /* &quot;FLOAT&quot; */5, 8, /* &quot;PARAM&quot; */6, 9, /* &quot;HTML&quot; */8, 10, /* &quot;COMMAND&quot; */10, 11, /* &quot;VAR&quot; */7, 12],
                    /* State 24 */
                    [/* &quot;(&quot; */2, 3, /* &quot;!&quot; */23, 4, /* &quot;-&quot; */12, 5, /* &quot;STRING&quot; */9, 6, /* &quot;INT&quot; */4, 7, /* &quot;FLOAT&quot; */5, 8, /* &quot;PARAM&quot; */6, 9, /* &quot;HTML&quot; */8, 10, /* &quot;COMMAND&quot; */10, 11, /* &quot;VAR&quot; */7, 12],
                    /* State 25 */
                    [/* &quot;(&quot; */2, 3, /* &quot;!&quot; */23, 4, /* &quot;-&quot; */12, 5, /* &quot;STRING&quot; */9, 6, /* &quot;INT&quot; */4, 7, /* &quot;FLOAT&quot; */5, 8, /* &quot;PARAM&quot; */6, 9, /* &quot;HTML&quot; */8, 10, /* &quot;COMMAND&quot; */10, 11, /* &quot;VAR&quot; */7, 12],
                    /* State 26 */
                    [/* &quot;/&quot; */14, 13, /* &quot;*&quot; */13, 14, /* &quot;&amp;&amp;&quot; */25, 15, /* &quot;||&quot; */24, 16, /* &quot;^&quot; */15, 17, /* &quot;-&quot; */12, 18, /* &quot;+&quot; */11, 19, /* &quot;&gt;&quot; */22, 20, /* &quot;&lt;&quot; */21, 21, /* &quot;!=&quot; */20, 22, /* &quot;==&quot; */19, 23, /* &quot;&gt;=&quot; */18, 24, /* &quot;&lt;=&quot; */17, 25, /* &quot;,&quot; */16, 44, /* &quot;)&quot; */3, 45],
                    /* State 27 */
                    [/* &quot;/&quot; */14, -11, /* &quot;*&quot; */13, -11, /* &quot;&amp;&amp;&quot; */25, 15, /* &quot;||&quot; */24, 16, /* &quot;^&quot; */15, -11, /* &quot;-&quot; */12, -11, /* &quot;+&quot; */11, -11, /* &quot;&gt;&quot; */22, -11, /* &quot;&lt;&quot; */21, -11, /* &quot;!=&quot; */20, -11, /* &quot;==&quot; */19, -11, /* &quot;&gt;=&quot; */18, -11, /* &quot;&lt;=&quot; */17, -11, /* &quot;$$&quot; */28, -11, /* &quot;,&quot; */16, -11, /* &quot;)&quot; */3, -11],
                    /* State 28 */
                    [/* &quot;/&quot; */14, -17, /* &quot;*&quot; */13, -17, /* &quot;&amp;&amp;&quot; */25, 15, /* &quot;||&quot; */24, 16, /* &quot;^&quot; */15, 17, /* &quot;-&quot; */12, -17, /* &quot;+&quot; */11, -17, /* &quot;&gt;&quot; */22, 20, /* &quot;&lt;&quot; */21, 21, /* &quot;!=&quot; */20, 22, /* &quot;==&quot; */19, 23, /* &quot;&gt;=&quot; */18, 24, /* &quot;&lt;=&quot; */17, 25, /* &quot;$$&quot; */28, -17, /* &quot;,&quot; */16, -17, /* &quot;)&quot; */3, -17],
                    /* State 29 */
                    [/* &quot;(&quot; */2, 3, /* &quot;!&quot; */23, 4, /* &quot;-&quot; */12, 5, /* &quot;STRING&quot; */9, 6, /* &quot;INT&quot; */4, 7, /* &quot;FLOAT&quot; */5, 8, /* &quot;PARAM&quot; */6, 9, /* &quot;HTML&quot; */8, 10, /* &quot;COMMAND&quot; */10, 11, /* &quot;VAR&quot; */7, 12],
                    /* State 30 */
                    [/* &quot;(&quot; */2, 3, /* &quot;!&quot; */23, 4, /* &quot;-&quot; */12, 5, /* &quot;STRING&quot; */9, 6, /* &quot;INT&quot; */4, 7, /* &quot;FLOAT&quot; */5, 8, /* &quot;PARAM&quot; */6, 9, /* &quot;HTML&quot; */8, 10, /* &quot;COMMAND&quot; */10, 11, /* &quot;VAR&quot; */7, 12],
                    /* State 31 */
                    [/* &quot;/&quot; */14, -16, /* &quot;*&quot; */13, -16, /* &quot;&amp;&amp;&quot; */25, 15, /* &quot;||&quot; */24, 16, /* &quot;^&quot; */15, 17, /* &quot;-&quot; */12, -16, /* &quot;+&quot; */11, -16, /* &quot;&gt;&quot; */22, 20, /* &quot;&lt;&quot; */21, 21, /* &quot;!=&quot; */20, 22, /* &quot;==&quot; */19, 23, /* &quot;&gt;=&quot; */18, 24, /* &quot;&lt;=&quot; */17, 25, /* &quot;$$&quot; */28, -16, /* &quot;,&quot; */16, -16, /* &quot;)&quot; */3, -16],
                    /* State 32 */
                    [/* &quot;/&quot; */14, -15, /* &quot;*&quot; */13, -15, /* &quot;&amp;&amp;&quot; */25, 15, /* &quot;||&quot; */24, 16, /* &quot;^&quot; */15, 17, /* &quot;-&quot; */12, -15, /* &quot;+&quot; */11, -15, /* &quot;&gt;&quot; */22, 20, /* &quot;&lt;&quot; */21, 21, /* &quot;!=&quot; */20, 22, /* &quot;==&quot; */19, 23, /* &quot;&gt;=&quot; */18, 24, /* &quot;&lt;=&quot; */17, 25, /* &quot;$$&quot; */28, -15, /* &quot;,&quot; */16, -15, /* &quot;)&quot; */3, -15],
                    /* State 33 */
                    [/* &quot;/&quot; */14, -14, /* &quot;*&quot; */13, -14, /* &quot;&amp;&amp;&quot; */25, -14, /* &quot;||&quot; */24, -14, /* &quot;^&quot; */15, -14, /* &quot;-&quot; */12, -14, /* &quot;+&quot; */11, -14, /* &quot;&gt;&quot; */22, -14, /* &quot;&lt;&quot; */21, -14, /* &quot;!=&quot; */20, -14, /* &quot;==&quot; */19, -14, /* &quot;&gt;=&quot; */18, -14, /* &quot;&lt;=&quot; */17, -14, /* &quot;$$&quot; */28, -14, /* &quot;,&quot; */16, -14, /* &quot;)&quot; */3, -14],
                    /* State 34 */
                    [/* &quot;/&quot; */14, -13, /* &quot;*&quot; */13, -13, /* &quot;&amp;&amp;&quot; */25, -13, /* &quot;||&quot; */24, -13, /* &quot;^&quot; */15, -13, /* &quot;-&quot; */12, -13, /* &quot;+&quot; */11, -13, /* &quot;&gt;&quot; */22, -13, /* &quot;&lt;&quot; */21, -13, /* &quot;!=&quot; */20, -13, /* &quot;==&quot; */19, -13, /* &quot;&gt;=&quot; */18, -13, /* &quot;&lt;=&quot; */17, -13, /* &quot;$$&quot; */28, -13, /* &quot;,&quot; */16, -13, /* &quot;)&quot; */3, -13],
                    /* State 35 */
                    [/* &quot;/&quot; */14, -12, /* &quot;*&quot; */13, -12, /* &quot;&amp;&amp;&quot; */25, 15, /* &quot;||&quot; */24, 16, /* &quot;^&quot; */15, -12, /* &quot;-&quot; */12, -12, /* &quot;+&quot; */11, -12, /* &quot;&gt;&quot; */22, 20, /* &quot;&lt;&quot; */21, 21, /* &quot;!=&quot; */20, 22, /* &quot;==&quot; */19, 23, /* &quot;&gt;=&quot; */18, 24, /* &quot;&lt;=&quot; */17, 25, /* &quot;$$&quot; */28, -12, /* &quot;,&quot; */16, -12, /* &quot;)&quot; */3, -12],
                    /* State 36 */
                    [/* &quot;/&quot; */14, 13, /* &quot;*&quot; */13, 14, /* &quot;&amp;&amp;&quot; */25, 15, /* &quot;||&quot; */24, 16, /* &quot;^&quot; */15, 17, /* &quot;-&quot; */12, -10, /* &quot;+&quot; */11, -10, /* &quot;&gt;&quot; */22, 20, /* &quot;&lt;&quot; */21, 21, /* &quot;!=&quot; */20, 22, /* &quot;==&quot; */19, 23, /* &quot;&gt;=&quot; */18, 24, /* &quot;&lt;=&quot; */17, 25, /* &quot;$$&quot; */28, -10, /* &quot;,&quot; */16, -10, /* &quot;)&quot; */3, -10],
                    /* State 37 */
                    [/* &quot;/&quot; */14, 13, /* &quot;*&quot; */13, 14, /* &quot;&amp;&amp;&quot; */25, 15, /* &quot;||&quot; */24, 16, /* &quot;^&quot; */15, 17, /* &quot;-&quot; */12, -9, /* &quot;+&quot; */11, -9, /* &quot;&gt;&quot; */22, 20, /* &quot;&lt;&quot; */21, 21, /* &quot;!=&quot; */20, 22, /* &quot;==&quot; */19, 23, /* &quot;&gt;=&quot; */18, 24, /* &quot;&lt;=&quot; */17, 25, /* &quot;$$&quot; */28, -9, /* &quot;,&quot; */16, -9, /* &quot;)&quot; */3, -9],
                    /* State 38 */
                    [/* &quot;/&quot; */14, -8, /* &quot;*&quot; */13, -8, /* &quot;&amp;&amp;&quot; */25, 15, /* &quot;||&quot; */24, 16, /* &quot;^&quot; */15, -8, /* &quot;-&quot; */12, -8, /* &quot;+&quot; */11, -8, /* &quot;&gt;&quot; */22, -8, /* &quot;&lt;&quot; */21, -8, /* &quot;!=&quot; */20, -8, /* &quot;==&quot; */19, -8, /* &quot;&gt;=&quot; */18, -8, /* &quot;&lt;=&quot; */17, -8, /* &quot;$$&quot; */28, -8, /* &quot;,&quot; */16, -8, /* &quot;)&quot; */3, -8],
                    /* State 39 */
                    [/* &quot;/&quot; */14, -7, /* &quot;*&quot; */13, -7, /* &quot;&amp;&amp;&quot; */25, 15, /* &quot;||&quot; */24, 16, /* &quot;^&quot; */15, -7, /* &quot;-&quot; */12, -7, /* &quot;+&quot; */11, -7, /* &quot;&gt;&quot; */22, -7, /* &quot;&lt;&quot; */21, -7, /* &quot;!=&quot; */20, -7, /* &quot;==&quot; */19, -7, /* &quot;&gt;=&quot; */18, -7, /* &quot;&lt;=&quot; */17, -7, /* &quot;$$&quot; */28, -7, /* &quot;,&quot; */16, -7, /* &quot;)&quot; */3, -7],
                    /* State 40 */
                    [/* &quot;/&quot; */14, -6, /* &quot;*&quot; */13, -6, /* &quot;&amp;&amp;&quot; */25, 15, /* &quot;||&quot; */24, 16, /* &quot;^&quot; */15, -6, /* &quot;-&quot; */12, -6, /* &quot;+&quot; */11, -6, /* &quot;&gt;&quot; */22, -6, /* &quot;&lt;&quot; */21, -6, /* &quot;!=&quot; */20, -6, /* &quot;==&quot; */19, -6, /* &quot;&gt;=&quot; */18, -6, /* &quot;&lt;=&quot; */17, -6, /* &quot;$$&quot; */28, -6, /* &quot;,&quot; */16, -6, /* &quot;)&quot; */3, -6],
                    /* State 41 */
                    [/* &quot;/&quot; */14, -5, /* &quot;*&quot; */13, -5, /* &quot;&amp;&amp;&quot; */25, 15, /* &quot;||&quot; */24, 16, /* &quot;^&quot; */15, -5, /* &quot;-&quot; */12, -5, /* &quot;+&quot; */11, -5, /* &quot;&gt;&quot; */22, -5, /* &quot;&lt;&quot; */21, -5, /* &quot;!=&quot; */20, -5, /* &quot;==&quot; */19, -5, /* &quot;&gt;=&quot; */18, -5, /* &quot;&lt;=&quot; */17, -5, /* &quot;$$&quot; */28, -5, /* &quot;,&quot; */16, -5, /* &quot;)&quot; */3, -5],
                    /* State 42 */
                    [/* &quot;/&quot; */14, -4, /* &quot;*&quot; */13, -4, /* &quot;&amp;&amp;&quot; */25, 15, /* &quot;||&quot; */24, 16, /* &quot;^&quot; */15, -4, /* &quot;-&quot; */12, -4, /* &quot;+&quot; */11, -4, /* &quot;&gt;&quot; */22, -4, /* &quot;&lt;&quot; */21, -4, /* &quot;!=&quot; */20, -4, /* &quot;==&quot; */19, -4, /* &quot;&gt;=&quot; */18, -4, /* &quot;&lt;=&quot; */17, -4, /* &quot;$$&quot; */28, -4, /* &quot;,&quot; */16, -4, /* &quot;)&quot; */3, -4],
                    /* State 43 */
                    [/* &quot;/&quot; */14, -3, /* &quot;*&quot; */13, -3, /* &quot;&amp;&amp;&quot; */25, 15, /* &quot;||&quot; */24, 16, /* &quot;^&quot; */15, -3, /* &quot;-&quot; */12, -3, /* &quot;+&quot; */11, -3, /* &quot;&gt;&quot; */22, -3, /* &quot;&lt;&quot; */21, -3, /* &quot;!=&quot; */20, -3, /* &quot;==&quot; */19, -3, /* &quot;&gt;=&quot; */18, -3, /* &quot;&lt;=&quot; */17, -3, /* &quot;$$&quot; */28, -3, /* &quot;,&quot; */16, -3, /* &quot;)&quot; */3, -3],
                    /* State 44 */
                    [/* &quot;(&quot; */2, 3, /* &quot;!&quot; */23, 4, /* &quot;-&quot; */12, 5, /* &quot;STRING&quot; */9, 6, /* &quot;INT&quot; */4, 7, /* &quot;FLOAT&quot; */5, 8, /* &quot;PARAM&quot; */6, 9, /* &quot;HTML&quot; */8, 10, /* &quot;COMMAND&quot; */10, 11, /* &quot;VAR&quot; */7, 12],
                    /* State 45 */
                    [/* &quot;$$&quot; */28, -18, /* &quot;&lt;=&quot; */17, -18, /* &quot;&gt;=&quot; */18, -18, /* &quot;==&quot; */19, -18, /* &quot;!=&quot; */20, -18, /* &quot;&lt;&quot; */21, -18, /* &quot;&gt;&quot; */22, -18, /* &quot;+&quot; */11, -18, /* &quot;-&quot; */12, -18, /* &quot;^&quot; */15, -18, /* &quot;||&quot; */24, -18, /* &quot;&amp;&amp;&quot; */25, -18, /* &quot;*&quot; */13, -18, /* &quot;/&quot; */14, -18, /* &quot;,&quot; */16, -18, /* &quot;)&quot; */3, -18],
                    /* State 46 */
                    [/* &quot;/&quot; */14, 13, /* &quot;*&quot; */13, 14, /* &quot;&amp;&amp;&quot; */25, 15, /* &quot;||&quot; */24, 16, /* &quot;^&quot; */15, 17, /* &quot;-&quot; */12, -19, /* &quot;+&quot; */11, -19, /* &quot;&gt;&quot; */22, 20, /* &quot;&lt;&quot; */21, 21, /* &quot;!=&quot; */20, 22, /* &quot;==&quot; */19, 23, /* &quot;&gt;=&quot; */18, 24, /* &quot;&lt;=&quot; */17, 25, /* &quot;$$&quot; */28, -19, /* &quot;,&quot; */16, -19, /* &quot;)&quot; */3, -19],
                    /* State 47 */
                    [/* &quot;/&quot; */14, 13, /* &quot;*&quot; */13, 14, /* &quot;&amp;&amp;&quot; */25, 15, /* &quot;||&quot; */24, 16, /* &quot;^&quot; */15, 17, /* &quot;-&quot; */12, 18, /* &quot;+&quot; */11, 19, /* &quot;&gt;&quot; */22, 20, /* &quot;&lt;&quot; */21, 21, /* &quot;!=&quot; */20, 22, /* &quot;==&quot; */19, 23, /* &quot;&gt;=&quot; */18, 24, /* &quot;&lt;=&quot; */17, 25, /* &quot;)&quot; */3, 49],
                    /* State 48 */
                    [/* &quot;/&quot; */14, 13, /* &quot;*&quot; */13, 14, /* &quot;&amp;&amp;&quot; */25, 15, /* &quot;||&quot; */24, 16, /* &quot;^&quot; */15, 17, /* &quot;-&quot; */12, 18, /* &quot;+&quot; */11, 19, /* &quot;&gt;&quot; */22, 20, /* &quot;&lt;&quot; */21, 21, /* &quot;!=&quot; */20, 22, /* &quot;==&quot; */19, 23, /* &quot;&gt;=&quot; */18, 24, /* &quot;&lt;=&quot; */17, 25, /* &quot;)&quot; */3, 50],
                    /* State 49 */
                    [/* &quot;$$&quot; */28, -26, /* &quot;&lt;=&quot; */17, -26, /* &quot;&gt;=&quot; */18, -26, /* &quot;==&quot; */19, -26, /* &quot;!=&quot; */20, -26, /* &quot;&lt;&quot; */21, -26, /* &quot;&gt;&quot; */22, -26, /* &quot;+&quot; */11, -26, /* &quot;-&quot; */12, -26, /* &quot;^&quot; */15, -26, /* &quot;||&quot; */24, -26, /* &quot;&amp;&amp;&quot; */25, -26, /* &quot;*&quot; */13, -26, /* &quot;/&quot; */14, -26, /* &quot;,&quot; */16, -26, /* &quot;)&quot; */3, -26],
                    /* State 50 */
                    [/* &quot;$$&quot; */28, -2, /* &quot;&lt;=&quot; */17, -2, /* &quot;&gt;=&quot; */18, -2, /* &quot;==&quot; */19, -2, /* &quot;!=&quot; */20, -2, /* &quot;&lt;&quot; */21, -2, /* &quot;&gt;&quot; */22, -2, /* &quot;+&quot; */11, -2, /* &quot;-&quot; */12, -2, /* &quot;^&quot; */15, -2, /* &quot;||&quot; */24, -2, /* &quot;&amp;&amp;&quot; */25, -2, /* &quot;*&quot; */13, -2, /* &quot;/&quot; */14, -2, /* &quot;,&quot; */16, -2, /* &quot;)&quot; */3, -2]
                ];

                // Goto-Table
                goto_tab = [
                    /* State 0 */
                    [/* p */27, 1, /* e */26, 2],
                    /* State 1 */
                    [],
                    /* State 2 */
                    [],
                    /* State 3 */
                    [/* e */26, 26],
                    /* State 4 */
                    [/* e */26, 27],
                    /* State 5 */
                    [/* e */26, 28],
                    /* State 6 */
                    [],
                    /* State 7 */
                    [],
                    /* State 8 */
                    [],
                    /* State 9 */
                    [],
                    /* State 10 */
                    [],
                    /* State 11 */
                    [],
                    /* State 12 */
                    [],
                    /* State 13 */
                    [/* e */26, 31],
                    /* State 14 */
                    [/* e */26, 32],
                    /* State 15 */
                    [/* e */26, 33],
                    /* State 16 */
                    [/* e */26, 34],
                    /* State 17 */
                    [/* e */26, 35],
                    /* State 18 */
                    [/* e */26, 36],
                    /* State 19 */
                    [/* e */26, 37],
                    /* State 20 */
                    [/* e */26, 38],
                    /* State 21 */
                    [/* e */26, 39],
                    /* State 22 */
                    [/* e */26, 40],
                    /* State 23 */
                    [/* e */26, 41],
                    /* State 24 */
                    [/* e */26, 42],
                    /* State 25 */
                    [/* e */26, 43],
                    /* State 26 */
                    [],
                    /* State 27 */
                    [],
                    /* State 28 */
                    [],
                    /* State 29 */
                    [/* e */26, 46],
                    /* State 30 */
                    [/* e */26, 47],
                    /* State 31 */
                    [],
                    /* State 32 */
                    [],
                    /* State 33 */
                    [],
                    /* State 34 */
                    [],
                    /* State 35 */
                    [],
                    /* State 36 */
                    [],
                    /* State 37 */
                    [],
                    /* State 38 */
                    [],
                    /* State 39 */
                    [],
                    /* State 40 */
                    [],
                    /* State 41 */
                    [],
                    /* State 42 */
                    [],
                    /* State 43 */
                    [],
                    /* State 44 */
                    [/* e */26, 48],
                    /* State 45 */
                    [],
                    /* State 46 */
                    [],
                    /* State 47 */
                    [],
                    /* State 48 */
                    [],
                    /* State 49 */
                    [],
                    /* State 50 */
                    []
                ];



                // Symbol labels
                labels = [
                    /* Non-terminal symbol */
                    &quot;p&#x27;&quot;,
                    /* Terminal symbol */
                    &quot;WHITESPACE&quot;,
                    /* Terminal symbol */
                    &quot;(&quot;,
                    /* Terminal symbol */
                    &quot;)&quot;,
                    /* Terminal symbol */
                    &quot;INT&quot;,
                    /* Terminal symbol */
                    &quot;FLOAT&quot;,
                    /* Terminal symbol */
                    &quot;PARAM&quot;,
                    /* Terminal symbol */
                    &quot;VAR&quot;,
                    /* Terminal symbol */
                    &quot;HTML&quot;,
                    /* Terminal symbol */
                    &quot;STRING&quot;,
                    /* Terminal symbol */
                    &quot;COMMAND&quot;,
                    /* Terminal symbol */
                    &quot;+&quot;,
                    /* Terminal symbol */
                    &quot;-&quot;,
                    /* Terminal symbol */
                    &quot;*&quot;,
                    /* Terminal symbol */
                    &quot;/&quot;,
                    /* Terminal symbol */
                    &quot;^&quot;,
                    /* Terminal symbol */
                    &quot;,&quot;,
                    /* Terminal symbol */
                    &quot;&lt;=&quot;,
                    /* Terminal symbol */
                    &quot;&gt;=&quot;,
                    /* Terminal symbol */
                    &quot;==&quot;,
                    /* Terminal symbol */
                    &quot;!=&quot;,
                    /* Terminal symbol */
                    &quot;&lt;&quot;,
                    /* Terminal symbol */
                    &quot;&gt;&quot;,
                    /* Terminal symbol */
                    &quot;!&quot;,
                    /* Terminal symbol */
                    &quot;||&quot;,
                    /* Terminal symbol */
                    &quot;&amp;&amp;&quot;,
                    /* Non-terminal symbol */
                    &quot;e&quot;,
                    /* Non-terminal symbol */
                    &quot;p&quot;,
                    /* Terminal symbol */
                    &quot;$$&quot;
                ];



                info.offset = 0;
                info.src = src;
                info.att = &#x27;&#x27;;

                if (!err_off) {
                    err_off = [];
                }

                if (!err_la) {
                    err_la = [];
                }

                sstack.push(0);
                vstack.push(0);

                la = lex(info);

                while (true) {
                    act = 52;

                    for (i = 0; i &lt; act_tab[sstack[sstack.length - 1]].length; i += 2) {
                        if (act_tab[sstack[sstack.length - 1]][i] === la) {
                            act = act_tab[sstack[sstack.length - 1]][i + 1];
                            break;
                        }
                    }

                    if (dbg_withtrace &amp;&amp; sstack.length &gt; 0) {
                        dbg_print(&#x27;\nState &#x27; + sstack[sstack.length - 1] + &#x27;\n&#x27; +
                            &#x27;\tLookahead: &#x27; + labels[la] + &#x27; (\&#x27;&#x27; + info.att + &#x27;\&#x27;)\n&#x27; +
                            &#x27;\tAction: &#x27; + act + &#x27;\n&#x27; +
                            &#x27;\tSource: \&#x27;&#x27; + info.src.substr(info.offset, 30) +
                            ((info.offset + 30 &lt; info.src.length) ? &#x27;...&#x27; : &#x27;&#x27;) +
                            &#x27;\&#x27;\n&#x27; + &#x27;\tStack: &#x27; + sstack.join() + &#x27;\n&#x27; +
                            &#x27;\tValue stack: &#x27; + vstack.join() + &#x27;\n&#x27;);
                    }

                    //Panic-mode: Try recovery when parse-error occurs!
                    if (act === 52) {
                        if (dbg_withtrace) {
                            dbg_print(&#x27;Error detected: There is no reduce or shift on the symbol &#x27; + labels[la]);
                        }

                        err_cnt += 1;
                        err_off.push(info.offset - info.att.length);
                        err_la.push([]);
                        for (i = 0; i &lt; act_tab[sstack[sstack.length - 1]].length; i += 2) {
                            err_la[err_la.length - 1].push(labels[act_tab[sstack[sstack.length - 1]][i]]);
                        }

                        //Remember the original stack!
                        rsstack = [];
                        rvstack = [];
                        for (i = 0; i &lt; sstack.length; i++) {
                            rsstack[i] = sstack[i];
                            rvstack[i] = vstack[i];
                        }

                        while (act === 52 &amp;&amp; la !== 28) {
                            if (dbg_withtrace) {
                                dbg_print(&#x27;\tError recovery\n&#x27; +
                                    &#x27;Current lookahead: &#x27; + labels[la] + &#x27; (&#x27; + info.att + &#x27;)\n&#x27; +
                                    &#x27;Action: &#x27; + act + &#x27;\n\n&#x27;);
                            }

                            if (la === -1) {
                                info.offset += 1;
                            }

                            while (act === 52 &amp;&amp; sstack.length &gt; 0) {
                                sstack.pop();
                                vstack.pop();

                                if (sstack.length === 0) {
                                    break;
                                }

                                act = 52;

                                for (i = 0; i &lt; act_tab[sstack[sstack.length - 1]].length; i += 2) {
                                    if (act_tab[sstack[sstack.length - 1]][i] === la) {
                                        act = act_tab[sstack[sstack.length - 1]][i + 1];
                                        break;
                                    }
                                }
                            }

                            if (act !== 52) {
                                break;
                            }

                            for (i = 0; i &lt; rsstack.length; i++) {
                                sstack.push(rsstack[i]);
                                vstack.push(rvstack[i]);
                            }

                            la = lex(info);
                        }

                        if (act === 52) {
                            if (dbg_withtrace) {
                                dbg_print(&#x27;\tError recovery failed, terminating parse process...&#x27;);
                            }
                            break;
                        }


                        if (dbg_withtrace) {
                            dbg_print(&#x27;\tError recovery succeeded, continuing&#x27;);
                        }
                    }

                    //Shift
                    if (act &gt; 0) {
                        if (dbg_withtrace) {
                            dbg_print(&#x27;Shifting symbol: &#x27; + labels[la] + &#x27; (&#x27; + info.att + &#x27;)&#x27;);
                        }

                        sstack.push(act);
                        vstack.push(info.att);

                        la = lex(info);

                        if (dbg_withtrace) {
                            dbg_print(&#x27;\tNew lookahead symbol: &#x27; + labels[la] + &#x27; (&#x27; + info.att + &#x27;)&#x27;);
                        }
                        //Reduce
                    } else {
                        act *= -1;

                        if (dbg_withtrace) {
                            dbg_print(&#x27;Reducing by producution: &#x27; + act);
                        }

                        rval = undef;

                        if (dbg_withtrace) {
                            dbg_print(&#x27;\tPerforming semantic action...&#x27;);
                        }

                        switch (act) {
                        case 0:
                            rval = vstack[vstack.length - 1];
                            break;
                        case 1:
                            rval = ggbr.ggbAct(&#x27;end&#x27;, vstack[vstack.length - 1]);
                            break;
                        case 2:
                            rval = ggbr.ggbAct(&#x27;coord&#x27;, vstack[vstack.length - 4], vstack[vstack.length - 2], element);
                            break;
                        case 3:
                            rval = ggbr.ggbAct(&#x27;le&#x27;, vstack[vstack.length - 3], vstack[vstack.length - 1]);
                            break;
                        case 4:
                            rval = ggbr.ggbAct(&#x27;ge&#x27;, vstack[vstack.length - 3], vstack[vstack.length - 1]);
                            break;
                        case 5:
                            rval = ggbr.ggbAct(&#x27;eq&#x27;, vstack[vstack.length - 3], vstack[vstack.length - 1]);
                            break;
                        case 6:
                            rval = ggbr.ggbAct(&#x27;neq&#x27;, vstack[vstack.length - 3], vstack[vstack.length - 1]);
                            break;
                        case 7:
                            rval = ggbr.ggbAct(&#x27;lt&#x27;, vstack[vstack.length - 3], vstack[vstack.length - 1]);
                            break;
                        case 8:
                            rval = ggbr.ggbAct(&#x27;gt&#x27;, vstack[vstack.length - 3], vstack[vstack.length - 1]);
                            break;
                        case 9:
                            rval = ggbr.ggbAct(&#x27;add&#x27;, vstack[vstack.length - 3], vstack[vstack.length - 1]);
                            break;
                        case 10:
                            rval = ggbr.ggbAct(&#x27;sub&#x27;, vstack[vstack.length - 3], vstack[vstack.length - 1]);
                            break;
                        case 11:
                            rval = ggbr.ggbAct(&#x27;neg&#x27;, vstack[vstack.length - 1]);
                            break;
                        case 12:
                            rval = ggbr.ggbAct(&#x27;pow&#x27;, vstack[vstack.length - 3], vstack[vstack.length - 1]);
                            break;
                        case 13:
                            rval = ggbr.ggbAct(&#x27;or&#x27;, vstack[vstack.length - 3], vstack[vstack.length - 1]);
                            break;
                        case 14:
                            rval = ggbr.ggbAct(&#x27;and&#x27;, vstack[vstack.length - 3], vstack[vstack.length - 1]);
                            break;
                        case 15:
                            rval = ggbr.ggbAct(&#x27;mul&#x27;, vstack[vstack.length - 3], vstack[vstack.length - 1]);
                            break;
                        case 16:
                            rval = ggbr.ggbAct(&#x27;div&#x27;, vstack[vstack.length - 3], vstack[vstack.length - 1]);
                            break;
                        case 17:
                            rval = ggbr.ggbAct(&#x27;negmult&#x27;, vstack[vstack.length - 1]);
                            break;
                        case 18:
                            rval = ggbr.ggbAct(&#x27;bra&#x27;, vstack[vstack.length - 2]);
                            break;
                        case 19:
                            rval = ggbr.ggbAct(&#x27;string&#x27;, vstack[vstack.length - 3], vstack[vstack.length - 1]);
                            break;
                        case 20:
                            rval = ggbr.ggbAct(&#x27;int&#x27;, vstack[vstack.length - 1]);
                            break;
                        case 21:
                            rval = ggbr.ggbAct(&#x27;float&#x27;, vstack[vstack.length - 1]);
                            break;
                        case 22:
                            rval = ggbr.ggbAct(&#x27;param&#x27;, vstack[vstack.length - 1]);
                            break;
                        case 23:
                            rval = ggbr.ggbAct(&#x27;html&#x27;, vstack[vstack.length - 1]);
                            break;
                        case 24:
                            rval = ggbr.ggbAct(&#x27;string&#x27;, vstack[vstack.length - 1]);
                            break;
                        case 25:
                            rval = ggbr.ggbAct(&#x27;command&#x27;, vstack[vstack.length - 1]);
                            break;
                        case 26:
                            rval = ggbr.ggbAct(&#x27;var&#x27;, vstack[vstack.length - 4], vstack[vstack.length - 2]);
                            break;
                        case 27:
                            rval = ggbr.ggbAct(&#x27;var&#x27;, vstack[vstack.length - 1]);
                            break;
                        }

                        if (dbg_withtrace) {
                            dbg_print(&#x27;\tPopping &#x27; + pop_tab[act][1] + &#x27; off the stack...&#x27;);
                        }

                        for (i = 0; i &lt; pop_tab[act][1]; i++) {
                            sstack.pop();
                            str = vstack.pop();
                        }

                        go = -1;
                        for (i = 0; i &lt; goto_tab[sstack[sstack.length - 1]].length; i += 2) {
                            if (goto_tab[sstack[sstack.length - 1]][i] === pop_tab[act][0]) {
                                go = goto_tab[sstack[sstack.length - 1]][i + 1];
                                break;
                            }
                        }

                        if (act === 0) {
                            break;
                        }

                        if (dbg_withtrace) {
                            dbg_print(&#x27;\tPushing non-terminal &#x27; + labels[pop_tab[act][0]]);
                        }

                        sstack.push(go);
                        vstack.push(rval);
                    }

                    if (dbg_withtrace) {
                        JXG.debug(dbg_string);
                        dbg_string = &#x27;&#x27;;
                    }
                }

                if (dbg_withtrace) {
                    dbg_print(&#x27;\nParse complete.&#x27;);
                    JXG.debug(dbg_string);
                }

                return err_cnt;
            }
            /***** end replace *****/

            if ((error_count = parse(str, error_offsets, error_lookaheads)) &gt; 0) {
                for (i = 0; i &lt; error_count; i++) {
                    errstr += &#x27;Parse error in line &#x27; +
                        (str.substr(0, error_offsets[i]).match(/\n/g) ? str.substr(0, error_offsets[i]).match(/\n/g).length : 1) +
                        &#x27; near \&#x27;&#x27; + str.substr(error_offsets[i]) + &#x27;\&#x27;, expecting \&#x27;&#x27; + error_lookaheads[i].join() + &#x27;\&#x27;\n&#x27;;
                }
                JXG.debug(errstr);
            }

            return str;
        },

        /**
         * Override JSxGraph defaults with Geogebra settings
         */
        setDefaultOptions: function () {
            this.board.options.elements.strokeWidth = 1;
            this.board.options.elements.withLabel = true;

            this.board.options.point.face = &#x27;circle&#x27;;
            this.board.options.point.size = 3;
            this.board.options.point.fillColor = &#x27;blue&#x27;;
            this.board.options.point.fillOpacity = 1;
            this.board.options.point.highlightFillOpacity = 1;
            this.board.options.point.strokeColor = &#x27;black&#x27;;
            this.board.options.point.highlightStrokeColor = &#x27;black&#x27;;
            this.board.options.point.strokeWidth = 2;

            this.board.options.line.strokeWidth = 1;
            this.board.options.line.highlightStrokeColor = &#x27;#000000&#x27;;
            this.board.options.line.strokeColor = &#x27;#000000&#x27;;

            this.board.options.polygon.fillColor = JXG.rgb2hex(153, 51, 0);
            this.board.options.polygon.fillOpacity = 0.1;
            this.board.options.polygon.highlightFillColor = this.board.options.polygon.fillColor;
            this.board.options.polygon.highlightFillOpacity = 0.1;

            this.board.options.sector.fillColor = JXG.rgb2hex(153, 51, 0);
            this.board.options.sector.fillOpacity = 0.1;
            this.board.options.sector.highlightFillColor = this.board.options.sector.fillColor;
            this.board.options.sector.highlightFillOpacity = 0.1;

            this.board.options.angle.fillColor = JXG.rgb2hex(0, 100, 0);
            this.board.options.angle.fillOpacity = 0.1;
            this.board.options.angle.highlightFillOpacity = 0.1;
        },

        /**
         * Set color properties of a geogebra element.
         * Set stroke, fill, lighting, label and draft color attributes.
         * @param {Object} Data gxtEl element of which attributes are to set
         * @param {Object} attr object carrying all necessary attribute values
         * @return {Object} returning the updated attr-attributes object
         */
        colorProperties: function (Data, attr) {
            var a, r, g, b,
                objColor = Data.getElementsByTagName(&quot;objColor&quot;)[0],
                len = Data.getElementsByTagName(&quot;objColor&quot;).length &gt; 0;

            a = (len &amp;&amp; objColor.getAttribute(&quot;alpha&quot;)) ? parseFloat(objColor.getAttribute(&quot;alpha&quot;)) : 0;
            r = (len &amp;&amp; objColor.getAttribute(&quot;r&quot;)) ? parseInt(objColor.getAttribute(&quot;r&quot;), 10).toString(16) : 0;
            g = (len &amp;&amp; objColor.getAttribute(&quot;g&quot;)) ? parseInt(objColor.getAttribute(&quot;g&quot;), 10).toString(16) : 0;
            b = (len &amp;&amp; objColor.getAttribute(&quot;b&quot;)) ? parseInt(objColor.getAttribute(&quot;b&quot;), 10).toString(16) : 0;

            if (r.length === 1) {
                r = &#x27;0&#x27; + r;
            }

            if (g.length === 1) {
                g = &#x27;0&#x27; + g;
            }

            if (b.length === 1) {
                b = &#x27;0&#x27; + b;
            }

            attr.fillColor = &#x27;#&#x27; + r + g + b;
            attr.strokeColor = attr.fillColor;
            attr.highlightFillColor = attr.fillColor;
            attr.highlightStrokeColor = attr.strokeColor;
            attr.fillOpacity = a;
            attr.highlightFillOpacity = a;
            attr.labelColor = attr.fillColor;

            return attr;
        },

        /**
         * Set the board properties.
         * Set active, area, dash, draft and showinfo attributes.
         * @param {Object} gxtEl element of which attributes are to set
         * @param {Object} Data element of which attributes are to set
         * @param {Object} attr object containing the necessary attribute values
         * @return {Object} The attr parameter
         */
        boardProperties: function (gxtEl, Data, attr) {
            return attr;
        },

        /**
         * @param {Object} gxtEl element of which attributes are to set
         * @param {Object} Data element of which attributes are to set
         * @return {Object} updated element
         */
        coordinates: function (gxtEl, Data) {
            var a, tmp,
                labelOffset = {
                    x: 0,
                    y: 0,
                    z: 0
                };

            if (Data.getElementsByTagName(&#x27;labelOffset&#x27;)[0]) {
                labelOffset.x = parseFloat(Data.getElementsByTagName(&quot;labelOffset&quot;)[0].getAttribute(&quot;x&quot;)) / this.board.unitX;
                labelOffset.y = parseFloat(Data.getElementsByTagName(&quot;labelOffset&quot;)[0].getAttribute(&quot;y&quot;)) / this.board.unitY;
            }

            if (Data.getElementsByTagName(&quot;coords&quot;)[0]) {
                gxtEl.x = parseFloat(Data.getElementsByTagName(&quot;coords&quot;)[0].getAttribute(&quot;x&quot;));
                gxtEl.y = parseFloat(Data.getElementsByTagName(&quot;coords&quot;)[0].getAttribute(&quot;y&quot;));
                gxtEl.z = parseFloat(Data.getElementsByTagName(&quot;coords&quot;)[0].getAttribute(&quot;z&quot;));
            } else if (Data.getElementsByTagName(&quot;startPoint&quot;)[0]) {
                if (Data.getElementsByTagName(&quot;startPoint&quot;)[0].getAttribute(&#x27;exp&#x27;)) {
                    a = this.board.select(Data.getElementsByTagName(&quot;startPoint&quot;)[0].getAttribute(&#x27;exp&#x27;));
                    gxtEl.x = function () {
                        return a.X() + labelOffset.x;
                    };
                    gxtEl.y = function () {
                        // minus because geogebra starts on the other side
                        return a.Y() - labelOffset.y;
                    };
                    gxtEl.z = false;
                } else {
                    gxtEl.x = parseFloat(Data.getElementsByTagName(&quot;startPoint&quot;)[0].getAttribute(&quot;x&quot;));
                    gxtEl.y = parseFloat(Data.getElementsByTagName(&quot;startPoint&quot;)[0].getAttribute(&quot;y&quot;));
                    gxtEl.z = parseFloat(Data.getElementsByTagName(&quot;startPoint&quot;)[0].getAttribute(&quot;z&quot;));
                }
            } else if (Data.getElementsByTagName(&quot;absoluteScreenLocation&quot;)[0]) {
                tmp = new JXG.Coords(JXG.COORDS_BY_SCREEN, [parseFloat(Data.getElementsByTagName(&quot;absoluteScreenLocation&quot;)[0].getAttribute(&quot;x&quot;)),
                    parseFloat(Data.getElementsByTagName(&quot;absoluteScreenLocation&quot;)[0].getAttribute(&quot;y&quot;))], this.board);
                gxtEl.x = tmp.usrCoords[1] + labelOffset.x;
                gxtEl.y = tmp.usrCoords[2] + labelOffset.y;
                gxtEl.z = false;
            } else {
                return false;
            }

            return gxtEl;
        },

        /**
         * Writing element attributes to the given object
         * @param {Object} Data expects the content of the current element
         * @param {Object} attr
         * @return {Object} object with according attributes
         */
        visualProperties: function (Data, attr) {
            var show = Data.getElementsByTagName(&quot;show&quot;),
                pointSize = Data.getElementsByTagName(&#x27;pointSize&#x27;),
                pointStyle = Data.getElementsByTagName(&#x27;pointStyle&#x27;),
                slopeTriangleSize = Data.getElementsByTagName(&#x27;slopeTriangleSize&#x27;),
                lineStyle = Data.getElementsByTagName(&#x27;lineStyle&#x27;),
                labelOffset = Data.getElementsByTagName(&#x27;labelOffset&#x27;),
                trace = Data.getElementsByTagName(&#x27;trace&#x27;),
                fix = Data.getElementsByTagName(&#x27;fix&#x27;);

            if (show.length &gt; 0 &amp;&amp; show[0].getAttribute(&#x27;object&#x27;)) {
                attr.visible = JXG.str2Bool(show[0].getAttribute(&#x27;object&#x27;));
            }

            if (show.length &gt; 0 &amp;&amp; show[0].getAttribute(&#x27;label&#x27;)) {
                attr.withLabel = JXG.str2Bool(show[0].getAttribute(&#x27;label&#x27;));
            }

            if (pointSize.length &gt; 0 &amp;&amp; pointSize[0].getAttribute(&#x27;val&#x27;)) {
                attr.size = parseInt(pointSize[0].getAttribute(&#x27;val&#x27;), 10);
            }

            if (pointStyle.length &gt; 0 &amp;&amp; pointStyle[0].getAttribute(&#x27;val&#x27;)) {
                attr.styleGGB = parseInt(pointStyle[0].getAttribute(&#x27;val&#x27;), 10);
            }

            if (attr.styleGGB === 0 || attr.styleGGB === 2) {
                attr.face = &#x27;circle&#x27;;

                if (attr.styleGGB === 0) {
                    attr.fillColor = attr.strokeColor;
                    attr.fillOpacity = 1;
                    attr.highlightFillColor = attr.strokeColor;
                    attr.highlightFillOpacity = 1;
                    attr.strokeColor = &#x27;black&#x27;;
                    attr.strokeWidth = 1;
                } else if (attr.styleGGB === 2) {
                    attr.fillColor = &#x27;none&#x27;;
                }
            } else if (attr.styleGGB === 1) {
                attr.face = &#x27;x&#x27;;
            } else if (attr.styleGGB === 3) {
                attr.face = &#x27;+&#x27;;
                attr.strokeOpacity = 1;
            } else if (attr.styleGGB === 4 || attr.styleGGB === 5) {
                attr.face = &#x27;diamond&#x27;;

                if (attr.styleGGB === 4) {
                    attr.fillColor = attr.strokeColor;
                    attr.fillOpacity = 1;
                } else if (attr.styleGGB === 5) {
                    attr.fillColor = &#x27;none&#x27;;
                }
            } else if (attr.styleGGB === 6) {
                attr.face = &#x27;triangleUp&#x27;;
                attr.fillColor = attr.strokeColor;
                attr.fillOpacity = 1;
            } else if (attr.styleGGB === 7) {
                attr.face = &#x27;triangleDown&#x27;;
                attr.fillColor = attr.strokeColor;
                attr.fillOpacity = 1;
            } else if (attr.styleGGB === 8) {
                attr.face = &#x27;triangleRight&#x27;;
                attr.fillColor = attr.strokeColor;
                attr.fillOpacity = 1;
            } else if (attr.styleGGB === 9) {
                attr.face = &#x27;triangleLeft&#x27;;
                attr.fillColor = attr.strokeColor;
                attr.fillOpacity = 1;
            }

            if (slopeTriangleSize.length &gt; 0) {
                attr.slopeWidth = slopeTriangleSize[0].getAttribute(&#x27;val&#x27;);
            }

            if (lineStyle.length &gt; 0) {
                attr.strokeWidth = Math.round(parseFloat(lineStyle[0].getAttribute(&#x27;thickness&#x27;)) / 2);
                attr.dashGGB = lineStyle[0].getAttribute(&quot;type&quot;);
            }

            if (attr.strokeWidth) {
                attr.highlightStrokeWidth = attr.strokeWidth + 1;
            }

            if (attr.dashGGB === &#x27;0&#x27;) {
                attr.dash = 0;
            } else if (attr.dashGGB === &#x27;10&#x27;) {
                attr.dash = 2;
            } else if (attr.dashGGB === &#x27;15&#x27;) {
                attr.dash = 3;
            } else if (attr.dashGGB === &#x27;20&#x27;) {
                attr.dash = 1;
            } else if (attr.dashGGB === &#x27;30&#x27;) {
                attr.dash = 6;
            }

            if (labelOffset.length &gt; 0) {
                attr.labelX = parseFloat(labelOffset[0].getAttribute(&#x27;x&#x27;));
                attr.labelY = parseFloat(labelOffset[0].getAttribute(&#x27;y&#x27;));
            }

            if (trace.length &gt; 0) {
                attr.trace = trace[0].getAttribute(&#x27;val&#x27;);
            }

            if (fix.length &gt; 0) {
                attr.fixed = fix[0].getAttribute(&#x27;val&#x27;);
            }

            return attr;
        },

        /**
         * Searching for an element in the geogebra tree
         * @param {String} name the name of the element to search for
         * @param {Boolean} [expr=false] whether it is search for an expression or not
         * @return {Object} object with according label
         */
        getElement: function (name, expr) {
            var Data, i, j;

            expr = expr || false;
            for (i = 0; i &lt; this.tree.getElementsByTagName(&quot;construction&quot;).length; i++) {
                if (expr === false) {
                    for (j = 0; j &lt; this.tree.getElementsByTagName(&quot;construction&quot;)[i].getElementsByTagName(&quot;element&quot;).length; j++) {
                        Data = this.tree.getElementsByTagName(&quot;construction&quot;)[i].getElementsByTagName(&quot;element&quot;)[j];
                        if (name === Data.getAttribute(&quot;label&quot;)) {
                            return Data;
                        }
                    }
                } else {
                    for (j = 0; j &lt; this.tree.getElementsByTagName(&quot;construction&quot;)[i].getElementsByTagName(&quot;expression&quot;).length; j++) {
                        Data = this.tree.getElementsByTagName(&quot;construction&quot;)[i].getElementsByTagName(&quot;expression&quot;)[j];
                        if (name === Data.getAttribute(&quot;label&quot;)) {
                            return Data;
                        }
                        if (name === Data.getAttribute(&quot;exp&quot;)) {
                            return this.getElement(Data.getAttribute(&quot;label&quot;));
                        }
                    }
                }
            }

            return false;
        },

        /**
         * Check if an element is already registered in the temporary ggbElements register. If not, create and register the element.
         * @param {String} name the name of the element to check
         * @return {Object} newly created element
         */
        checkElement: function (name) {
            var input;

            // Segment[A, B] nur bis Version 2.4 ? In 2.5 schon (x(A), x(B)) und durch Parser loesbar
            // if(name.match(/[a-zA-Z]+\[[a-zA-Z0-9]+[a-zA-Z0-9,\ ]*\]/)) {
            //   var tmp, type, input, output, i;
            //   tmp = name.split(&#x27;[&#x27;);
            //   type = tmp[0];
            //   input = tmp[1].split(&#x27;]&#x27;);
            //   input = input[0].split(&#x27;, &#x27;);
            //   for(i=0; i&lt;input.length; i++) {
            //     input[i] = this.checkElement(input[i]);
            //   }
            //   output = {
            //     &#x27;attributes&#x27; : []
            //   };
            //   output.attributes[&#x27;type&#x27;] = {value: type };
            //   output.attributes[&#x27;label&#x27;] = {value: name};
            //
            //   this.ggbElements[name] = this.writeElement(name, input, type);
            // } else

            if (!JXG.exists(this.ggbElements[name]) || this.ggbElements[name] === &#x27;&#x27;) {
                input = this.getElement(name) || this.getElement(name, true);
                if(!input) {
                    var i, j, Data;
                    var exp1 = this.ggbParse(name);
                    for (i = 0; i &lt; this.tree.getElementsByTagName(&quot;construction&quot;).length; i++) {
                        for (j = 0; j &lt; this.tree.getElementsByTagName(&quot;construction&quot;)[i].getElementsByTagName(&quot;expression&quot;).length; j++) {
                            Data = this.tree.getElementsByTagName(&quot;construction&quot;)[i].getElementsByTagName(&quot;expression&quot;)[j];
                            var exp2 = this.ggbParse(Data.getAttribute(&quot;exp&quot;));
                            if(JXG.isArray(exp1) &amp;&amp; JXG.isArray(exp2)) {
                                if(exp1[0] == exp2[0] &amp;&amp; exp1[1] == exp2[1]) {
                                    input = this.getElement(Data.getAttribute(&quot;label&quot;));
                                }
                            }
                        }
                    }
                    if(!input) {
                        return new Function(&#x27;return &#x27; + exp1 + &#x27;;&#x27;);
                    }
                }
                this.ggbElements[name] = this.writeElement(input);
            }

            return this.ggbElements[name];
        },

        /**
         * Prepare expression for this.ggbParse with solving multiplications and replacing mathematical functions.
         * @param {String} type c, s, or something else
         * @param {String} exp Expression to parse and correct
         * @return {String} correct expression with fixed function and multiplication
         */
        functionParse: function (type, exp) {
            var input, vars, expr, output, i, s, o;

            switch (type) {
            case &#x27;c&#x27;:
                // search for function params
                if (exp.match(/[a-zA-Z0-9\&#x27;]+\([a-zA-Z0-9]+[a-zA-Z0-9,\ ]*\)[\ ]*[=][\ ]*[a-zA-Z0-9\+\-\*\/ \( \) \u005E]+/)) {
                    input = exp.split(&#x27;(&#x27;)[1].split(&#x27;)&#x27;)[0];
                    vars = input.split(&#x27;, &#x27;);

                    output = [];
                    for (i = 0; i &lt; vars.length; i++) {
                        output.push(&quot;__&quot; + vars[i]);
                    }

                    expr = exp.split(&#x27;=&#x27;)[1];

                    // separate and replace function parameters
                    for (i = 0; i &lt; vars.length; i++) {
                        if (vars[i] === &#x27;x&#x27;) {
                            expr = expr.replace(/(?![e])x(?!\()(?![p])/g, &#x27;__&#x27; + vars[i]);
                        } else if (vars[i] === &#x27;y&#x27;) {
                            expr = expr.replace(/(?![e])y(?!\()(?![p])/g, &#x27;__&#x27; + vars[i]);
                        } else {
                            expr = expr.replace(new RegExp(vars[i], &#x27;g&#x27;), &#x27;__&#x27; + vars[i]);
                        }
                    }

                    // replace -__x to -1*__x
                    expr = expr.replace(/-__/g, &#x27;-1*__&#x27;);

                    if (this.format &lt;= 3.01) {
                        // prepare string: &quot;solve&quot; multiplications &#x27;a b&#x27; to &#x27;a*b&#x27;
                        s = expr.split(&#x27; &#x27;);
                        o = &#x27;&#x27;;

                        for (i = 0; i &lt; s.length; i++) {
                            if (s.length !== i + 1) {
                                if (s[i].search(/\)$/) &gt; -1 || s[i].search(/[0-9]+$/) &gt; -1 || s[i].search(/[a-zA-Z]+(_*[a-zA-Z0-9]+)*$/) &gt; -1) {
                                    if (s[i + 1].search(/^\(/) &gt; -1 ||
                                            s[i + 1].search(/^[0-9]+/) &gt; -1 ||
                                            s[i + 1].search(/^[a-zA-Z]+(_*[a-zA-Z0-9]+)*/) &gt; -1 ||
                                            s[i + 1].search(/__[a-zA-Z0-9]+/) &gt; -1) {
                                        s[i] = s[i] + &quot;*&quot;;
                                    }
                                }
                            }
                            o += s[i];
                        }
                        expr = o;
                    }

                    output.push(expr);
                    return output;
                }

                return exp;
            case &#x27;s&#x27;:
                exp = exp.replace(/(?![e])x(?!\()(?![p])/g, &#x27;__x&#x27;);
                return [&#x27;__x&#x27;, exp];
            default:
                if (this.format &lt;= 3.01) {
                    // prepare string: &quot;solve&quot; multiplications &#x27;a b&#x27; to &#x27;a*b&#x27;
                    s = exp.split(&#x27; &#x27;);
                    o = &#x27;&#x27;;

                    for (i = 0; i &lt; s.length; i++) {
                        if (s.length !== i + 1) {
                            if (s[i].search(/\)$/) &gt; -1 || s[i].search(/[0-9]+$/) &gt; -1 || s[i].search(/[a-zA-Z]+(_*[a-zA-Z0-9]+)*$/) &gt; -1) {
                                if (s[i + 1].search(/^\(/) &gt; -1 ||
                                        s[i + 1].search(/^[0-9]+/) &gt; -1 ||
                                        s[i + 1].search(/^[a-zA-Z]+(\_*[a-zA-Z0-9]+)*/) &gt; -1 ||
                                        s[i + 1].search(/\_\_[a-zA-Z0-9]+/) &gt; -1) {
                                    s[i] = s[i] + &quot;*&quot;;
                                }
                            }
                        }
                        o += s[i];
                    }
                    exp = o;
                }
                return exp;
            }
        },

        /**
         * Searching for an element in the geogebra tree
         */
        writeBoard: function () {
            var grid, // currently unused: snapToPoint,
                boardData = this.tree.getElementsByTagName(&quot;euclidianView&quot;)[0],
                coordSystem = boardData.getElementsByTagName(&#x27;coordSystem&#x27;)[0],
                gui = this.tree.getElementsByTagName(&#x27;gui&#x27;)[0],
                evSettings = boardData.getElementsByTagName(&#x27;evSettings&#x27;)[0];

            this.board.origin = {};
            this.board.origin.usrCoords = [1, 0, 0];
            this.board.origin.scrCoords = [1, parseInt(coordSystem.getAttribute(&#x27;xZero&#x27;), 10), parseInt(coordSystem.getAttribute(&#x27;yZero&#x27;), 10)];
            this.board.unitX = (coordSystem.getAttribute(&#x27;scale&#x27;)) ? parseInt(coordSystem.getAttribute(&#x27;scale&#x27;), 10) : 1;
            this.board.unitY = (coordSystem.getAttribute(&#x27;yscale&#x27;)) ? parseInt(coordSystem.getAttribute(&#x27;yscale&#x27;), 10) : this.board.unitX;

            this.board.fontSize = (gui &amp;&amp; gui.getElementsByTagName(&#x27;font&#x27;)[0]) ?
                    parseInt(gui.getElementsByTagName(&quot;font&quot;)[0].getAttribute(&quot;size&quot;), 10) :
                    12;

            // the new board storage
            JXG.boards[this.board.id] = this.board;

            // Update of properties during update() is not necessary in GEONExT files
            this.board.renderer.enhancedRendering = true;

            // snap to point; value is never used?
            //snapToPoint = (evSettings.getAttribute(&quot;pointCapturing&quot;) === &quot;true&quot;);

            grid = (evSettings.getAttribute(&quot;grid&quot;) === &quot;true&quot;) ? this.board.create(&#x27;grid&#x27;) : null;

            if (evSettings.getAttribute(&quot;axes&quot;)) {
                if(evSettings.getAttribute(&quot;axes&quot;) === &quot;true&quot;) {
                    this.ggbElements.xAxis = this.board.create(&#x27;axis&#x27;, [[0, 0], [1, 0]], {strokeColor: &#x27;transparent&#x27;, minorTicks: 0});
                    this.ggbElements.yAxis = this.board.create(&#x27;axis&#x27;, [[0, 0], [0, 1]], {strokeColor: &#x27;black&#x27;, minorTicks: 0});
                } else {
                    this.ggbElements.xAxis = this.board.create(&#x27;axis&#x27;, [[0, 0], [1, 0]], {strokeColor: &#x27;transparent&#x27;, ticks: {drawLabels: false}});
                    this.ggbElements.yAxis = this.board.create(&#x27;axis&#x27;, [[0, 0], [0, 1]], {strokeColor: &#x27;transparent&#x27;, ticks: {drawLabels: false}});
                }
            }
        },

        /**
         * Searching for an element in the geogebra tree
         * @param {Object} output ggb element whose attributes are to parse
         * @param {Array} input list of all input elements
         * @param {String} cmd output construction method
         * @return {Object} return newly created element or false
         */
        writeElement: function (output, input, cmd) {
            var p, res, re2, poly, t2, t, m, i, l2, p2, l1, p1, slopeWidth,
                tmp, attr2, t1, i2, i1, pol, type, d2, d1, d, startpoint,
                inp, borderatts, borders, element, gxtEl, attr, exp, coord, points,
                length, match, matchDep, rx, q, c, s, e, sx, sy, ex, ey, func, range,

                // for use with closures
                that = this,

                makeConstFun = function (a) {
                    return function () {
                        return a;
                    };
                },
                makeRootFun = function (x) {
                    return function () {
                        return JXG.Math.Numerics.root(inp.Y, x, inp);
                    };
                };

            element = (JXG.isArray(output) ? output[0] : output);
            // geometric element
            gxtEl = {};
            // Attributes of geometric elements
            attr = {};

            JXG.debug(element);

            gxtEl.type = (element &amp;&amp; element.attributes &amp;&amp; !JXG.exists(cmd)) ? element.getAttribute(&#x27;type&#x27;).toLowerCase() : cmd;
            gxtEl.label = element.getAttribute(&#x27;label&#x27;);
            attr.name  = gxtEl.label;

            JXG.debug(&quot;Constructing &quot; + attr.name + &quot;(&quot; + gxtEl.type + &quot;):&quot;);

            switch (gxtEl.type) {
            case &#x27;point&#x27;:
                attr = this.boardProperties(gxtEl, element, attr);
                attr = this.colorProperties(element, attr);
                attr = this.visualProperties(element, attr);

                if (this.getElement(attr.name, true)) {
                    exp = this.getElement(attr.name, true).getAttribute(&#x27;exp&#x27;);
                    coord = this.ggbParse(exp);

                    // this is parsed and verified by the parser unit above
                    /*jslint evil:true*/
                    gxtEl.x = new Function(&#x27;return &#x27; + coord[0] + &#x27;;&#x27;);
                    gxtEl.y = new Function(&#x27;return &#x27; + coord[1] + &#x27;;&#x27;);
                    /*jslint evil:false*/
                } else {
                    gxtEl = this.coordinates(gxtEl, element);
                }

                if (!JXG.exists(attr.styleGGB)) {
                    attr.face = &#x27;circle&#x27;;
                    attr.fillColor = attr.strokeColor;
                    attr.fillOpacity = 1;
                    attr.highlightFillColor = attr.strokeColor;
                    attr.highlightFillOpacity = 1;
                    attr.strokeColor = &#x27;black&#x27;;
                    attr.strokeWidth = 1;
                }

                JXG.debug(gxtEl);
                JXG.debug(input);

                try {
                    match = /Circle\[\s*(\w+)\s*,\s*([\d\.]+)\s*\]/.exec(input);
                    matchDep = /Circle\[\s*(\w+)\s*,\s*(\w+)\s*\]/.exec(input);

                    if (JXG.exists(input)) {
                        if (JXG.exists(match) &amp;&amp; match.length === 3) {
                            // from Circle[A, 5] take &quot;A&quot; and &quot;5&quot;, stored in ma[1] and ma[2]
                            q = this.checkElement(match[1]);
                            c = this.board.create(&#x27;circle&#x27;, [q, parseFloat(match[2])], {fillColor: &#x27;none&#x27;, visible: false, name: &#x27;&#x27;});
                            p = this.board.create(&#x27;glider&#x27;, [gxtEl.x, gxtEl.y, c], attr);
                        } else if (JXG.exists(matchDep) &amp;&amp; matchDep.length === 3) {
                            // Circle around point ma[1] with radius defined by another elements Value-function ma[2]
                            q = this.checkElement(matchDep[1]);
                            m = this.checkElement(matchDep[2]);
                            c = this.board.create(&#x27;circle&#x27;, [q, function () { return m.Value(); }], {fillColor: &#x27;none&#x27;, visible: false, name: &#x27;&#x27;});
                            p = this.board.create(&#x27;glider&#x27;, [gxtEl.x, gxtEl.y, c], attr);
                        } else if (JXG.isArray(input)) {
                            p = this.board.create(&#x27;glider&#x27;, [gxtEl.x, gxtEl.y, input[0]], attr);
                        } else {
                            p = this.board.create(&#x27;glider&#x27;, [gxtEl.x, gxtEl.y, input], attr);
                        }
                    } else {
                        p = this.board.create(&#x27;point&#x27;, [gxtEl.x, gxtEl.y], attr);
                    }
                    return p;
                } catch (exc1) {
                    JXG.debug(&quot;* Err: Point &quot; + attr.name);
                    return false;
                }
                break;
            case &#x27;segment&#x27;:
                attr = this.boardProperties(gxtEl, element, attr);
                attr = this.colorProperties(element, attr);
                gxtEl = this.coordinates(gxtEl, element);
                attr = this.visualProperties(element, attr);

                if (typeof input === &#x27;undefined&#x27;) {
                    input = [
                        parseFloat(element.getElementsByTagName(&#x27;coords&#x27;)[0].getAttribute(&#x27;z&#x27;)),
                        parseFloat(element.getElementsByTagName(&#x27;coords&#x27;)[0].getAttribute(&#x27;x&#x27;)),
                        parseFloat(element.getElementsByTagName(&#x27;coords&#x27;)[0].getAttribute(&#x27;y&#x27;))
                    ];
                } else if (this.board.select(input[1].id).elementClass === JXG.OBJECT_CLASS_LINE) {
                    type = &#x27;parallel&#x27;;
                }

                try {
                    JXG.debug(&quot;* Segment: (&quot; + attr.name + &quot;) First: &quot; + input[0].name + &quot;, Last: &quot; + input[1].name);
                    attr.straightFirst = false;
                    attr.straightLast =  false;
                    p = this.board.create(&#x27;line&#x27;, input, attr);
                    return p;
                } catch (exc2) {
                    JXG.debug(&quot;* Err: Segment &quot; + attr.name + &quot; First: &quot; + input[0].name + &quot;, Last: &quot; + input[1].name);
                    return false;
                }
                break;
            case &#x27;line&#x27;:
                attr = this.boardProperties(gxtEl, element, attr);
                attr = this.colorProperties(element, attr);
                gxtEl = this.coordinates(gxtEl, element);
                attr = this.visualProperties(element, attr);

                type = &#x27;line&#x27;;
                if (!input) {
                    input = [
                        parseFloat(element.getElementsByTagName(&#x27;coords&#x27;)[0].getAttribute(&#x27;z&#x27;)),
                        parseFloat(element.getElementsByTagName(&#x27;coords&#x27;)[0].getAttribute(&#x27;x&#x27;)),
                        parseFloat(element.getElementsByTagName(&#x27;coords&#x27;)[0].getAttribute(&#x27;y&#x27;))
                    ];
                } else if (this.board.select(input[1].id).elementClass === JXG.OBJECT_CLASS_LINE) {
                    // Parallel line through point
                    type = &#x27;parallel&#x27;;
                }

                try {
                    p = this.board.create(type, input, attr);
                    return p;
                } catch (exc3) {
                    JXG.debug(&quot;* Err: Line &quot; + attr.label);
                    return false;
                }
                break;
            case &quot;orthogonalline&quot;:
                attr = this.boardProperties(gxtEl, element, attr);
                attr = this.colorProperties(element, attr);
                gxtEl = this.coordinates(gxtEl, element);
                attr = this.visualProperties(element, attr);

                try {
                    JXG.debug(&quot;* Orthogonalline: First: &quot; + input[0].id + &quot;, Last: &quot; + input[1].id);
                    p = this.board.create(&#x27;normal&#x27;, input, attr);
                    return p;
                } catch (exc4) {
                    JXG.debug(&quot;* Err: Orthogonalline &quot; + attr.label);
                    return false;
                }
                break;
            case &quot;polygon&quot;:
                attr = this.boardProperties(gxtEl, element, attr);
                attr = this.colorProperties(element, attr);
                gxtEl = this.coordinates(gxtEl, element);
                attr = this.visualProperties(element, attr);

                // test if polygon is regular
                if (input.length === 3 &amp;&amp; output.length !== 4) {
                    input[2] = parseInt(input[2], 10);
                    type = &#x27;regular&#x27;;
                }

                try {
                    JXG.debug(&quot;* Polygon: First: &quot; + input[0].name + &quot;, Second: &quot; + input[1].name + &quot;, Third: &quot; + input[2]);

                    borders = [];
                    borderatts = [];
                    length = (type === &#x27;regular&#x27; ? output.length - input[2] + 2 : output.length);

                    for (i = 1; i &lt; length; i++) {
                        borders[i - 1] = {};
                        borderatts[i - 1] = {};
                        borders[i - 1].id = &#x27;&#x27;;
                        borders[i - 1].name = output[i].getAttribute(&#x27;label&#x27;);
                        borderatts[i - 1] = this.colorProperties(output[i], borderatts[i - 1]);
                        borderatts[i - 1] = this.visualProperties(output[i], borderatts[i - 1]);
                    }
                    attr.borders = borders;

                    points = [];
                    if (type === &#x27;regular&#x27;) {
                        points.push(input[0]);
                        points.push(input[1]);

                        for (i = input[2] + 1; i &lt; output.length; i++) {
                            if (output[i].attributes) {
                                points.push(this.checkElement(output[i].getAttribute(&#x27;label&#x27;)));
                            } else {
                                points.push(output[i]);
                            }
                        }
                    } else {
                        for (i = 0; i &lt; input.length; i++) {
                            if (typeof input[i] === &#x27;object&#x27;) {
                                points.push(input[i]);
                            }
                        }
                    }

                    if (type === &#x27;regular&#x27;) {
                        p = this.board.create(&#x27;regularpolygon&#x27;, points, attr);
                    } else {
                        p = this.board.create(&#x27;polygon&#x27;, points, attr);
                    }

                    for (i = 0; i &lt; p.borders.length; i++) {
                        if (borderatts[i].withLabel) {
                            p.borders[i].createLabel();
                        }
                        p.borders[i].setAttribute(borderatts[i]);
                    }
                    return p;
                } catch (exc5) {
                    JXG.debug(&quot;* Err: Polygon &quot; + attr.name);
                    return false;
                }
                break;
            case &#x27;intersect&#x27;:
                attr = this.boardProperties(gxtEl, element, attr);
                attr = this.colorProperties(element, attr);
                gxtEl = this.coordinates(gxtEl, element);
                attr = this.visualProperties(element, attr);

                try {
                    JXG.debug(&quot;* Intersection: First: &quot; + input[0].name + &quot;, Second: &quot; + input[1].name);
                    if (!JXG.exists(attr.styleGGB)) {
                        attr.face = &#x27;circle&#x27;;
                        attr.fillColor = attr.strokeColor;
                        attr.fillOpacity = 1;
                        attr.highlightFillColor = attr.strokeColor;
                        attr.highlightFillOpacity = 1;
                        attr.strokeColor = &#x27;black&#x27;;
                        attr.strokeWidth = 1;
                    }

                    if (output.length === 1) {
                        p = this.board.create(&#x27;intersection&#x27;, [input[0], input[1], 0], attr);
                    } else {
                        p = this.board.create(&#x27;intersection&#x27;, [input[0], input[1], 1], attr);
                        attr2 = {};
                        attr2 = this.colorProperties(output[1], attr2);
                        attr2 = this.visualProperties(output[1], attr2);
                        attr2.name = output[1].getAttribute(&#x27;label&#x27;);
                        p2 = this.board.create(&#x27;otherintersection&#x27;, [input[0], input[1], p], attr2);
                        this.ggbElements[attr2.name] = p2;
                    }

                    return p;
                } catch (exc6) {
                    JXG.debug(&quot;* Err: Intersection &quot; + attr.name);
                    return false;
                }
                break;
            case &#x27;distance&#x27;:
                attr = this.boardProperties(gxtEl, element, attr);
                attr = this.colorProperties(element, attr);
                gxtEl = this.coordinates(gxtEl, element);
                attr = this.visualProperties(element, attr);


                try {
                    JXG.debug(&quot;* Distance: First: &quot; + input[0].name + &quot;, Second: &quot; + input[1].name);

                    /*if (false &amp;&amp; output[0].getAtribute(&#x27;type&#x27;) &amp;&amp; output[0].getAttribute(&#x27;type&#x27;) == &#x27;numeric&#x27;) {
                        input[1].Value = function(){ return this.X(); };
                        p = input[1];
                        board.elementsByName[attr.name] = p;
                    } else {*/
                    m = this.board.create(&#x27;midpoint&#x27;, input, {visible: &#x27;false&#x27;});
                    attr.visible = &#x27;true&#x27;;
                    p = this.board.create(&#x27;text&#x27;, [
                        function () {
                            return m.X();
                        },
                        function () {
                            return m.Y();
                        },
                        function () {
                            return &quot;&lt;span style=&#x27;text-decoration: overline&#x27;&gt;&quot; + input[0].name + input[1].name + &quot;&lt;/span&gt; = &quot; +
                                JXG.trimNumber(that.board.select(input[0].id).Dist(that.board.select(input[1].id)).toFixed(that.decimals));
                        }
                    ], attr);

                    p.Value = function () {
                        return (that.board.select(input[0].id).Dist(that.board.select(input[1].id)));
                    };

                    return p;
                } catch (exc7) {
                    JXG.debug(&quot;* Err: Distance &quot; + attr.name);
                    return false;
                }
                break;
            case &#x27;vector&#x27;:
                attr = this.boardProperties(gxtEl, element, attr);
                attr = this.colorProperties(element, attr);
                gxtEl = this.coordinates(gxtEl, element);
                attr = this.visualProperties(element, attr);

                if (element.getElementsByTagName(&quot;startPoint&quot;)[0]) {
                    if (input &amp;&amp; input.length === 2) {
                        e = this.checkElement(input[1].name);
                    } else {
                        e = [parseFloat(element.getElementsByTagName(&quot;coords&quot;)[0].getAttribute(&quot;x&quot;)), parseFloat(element.getElementsByTagName(&quot;coords&quot;)[0].getAttribute(&quot;y&quot;))];
                    }

                    if (element.getElementsByTagName(&quot;startPoint&quot;)[0].getAttribute(&quot;x&quot;) &amp;&amp; element.getElementsByTagName(&quot;startPoint&quot;)[0].getAttribute(&quot;y&quot;)) {
                        s = [parseFloat(element.getElementsByTagName(&quot;startPoint&quot;)[0].getAttribute(&quot;x&quot;)), parseFloat(element.getElementsByTagName(&quot;startPoint&quot;)[0].getAttribute(&quot;y&quot;))];
                    } else if (element.getElementsByTagName(&quot;startPoint&quot;)[0].getAttribute(&quot;exp&quot;)) {
                        startpoint = element.getElementsByTagName(&quot;startPoint&quot;)[0].getAttribute(&quot;exp&quot;);
                        s = this.checkElement(startpoint);
                    }
                } else if (input &amp;&amp; input.length !== 0) {
                    s = input[0];
                    e = input[1];
                } else {
                    exp = this.getElement(element.getAttribute(&#x27;label&#x27;), true);
                    if (exp) {// experimental
                        exp = exp.getAttribute(&#x27;exp&#x27;);
                        exp = this.ggbParse(exp);

                        // the input to these evals were verified by the parser unit above
                        /*jslint evil:true*/
                        if (JXG.isArray(exp)) {
                            exp = [new Function(&#x27;return &#x27; + exp[1] + &#x27;;&#x27;), new Function(&#x27;return &#x27; + exp[2] + &#x27;;&#x27;)];
                        } else {
                            exp = new Function(&#x27;return &#x27; + exp + &#x27;;&#x27;);
                        }
                        /*jslint evil:false*/

                        JXG.debug(&#x27;exp: &#x27; + exp);
                        p = this.board.create(&#x27;arrow&#x27;, [[0, 0], [exp[0], exp[1]]], attr);

                        return p;
                        // priorization of expression like &#x27;t*a&#x27; --&gt; a := startPoint
                    }
                }

                try {
                    JXG.debug(&quot;* Vector: First: &quot; + attr.name);
                    p = this.board.create(&#x27;arrow&#x27;, [s, e], attr);
                    return p;
                } catch (exc8) {
                    JXG.debug(&quot;* Err: Vector &quot; + attr.name + e);
                    return false;
                }
                break;
            case &#x27;rotate&#x27;:
                attr = this.boardProperties(gxtEl, element, attr);
                attr = this.colorProperties(element, attr);
                gxtEl = this.coordinates(gxtEl, element);
                attr = this.visualProperties(element, attr);

                try {
                    JXG.debug(&quot;* Rotate: First: &quot; + input[0].name + &quot;, Second: &quot; + input[1]);
                    attr.type = &#x27;rotate&#x27;;

                    if (!JXG.exists(attr.styleGGB)) {
                        attr.face = &#x27;circle&#x27;;
                        attr.fillColor = attr.strokeColor;
                        attr.fillOpacity = 1;
                        attr.highlightFillColor = attr.strokeColor;
                        attr.highlightFillOpacity = 1;
                        attr.strokeColor = &#x27;black&#x27;;
                        attr.strokeWidth = 1;
                    }

                    t = this.board.create(&#x27;transform&#x27;, [parseInt(input[1], 10) * Math.PI / 180, input[2]], {type: &#x27;rotate&#x27;});
                    p = this.board.create(&#x27;point&#x27;, [input[0], t], attr);
                    return p;
                } catch (exc9) {
                    JXG.debug(&quot;* Err: Rotate &quot; + attr.name);
                    return false;
                }
                break;
            case &#x27;dilate&#x27;:
                attr = this.boardProperties(gxtEl, element, attr);
                attr = this.colorProperties(element, attr);
                gxtEl = this.coordinates(gxtEl, element);
                attr = this.visualProperties(element, attr);

                try {
                    JXG.debug(&quot;* Dilate: First: &quot; + input[0].name + &quot;, Second: &quot; + input[1]);
                    attr.type = &#x27;rotate&#x27;;
                    d = parseInt(input[1], 10);
                    d1 = this.board.create(&#x27;transform&#x27;, [d, d], {type: &#x27;scale&#x27;});
                    d2 = this.board.create(&#x27;transform&#x27;, [
                        function () {
                            return (1 - d) * input[2].X();
                        },
                        function () {
                            return (1 - d) * input[2].Y();
                        }
                    ], {type: &#x27;translate&#x27;});

                    if (!JXG.exists(attr.styleGGB)) {
                        attr.face = &#x27;circle&#x27;;
                        attr.fillColor = attr.strokeColor;
                        attr.fillOpacity = 1;
                        attr.highlightFillColor = attr.strokeColor;
                        attr.highlightFillOpacity = 1;
                        attr.strokeColor = &#x27;black&#x27;;
                        attr.strokeWidth = 1;
                    }
                    p = this.board.create(&#x27;point&#x27;, [input[0], [d1, d2]], attr);

                    return p;
                } catch (exc10) {
                    JXG.debug(&quot;* Err: Dilate &quot; + attr.name);
                    return false;
                }
                break;
            case &#x27;translate&#x27;:
                attr = this.boardProperties(gxtEl, element, attr);
                attr = this.colorProperties(element, attr);
                gxtEl = this.coordinates(gxtEl, element);
                attr = this.visualProperties(element, attr);

                try {
                    t = this.board.create(&#x27;transform&#x27;, [
                        function () {
                            return input[1].point2.X() - input[1].point1.X();
                        },
                        function () {
                            return input[1].point2.Y() - input[1].point1.Y();
                        }
                    ], {type: &#x27;translate&#x27;});

                    if (!JXG.exists(attr.styleGGB)) {
                        attr.face = &#x27;circle&#x27;;
                        attr.fillColor = attr.strokeColor;
                        attr.fillOpacity = 1;
                        attr.highlightFillColor = attr.strokeColor;
                        attr.highlightFillOpacity = 1;
                        attr.strokeColor = &#x27;black&#x27;;
                        attr.strokeWidth = 1;
                    }
                    p = this.board.create(&#x27;point&#x27;, [input[0], t], attr);
                    return p;
                } catch (exc11) {
                    JXG.debug(&quot;* Err: Translate &quot; + attr.name);
                    return false;
                }
                break;
            case &#x27;mirror&#x27;:
                attr = this.boardProperties(gxtEl, element, attr);
                attr = this.colorProperties(element, attr);
                gxtEl = this.coordinates(gxtEl, element);
                attr = this.visualProperties(element, attr);

                // Punktspiegelung
                if (JXG.isPoint(this.board.select(input[1].id))) {
                    type = &#x27;mirrorpoint&#x27;;
                // Achsenspiegelung
                } else if (this.board.select(input[1].id).elementClass === JXG.OBJECT_CLASS_LINE) {
                    type = &#x27;reflection&#x27;;
                }

                try {
                    JXG.debug(&quot;* Mirror: First: &quot; + input[0].name + &quot;, Second: &quot; + input[1].name);
                    p = this.board.create(type, [input[1], input[0]], attr);
                    return p;
                } catch (exc12) {
                    JXG.debug(&quot;* Err: Mirror &quot; + attr.name);
                    return false;
                }
                break;
            case &#x27;circle&#x27;:
                attr = this.boardProperties(gxtEl, element, attr);
                attr = this.colorProperties(element, attr);
                gxtEl = this.coordinates(gxtEl, element);
                attr = this.visualProperties(element, attr);

                try {
                    JXG.debug(&quot;* Circle: First: &quot; + input[0].name + &quot;, Second: &quot; + input[1]);
                    p = this.board.create(&#x27;circle&#x27;, input, attr);
                    return p;
                } catch (exc13) {
                    JXG.debug(&quot;* Err: Circle &quot; + attr.name);
                    return false;
                }
                break;
            case &#x27;circlearc&#x27;:
                attr = this.boardProperties(gxtEl, element, attr);
                attr = this.colorProperties(element, attr);
                gxtEl = this.coordinates(gxtEl, element);
                attr = this.visualProperties(element, attr);

                try {
                    JXG.debug(&quot;* CircleArc: First: &quot; + input[0].name + &quot;, Second: &quot; + input[1].name + &quot;, Third: &quot; + input[2].name);
                    p = this.board.create(&#x27;arc&#x27;, input, attr);
                    return p;
                } catch (exc14) {
                    JXG.debug(&quot;* Err: CircleArc &quot; + attr.name);
                    return false;
                }
                break;
            case &#x27;ellipse&#x27;:
                attr = this.boardProperties(gxtEl, element, attr);
                attr = this.colorProperties(element, attr);
                gxtEl = this.coordinates(gxtEl, element);
                attr = this.visualProperties(element, attr);

                try {
                    JXG.debug(&quot;* Ellipse: First: &quot; + input[0].name + &quot;, Second: &quot; + input[1].name + &quot;, Third: &quot; + input[2]);

                    // if third parameters is the major axis, else the third parameter is a point
                    if (parseInt(input[2], 10) === input[2]) {
                        // Geogebra delivers the half major axis
                        input[2] = parseInt(input[2], 10) * 2;
                    }

                    p = this.board.create(&#x27;ellipse&#x27;, input, attr);
                    return p;
                } catch (exc15) {
                    JXG.debug(&quot;* Err: Ellipse &quot; + attr.name);
                    return false;
                }
                break;
            case &#x27;conic&#x27;:
                attr = this.boardProperties(gxtEl, element, attr);
                attr = this.colorProperties(element, attr);
                gxtEl = this.coordinates(gxtEl, element);
                attr = this.visualProperties(element, attr);

                try {
                    if (input &amp;&amp; input.length === 5) {
                        p = this.board.create(&#x27;conic&#x27;, input, attr);
                    } else if (element.getElementsByTagName(&#x27;matrix&#x27;)) {
                        m = [];
                        for (i = 0; i &lt; element.getElementsByTagName(&#x27;matrix&#x27;)[0].attributes.length; i++) {
                            m[i] = parseFloat(element.getElementsByTagName(&#x27;matrix&#x27;)[0].attributes[i].value);
                        }
                        p = this.board.create(&#x27;conic&#x27;, m, attr);
                    }
                    return p;
                } catch (exc16) {
                    JXG.debug(&quot;* Err: Conic &quot; + attr.name);
                    return false;
                }
                break;
            case &#x27;circlesector&#x27;:
                attr = this.boardProperties(gxtEl, element, attr);
                attr = this.colorProperties(element, attr);
                gxtEl = this.coordinates(gxtEl, element);
                attr = this.visualProperties(element, attr);
                try {
                    JXG.debug(&quot;* CircleSector: First: &quot; + input[0].name + &quot;, Second: &quot; + input[1].name + &quot;, Third: &quot; + input[2].name);
                    p = this.board.create(&#x27;sector&#x27;, [input[0], input[1], input[2]], attr);
                    return p;
                } catch (exc17) {
                    JXG.debug(&quot;* Err: CircleSector &quot; + attr.name);
                    return false;
                }
                break;
            case &#x27;linebisector&#x27;:
                attr = this.boardProperties(gxtEl, element, attr);
                attr = this.colorProperties(element, attr);
                gxtEl = this.coordinates(gxtEl, element);
                attr = this.visualProperties(element, attr);

                try {
                    JXG.debug(&quot;* LineBiSector (Mittelsenkrechte): First: &quot; + input[0].name);
                    m = this.board.create(&#x27;midpoint&#x27;, input, {visible: false});
                    if (JXG.isPoint(this.board.select(input[0].id)) &amp;&amp;
                            JXG.isPoint(this.board.select(input[1].id))) {
                        t = this.board.create(&#x27;line&#x27;, input, {visible: &#x27;false&#x27;});
                        p = this.board.create(&#x27;perpendicular&#x27;, [m, t], attr);
                    } else {
                        p = this.board.create(&#x27;perpendicular&#x27;, [m, input[0]], attr);
                    }
                    return p;
                } catch (exc18) {
                    JXG.debug(&quot;* Err: LineBiSector (Mittelsenkrechte) &quot; + attr.name);
                    return false;
                }
                break;
            case &#x27;ray&#x27;:
                attr = this.boardProperties(gxtEl, element, attr);
                attr = this.colorProperties(element, attr);
                gxtEl = this.coordinates(gxtEl, element);
                attr = this.visualProperties(element, attr);

                try {
                    JXG.debug(&quot;* Ray: First: &quot; + input[0].name);
                    attr.straightFirst = true;
                    attr.straightLast =  false;
                    p = this.board.create(&#x27;line&#x27;, [input[1], input[0]], attr);
                    return p;
                } catch (exc19) {
                    JXG.debug(&quot;* Err: Ray &quot; + attr.name);
                    return false;
                }
                break;
            case &#x27;tangent&#x27;:
                attr = this.boardProperties(gxtEl, element, attr);
                attr = this.colorProperties(element, attr);
                gxtEl = this.coordinates(gxtEl, element);
                attr = this.visualProperties(element, attr);

                try {
                    JXG.debug(&quot;* Tangent: First: &quot; + input[0].name + &quot;, Sec.: &quot; + input[1].name + &quot;(&quot; + input[1].type + &quot;)&quot;);
                    switch (input[1].type) {
                    // graph
                    case 1330923344:
                        input[0].makeGlider(input[1]);
                        p = this.board.create(&#x27;tangent&#x27;, [input[0]], attr);
                        return p;
                    // circle 0x4F54434C
                    case 1330922316:
                    // conic 0x4F54434F
                    case 1330922319:
                        pol = this.board.create(&#x27;polar&#x27;, [input[1], input[0]], {visible: false});
                        i1 = this.board.create(&#x27;intersection&#x27;, [input[1], pol, 0], {visible: false});
                        i2 = this.board.create(&#x27;intersection&#x27;, [input[1], pol, 1], {visible: false});
                        t1 = this.board.create(&#x27;line&#x27;, [input[0], i1], attr);
                        attr2 = {};
                        attr2 = this.colorProperties(output[1], attr2);
                        attr2 = this.visualProperties(output[1], attr2);
                        attr2.name = output[1].getAttribute(&#x27;label&#x27;);
                        t2 = this.board.create(&#x27;line&#x27;, [input[0], i2], attr2);
                        this.ggbElements[attr2.name] = t2;
                        return [t1, t2];
                    }
                } catch (exc20) {
                    JXG.debug(&quot;* Err: Tangent &quot; + attr.name + &quot; &quot; + attr2.name);
                    return false;
                }
                break;
            case &#x27;circumcirclearc&#x27;:
                attr = this.boardProperties(gxtEl, element, attr);
                attr = this.colorProperties(element, attr);
                gxtEl = this.coordinates(gxtEl, element);
                attr = this.visualProperties(element, attr);

                try {
                    JXG.debug(&quot;* CircumcircleArc: First: &quot; + input[0].name);
                    p = this.board.create(&#x27;circumcirclearc&#x27;, input, attr);
                    return p;
                } catch (exc21) {
                    JXG.debug(&quot;* Err: CircumcircleArc &quot; + attr.name);
                    return false;
                }
                break;
            case &#x27;circumcirclesector&#x27;:
                attr = this.boardProperties(gxtEl, element, attr);
                attr = this.colorProperties(element, attr);
                gxtEl = this.coordinates(gxtEl, element);
                attr = this.visualProperties(element, attr);

                try {
                    JXG.debug(&quot;* CircumcircleSector: First: &quot; + input[0].name);
                    p = this.board.create(&#x27;circumcirclesector&#x27;, [input[0], input[1], input[2]], attr);
                    return p;
                } catch (exc22) {
                    JXG.debug(&quot;* Err: CircumcircleSector &quot; + attr.name);
                    return false;
                }
                break;
            case &#x27;semicircle&#x27;:
                attr = this.boardProperties(gxtEl, element, attr);
                attr = this.colorProperties(element, attr);
                gxtEl = this.coordinates(gxtEl, element);
                attr = this.visualProperties(element, attr);

                try {
                    JXG.debug(&quot;* Semicircle: First: &quot; + input[0].name);
                    p = this.board.create(&#x27;semicircle&#x27;, [input[0], input[1]], attr);
                    return p;
                } catch (exc23) {
                    JXG.debug(&quot;* Err: Semicircle &quot; + attr.name);
                    return false;
                }
                break;
            case &#x27;angle&#x27;:
                attr = this.boardProperties(gxtEl, element, attr);
                attr = this.colorProperties(element, attr);
                gxtEl = this.coordinates(gxtEl, element);
                attr = this.visualProperties(element, attr);

                try {
                    JXG.debug(&quot;* Angle: First: &quot; + input[0].name);
                    p = this.board.create(&#x27;angle&#x27;, input, attr);
                    return p;
                } catch (exc24) {
                    JXG.debug(&quot;* Err: Angle &quot; + attr.name);
                    return false;
                }
                break;
            case &#x27;angularbisector&#x27;:
                attr = this.boardProperties(gxtEl, element, attr);
                attr = this.colorProperties(element, attr);
                gxtEl = this.coordinates(gxtEl, element);
                attr = this.visualProperties(element, attr);
                attr.straightFirst = true;
                attr.straightLast = true;

                try {
                    JXG.debug(&quot;* Angularbisector: First: &quot; + input[0].name);
                    p = this.board.create(&#x27;bisector&#x27;, input, attr);
                    return p;
                } catch (exc25) {
                    JXG.debug(&quot;* Err: Angularbisector &quot; + attr.name);
                    return false;
                }
                break;
            case &#x27;numeric&#x27;:
                if (element.getElementsByTagName(&#x27;slider&#x27;).length === 0) {
                    // auxiliary doesn&#x27;t exist in every numeric
                    //element.getElementsByTagName(&#x27;auxiliary&#x27;).length != 0 &amp;&amp; element.getElementsByTagName(&#x27;auxiliary&#x27;)[0].attributes[&#x27;val&#x27;].value == &#x27;true&#x27;) {
                    exp = this.getElement(element.getAttribute(&#x27;label&#x27;), true);

                    if (exp) {
                        exp = exp.getAttribute(&#x27;exp&#x27;);
                        exp = this.functionParse(&#x27;&#x27;, exp);
                        exp = this.ggbParse(exp);
                    }

                    // exp was validated by ggbParse
                    /*jslint evil:true*/
                    this.board.ggb[attr.name] = new Function(&#x27;return &#x27; + exp + &#x27;;&#x27;);
                    /*jslint evil:false*/

                    JXG.debug(&#x27;value: &#x27; + this.board.ggb[attr.name]());
                    return this.board.ggb[attr.name];
                }
                attr = this.boardProperties(gxtEl, element, attr);
                attr = this.colorProperties(element, attr);
                attr = this.visualProperties(element, attr);

                // it&#x27;s a slider
                if (element.getElementsByTagName(&#x27;slider&#x27;).length === 1) {
                    sx = parseFloat(element.getElementsByTagName(&#x27;slider&#x27;)[0].getAttribute(&#x27;x&#x27;));
                    sy = parseFloat(element.getElementsByTagName(&#x27;slider&#x27;)[0].getAttribute(&#x27;y&#x27;));
                    length = parseFloat(element.getElementsByTagName(&#x27;slider&#x27;)[0].getAttribute(&#x27;width&#x27;));
                    // are coordinates absolut?
                    if (element.getElementsByTagName(&#x27;slider&#x27;)[0].getAttribute(&#x27;absoluteScreenLocation&#x27;) &amp;&amp; element.getElementsByTagName(&#x27;slider&#x27;)[0].getAttribute(&#x27;absoluteScreenLocation&#x27;) === &#x27;true&#x27;) {
                        tmp = new JXG.Coords(JXG.COORDS_BY_SCREEN, [sx, sy], this.board);
                        sx = tmp.usrCoords[1];
                        sy = tmp.usrCoords[2];
                    }

                    if (element.getElementsByTagName(&#x27;slider&#x27;)[0].getAttribute(&#x27;horizontal&#x27;) === &#x27;true&#x27;) {
                        if (element.getElementsByTagName(&#x27;slider&#x27;)[0].getAttribute(&#x27;absoluteScreenLocation&#x27;) &amp;&amp; element.getElementsByTagName(&#x27;slider&#x27;)[0].getAttribute(&#x27;absoluteScreenLocation&#x27;) === &#x27;true&#x27;) {
                            length /= (this.board.unitX);
                        }
                        ex = sx + length;
                        ey = sy;
                    } else {
                        if (element.getElementsByTagName(&#x27;slider&#x27;)[0].getAttribute(&#x27;absoluteScreenLocation&#x27;) &amp;&amp; element.getElementsByTagName(&#x27;slider&#x27;)[0].getAttribute(&#x27;absoluteScreenLocation&#x27;) === &#x27;true&#x27;) {
                            length /= (this.board.unitY);
                        }
                        ex = sx;
                        ey = sy + length;
                    }

                    if (element.getElementsByTagName(&#x27;animation&#x27;)[0]) {
                        attr.snapWidth = parseFloat(element.getElementsByTagName(&#x27;animation&#x27;)[0].getAttribute(&#x27;step&#x27;));
                    }

                    try {
                        JXG.debug(&quot;* Numeric: First: &quot; + attr.name);
                        attr.withTicks = false;
                        p = this.board.create(&#x27;slider&#x27;, [[sx, sy], [ex, ey], [
                            parseFloat(element.getElementsByTagName(&#x27;slider&#x27;)[0].getAttribute(&#x27;min&#x27;)),
                            parseFloat(element.getElementsByTagName(&#x27;value&#x27;)[0].getAttribute(&#x27;val&#x27;)),
                            parseFloat(element.getElementsByTagName(&#x27;slider&#x27;)[0].getAttribute(&#x27;max&#x27;))
                        ]], attr);
                        return p;
                    } catch (exc26) {
                        JXG.debug(&quot;* Err: Numeric &quot; + attr.name);
                        return false;
                    }
                }
                break;
            case &#x27;midpoint&#x27;:
                attr = this.boardProperties(gxtEl, element, attr);
                attr = this.colorProperties(element, attr);
                gxtEl = this.coordinates(gxtEl, element);
                attr = this.visualProperties(element, attr);

                try {
                    if (!JXG.exists(attr.styleGGB)) {
                        attr.face = &#x27;circle&#x27;;
                        attr.fillColor = attr.strokeColor;
                        attr.fillOpacity = 1;
                        attr.highlightFillColor = attr.strokeColor;
                        attr.highlightFillOpacity = 1;
                        attr.strokeColor = &#x27;black&#x27;;
                        attr.strokeWidth = 1;
                    }
                    p = this.board.create(&#x27;midpoint&#x27;, input, attr);
                    JXG.debug(&quot;* Midpoint (&quot; + p.id + &quot;): &quot; + attr.name + &quot;(&quot; + gxtEl.x + &quot;, &quot; + gxtEl.y + &quot;)&quot;);
                    return p;
                } catch (exc27) {
                    JXG.debug(&quot;* Err: Midpoint &quot; + attr.name);
                    return false;
                }
                break;
            case &#x27;center&#x27;:
                attr = this.boardProperties(gxtEl, element, attr);
                attr = this.colorProperties(element, attr);
                gxtEl = this.coordinates(gxtEl, element);
                attr = this.visualProperties(element, attr);
                try {
                    if (!JXG.exists(attr.styleGGB)) {
                        attr.face = &#x27;circle&#x27;;
                        attr.fillColor = attr.strokeColor;
                        attr.fillOpacity = 1;
                        attr.highlightFillColor = attr.strokeColor;
                        attr.highlightFillOpacity = 1;
                        attr.strokeColor = &#x27;black&#x27;;
                        attr.strokeWidth = 1;
                    }
                    p = this.board.create(&#x27;point&#x27;, [
                        function () {
                            return that.board.select(input[0].id).center.X();
                        },
                        function () {
                            return that.board.select(input[0].id).center.Y();
                        }
                    ], attr);
                    JXG.debug(&quot;* Center (&quot; + p.id + &quot;): &quot; + attr.name + &quot;(&quot; + gxtEl.x + &quot;, &quot; + gxtEl.y + &quot;)&quot;);
                    return p;
                } catch (exc28) {
                    JXG.debug(&quot;* Err: Center &quot; + attr.name);
                    return false;
                }
                break;
            case &#x27;function&#x27;:
                attr = this.boardProperties(gxtEl, element, attr);
                attr = this.colorProperties(element, attr);
                gxtEl = this.coordinates(gxtEl, element);
                attr = this.visualProperties(element, attr);

                if (this.getElement(attr.name, true)) {
                    func = this.getElement(attr.name, true).getAttribute(&#x27;exp&#x27;);
                    func = this.functionParse(&#x27;c&#x27;, func);
                } else {
                    func = input[0];
                    func = this.functionParse(&#x27;s&#x27;, func);
                }

                JXG.debug(func);

                length = func.length;
                func[func.length - 1] = &#x27;return &#x27; + this.ggbParse(func[func.length - 1]) + &#x27;;&#x27;;

                JXG.debug(func);

                range = [(input &amp;&amp; input[1]) ? input[1] : null, (input &amp;&amp; input[2]) ? input[2] : null];

                // fix the range input. This might by x(&lt;point&gt;) or y(point) but JSXGraph only allows X(&lt;point&gt;)
                // and Y(point) so we need to convert this.
                rx = /([x|y])\((\w+)\)/;
                for (i = 0; i &lt; 2; i++) {
                    match = rx.exec(range[i]);
                    if (match) {
                        range[i] = match[1].toUpperCase() + &#x27;(&#x27; + match[2] + &#x27;)&#x27;;
                    }
                }

                // all validated by ggbParse and functionParse
                try {
                    /*jslint evil:true*/
                    if (length === 1) {
                        p = this.board.create(&#x27;functiongraph&#x27;, [new Function(func[0]), range[0], range[1]], attr);
                    } else if (length === 2) {
                        p = this.board.create(&#x27;functiongraph&#x27;, [new Function(func[0], func[1]), range[0], range[1]], attr);
                    } else if (length === 3) {
                        p = this.board.create(&#x27;functiongraph&#x27;, [new Function(func[0], func[1], func[2]), range[0], range[1]], attr);
                    } else if (length === 4) {
                        p = this.board.create(&#x27;functiongraph&#x27;, [new Function(func[0], func[1], func[2], func[3]), range[0], range[1]], attr);
                    } else if (length === 5) {
                        p = this.board.create(&#x27;functiongraph&#x27;, [new Function(func[0], func[1], func[2], func[3], func[4]), range[0], range[1]], attr);
                    }
                    /*jslint evil:false*/

                    return p;
                } catch (exc29) {
                    JXG.debug(&quot;* Err: Functiongraph &quot; + attr.name);
                    return false;
                }

                break;
            case &#x27;polar&#x27;:
                attr = this.boardProperties(gxtEl, element, attr);
                attr = this.colorProperties(element, attr);
                gxtEl = this.coordinates(gxtEl, element);
                attr = this.visualProperties(element, attr);

                try {
                    JXG.debug(&quot;* Polar: First: &quot; + input[0].name + &quot;, Sec.: &quot; + input[1].name);
                    p = this.board.create(&#x27;polar&#x27;, input, attr);
                    return p;
                } catch (exc30) {
                    JXG.debug(&quot;* Err: Polar &quot; + attr.name);
                    return false;
                }
                break;
            case &#x27;slope&#x27;:
                attr = this.boardProperties(gxtEl, element, attr);
                attr = this.colorProperties(element, attr);
                gxtEl = this.coordinates(gxtEl, element);
                attr = this.visualProperties(element, attr);

                try {
                    JXG.debug(&quot;* Slope (&quot; + attr.name + &quot;): First: &quot; + input[0].name);

                    slopeWidth = parseInt(attr.slopeWidth, 10) || 1;
                    p1 = input[0].glider || input[0].point1;

                    p2 = this.board.create(&#x27;point&#x27;, [
                        function () {
                            return (slopeWidth + p1.X());
                        },
                        function () {
                            return p1.Y();
                        }
                    ], {visible: false});

                    l1 = this.board.create(&#x27;segment&#x27;, [p1, p2], {visible: false});
                    l2 = this.board.create(&#x27;normal&#x27;, [l1, l1.point2], {visible: false});
                    i = this.board.create(&#x27;intersection&#x27;, [input[0], l2, 0], {visible: false});
                    m = this.board.create(&#x27;midpoint&#x27;, [l1.point2, i], {visible: false});

                    t = this.board.create(&#x27;text&#x27;, [
                        function () {
                            return m.X();
                        },
                        function () {
                            return m.Y();
                        },
                        function () {
                            return &quot;&amp;nbsp;&amp;nbsp;&quot; + (slopeWidth &gt; 1 ? slopeWidth.toString() : &#x27;&#x27;) + &#x27; &#x27; + this.name + &#x27; = &#x27; + JXG.trimNumber((slopeWidth * input[0].getSlope()).toFixed(that.decimals));
                        }
                    ], attr);
                    attr.name = &#x27;&#x27;;
                    t2 = this.board.create(&#x27;text&#x27;, [
                        function () {
                            return (p1.X() + p2.X()) / 2;
                        },
                        function () {
                            return p1.Y();
                        },
                        function () {
                            return &#x27;&lt;br/&gt;&#x27; + slopeWidth;
                        }
                    ], attr);
                    t.Value = (function () {
                        return function () {
                            return input[0].getSlope();
                        };
                    }());
                    poly = this.board.create(&#x27;polygon&#x27;, [p1, p2, i], attr);

                    poly.borders[2].setAttribute({visible: false});
                    poly.borders[0].setAttribute({strokeColor: attr.fillColor, strokeWidth: attr.strokeWidth, highlightStrokeColor: attr.fillColor, dash: attr.dash});
                    poly.borders[1].setAttribute({strokeColor: attr.fillColor, strokeWidth: attr.strokeWidth, highlightStrokeColor: attr.fillColor, dash: attr.dash});
                    return t;
                } catch (exc31) {
                    JXG.debug(&quot;* Err: Slope &quot; + attr.name);
                    return false;
                }
                break;
            case &#x27;text&#x27;:
                attr = this.boardProperties(gxtEl, element, attr);
                attr = this.colorProperties(element, attr);
                gxtEl = this.coordinates(gxtEl, element);
                attr = this.visualProperties(element, attr);
                res = &#x27;&#x27;;

                try {
                    /*jslint regexp:true*/
                    if (element.getElementsByTagName(&#x27;isLaTeX&#x27;)[0] &amp;&amp; element.getElementsByTagName(&#x27;isLaTeX&#x27;)[0].getAttribute(&#x27;val&#x27;) === &#x27;true&#x27;) {
                        this.board.options.text.useASCIIMathML = true;
                        t = this.getElement(attr.name, true).getAttribute(&#x27;exp&#x27;);

                        // here we&#x27;re searching for patterns like
                        //    &quot; + ... + &quot;
                        // ... will be sent to the ggbParser and a calculated text element is built from this.
                        rx = t.match(/(.*?)&quot; \+ (.+) \+ &quot;(.*)/);
                        while (rx) {
                            re2 = this.ggbParse(RegExp.$2);
                            if (typeof re2 === &#x27;string&#x27;) {
                                res = res + RegExp.$1 + re2;
                            } else {
                                res = res + RegExp.$1 + &#x27;&quot; + JXG.trimNumber((&#x27; + re2 + &#x27;).toFixed(&#x27; + this.decimals + &#x27;)) + &quot;&#x27;;
                            }
                            t = RegExp.$3;

                            rx = t.match(/(.*?)&quot; \+ (.+) \+ &quot;(.*)/);
                        }

                        // we have to look, if the string&#x27;s ending with a string-part or a formula part:
                        rx = t.match(/(.*?)&quot; \+ (.+)/);
                        if (rx) {
                            res = res + RegExp.$1 + &#x27;&quot; + JXG.trimNumber((&#x27; + this.ggbParse(RegExp.$2) + &#x27;).toFixed(&#x27; + this.decimals + &#x27;))&#x27;;
                        } else {
                            res = res + t;
                        }

                        JXG.debug(&quot;Text: &quot; + res);

                        // res is verified by ggbParse
                        /*jslint evil:true*/
                        p = this.board.create(&#x27;text&#x27;, [gxtEl.x, gxtEl.y, new Function(&#x27;return &#x27; + res + &#x27;;&#x27;)], attr);
                        /*jslint evil:false, regexp:false*/
                    } else {
                        JXG.debug(this.getElement(attr.name, true).getAttribute(&#x27;exp&#x27;));
                        t = this.functionParse(false, this.getElement(attr.name, true).getAttribute(&#x27;exp&#x27;));
                        t = this.ggbParse(t);
                        JXG.debug(t[1]);

                        if (JXG.isArray(t)) {
                            // input string is verified by ggbParse
                            /*jslint evil:true*/
                            p = this.board.create(&#x27;text&#x27;, [gxtEl.x, gxtEl.y, new Function(&#x27;return &#x27; + t[0] + &#x27; + &quot; &quot; + JXG.trimNumber(parseFloat(&#x27; + t[1] + &#x27;).toFixed(&#x27; + this.decimals + &#x27;));&#x27;) ], attr);
                            /*jslint evil:false*/
                        } else {
                            p = this.board.create(&#x27;text&#x27;, [gxtEl.x, gxtEl.y, t], attr);
                        }
                    }
                    JXG.debug(&quot;* Text: &quot; + t);
                    return p;
                } catch (exc32) {
                    JXG.debug(&quot;* Err: Text: &quot; + t, exc32, exc32.stack);
                    return false;
                }
                break;
            case &#x27;root&#x27;:
                attr = this.boardProperties(gxtEl, element, attr);
                attr = this.colorProperties(element, attr);
                gxtEl = this.coordinates(gxtEl, element);
                attr = this.visualProperties(element, attr);

                for (i = 0; i &lt; output.length; i++) {
                    output[i] = this.checkElement(output[i].getAttribute(&#x27;label&#x27;));
                }

                if (JXG.isArray(input)) {
                    inp = input[0];
                } else {
                    inp = input;
                }

                // At this point, the output points already exist.
                // Bind the root function to all output elements.
                // The start values for all output elements are the x-coordinates as given
                // in the ggb file.
                for (i = 0; i &lt; output.length; i++) {
                    output[i].addConstraint([
                        makeRootFun(output[i].X()),
                        makeConstFun(0)
                    ]);
                }
                // What to return here????
                return output;
            case &#x27;integral&#x27;:
                attr = this.boardProperties(gxtEl, element, attr);
                attr = this.colorProperties(element, attr);
                gxtEl = this.coordinates(gxtEl, element);
                attr = this.visualProperties(element, attr);

                try {
                    JXG.debug(&quot;* Integral: First: &quot; + input[0].name + &quot;, Sec.: &quot; + input[1].name + &quot;, Thir.: &quot; + input[2].name);
                    JXG.debug([input[1](), input[2]()]);
                    p = this.board.create(&#x27;integral&#x27;, [this.board.select(input[0]), [input[1], input[2]]], attr);
                    return p;
                } catch (exc33) {
                    JXG.debug(&quot;* Err: Integral &quot; + attr.name + e);
                    return false;
                }
                break;

//    case &#x27;transform&#x27;:
//    break;
//    case &#x27;radius&#x27;:
//    break;
//    case &#x27;derivative&#x27;:
//    break;
//    case &#x27;root&#x27;:
//    break;
//    case &#x27;corner&#x27;:
//    break;
//    case &#x27;unitvector&#x27;:
//    break;
//    case &#x27;extremum&#x27;:
//    break;
//    case &#x27;turningpoint&#x27;:
//    break;
//    case &#x27;arc&#x27;:
//    break;
//    case &#x27;circlepart&#x27;:
//    break;
//    case &#x27;uppersum&#x27;:
//    break;
//    case &#x27;lowersum&#x27;:
//    break;
//    case &#x27;image&#x27;:
//    break;
            default:
                return false;
            }
        },

        /**
         * Reading the elements of a geogebra file
         */
        read: function () {
            var type, constructions, el, Data, i, t, s, expr, cmds, input, output, elname, elements;

            this.writeBoard();

            // board won&#x27;t be overwritten, setDefaultOptions returns the board reference given to it.
            this.setDefaultOptions();

            // speeding up the drawing process
            //this.board.suspendUpdate();

            constructions = this.tree.getElementsByTagName(&quot;construction&quot;);
            for (t = 0; t &lt; constructions.length; t++) {

                cmds = constructions[t].getElementsByTagName(&quot;command&quot;);
                for (s = 0; s &lt; cmds.length; s++) {
                    Data = cmds[s];

                    JXG.debug(&#x27;now i\&#x27;ll parse the command:&#x27;);
                    JXG.debug(Data);

                    input = [];
                    for (i = 0; i &lt; Data.getElementsByTagName(&quot;input&quot;)[0].attributes.length; i++) {
                        el = Data.getElementsByTagName(&quot;input&quot;)[0].attributes[i].value;
                        if (el.match(/\u00B0/) || !el.match(/\D/) || el.match(/Circle/) || Data.getAttribute(&#x27;name&#x27;) === &#x27;Function&#x27; || el === parseFloat(el)) {
                            input[i] = el;
                        } else if (el === &#x27;xAxis&#x27; || el === &#x27;yAxis&#x27;) {
                            input[i] = this.ggbElements[el];
                        } else {
                            input[i] = this.checkElement(el);
                        }
                    }

                    output = [];
                    elname = Data.getElementsByTagName(&quot;output&quot;)[0].attributes[0].value;

                    for (i = 0; i &lt; Data.getElementsByTagName(&quot;output&quot;)[0].attributes.length; i++) {
                        el = Data.getElementsByTagName(&quot;output&quot;)[0].attributes[i].value;
                        output[i] = this.getElement(el);
                    }

                    if (!JXG.exists(this.ggbElements[elname]) || this.ggbElements[elname] === &#x27;&#x27;) {
                        this.ggbElements[elname] = this.writeElement(output, input, Data.getAttribute(&#x27;name&#x27;).toLowerCase());

                        /* register borders to according &quot;parent&quot; */
                        if (this.ggbElements[elname].borders) {
                            for (i = 0; i &lt; this.ggbElements[elname].borders.length; i++) {
                                this.ggbElements[this.ggbElements[elname].borders[i].name] = this.ggbElements[elname].borders[i];
                            }
                        }
                    }
                }

                JXG.debug(&#x27;Restesammler: &#x27;);
                // create &quot;single&quot; elements which do not depend on any other
                elements = constructions[t].getElementsByTagName(&quot;element&quot;);
                for (s = 0; s &lt; elements.length; s++) {
                    Data = elements[s];
                    el = Data.getAttribute(&#x27;label&#x27;);

                    if (!JXG.exists(this.ggbElements[el]) || this.ggbElements === &#x27;&#x27;) {
                        this.ggbElements[el] = this.writeElement(Data);

                        expr = this.getElement(el, true);
                        if (expr) {
                            type = Data.getAttribute(&#x27;type&#x27;);

                            switch (type) {
                            case &#x27;text&#x27;:
                            case &#x27;function&#x27;:
                                // this.ggbElements[el] = this.writeElement(this.ggbElements, this.board, expr, false, type);
                                break;
                            default:
                                this.ggbParse(expr.getAttribute(&#x27;exp&#x27;), el);
                                break;
                            }
                        }

                    }
                }

            } // end: for construction

            // speeding up the drawing process
            this.board.unsuspendUpdate();
            this.board.fullUpdate();
        },

        /**
         * Clean the utf8-symbols in a Geogebra expression in JavaScript syntax
         * @param {String} exp string to clean
         * @return {String} replaced string
         */
        utf8replace: function (exp) {
            exp = exp.replace(/\u03C0/g, &#x27;PI&#x27;)
                .replace(/\u00B2/g, &#x27;^2&#x27;)
                .replace(/\u00B3/g, &#x27;^3&#x27;)
                .replace(/\u225F/g, &#x27;==&#x27;)
                .replace(/\u2260/g, &#x27;!=&#x27;)
                .replace(/\u2264/g, &#x27;&lt;=&#x27;)
                .replace(/\u2265/g, &#x27;&gt;=&#x27;)
                .replace(/\u2227/g, &#x27;&amp;&amp;&#x27;)
                .replace(/\u2228/g, &#x27;//&#x27;);

            return exp;
        },

        /**
         * Extracting the packed geogebra file in order to return the &quot;blank&quot; xml-tree for further parsing.
         * @param {String} fileStr archive containing geogebra.xml-file or raw input string (eg. xml-tree)
         * @return {String} content of geogebra.xml-file if an archive was passed in
         */
        prepareString: function (fileStr) {
            var i, bA, len, fstr,
                isString = fileStr.slice(0, 2) !== &quot;PK&quot;;

            // here we have to deal with two different base64 encoded streams
            // first one: base64 encoded xml (geogebra&#x27;s web export)
            // second one: base64 encoded ggb file, this is our recommendation for an IE &amp; Opera
            // workaround, which can&#x27;t deal with binary data transferred via AJAX.

            if (isString &amp;&amp; fileStr.indexOf(&#x27;&lt;&#x27;) !== 0) {
                // first try to decode assuming we got a base64 encoded ggb file
                fstr = JXG.Util.Base64.decode(fileStr);

                if (fstr.slice(0, 2) !== &quot;PK&quot;) {
                    // ooops, that was no ggb file. try again with utf8 parameter set.
                    fstr = JXG.Util.Base64.decode(fileStr, true);
                }
                fileStr = fstr;
            }

            if (fileStr.indexOf(&#x27;&lt;&#x27;) !== 0) {
                bA = [];
                len = fileStr.length;
                for (i = 0; i &lt; len; i++) {
                    bA[i] = JXG.Util.UTF8.asciiCharCodeAt(fileStr, i);
                }

                // Unzip
                fileStr = (new JXG.Util.Unzip(bA)).unzipFile(&quot;geogebra.xml&quot;);
            }
            fileStr = JXG.Util.UTF8.decode(fileStr);
            fileStr = this.utf8replace(fileStr);

            return fileStr;
        },

        /**
         * Checking if a parameter is a Geogebra vector (array with length 3)
         * @param {Object} v possible Geogebra vector
         * @return {Boolean}
         */
        isGGBVector: function (v) {
            return JXG.isArray(v) &amp;&amp; v.length === 3 &amp;&amp; v[0] === 1;
        }
    });

    JXG.registerReader(JXG.GeogebraReader, [&#x27;ggb&#x27;, &#x27;geogebra&#x27;]);
}());

    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>

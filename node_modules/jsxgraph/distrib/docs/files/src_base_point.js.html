<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src/base/point.js - JSXGraph</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="../assets/js/jsxgraphcore.js"></script>
    <link rel="stylesheet" href="../assets/css/jsxgraph.css">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../assets/css/logo_blue.png" title="JSXGraph" width="117" height="52"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.99.4</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/Angle.html">Angle</a> </li>
                                <li><a href="../classes/Arc.html">Arc</a> </li>
                                <li><a href="../classes/Arrow.html">Arrow</a> </li>
                                <li><a href="../classes/Arrowparallel.html">Arrowparallel</a> </li>
                                <li><a href="../classes/Axis.html">Axis</a> </li>
                                <li><a href="../classes/Bisector.html">Bisector</a> </li>
                                <li><a href="../classes/Bisectorlines.html">Bisectorlines</a> </li>
                                <li><a href="../classes/Button.html">Button</a> </li>
                                <li><a href="../classes/Checkbox.html">Checkbox</a> </li>
                                <li><a href="../classes/Circle.html">Circle</a> </li>
                                <li><a href="../classes/Circumcenter.html">Circumcenter</a> </li>
                                <li><a href="../classes/Circumcircle.html">Circumcircle</a> </li>
                                <li><a href="../classes/CircumcircleArc.html">CircumcircleArc</a> </li>
                                <li><a href="../classes/CircumcircleSector.html">CircumcircleSector</a> </li>
                                <li><a href="../classes/Conic.html">Conic</a> </li>
                                <li><a href="../classes/Curve.html">Curve</a> </li>
                                <li><a href="../classes/Ellipse.html">Ellipse</a> </li>
                                <li><a href="../classes/EventEmitter.html">EventEmitter</a> </li>
                                <li><a href="../classes/Functiongraph.html">Functiongraph</a> </li>
                                <li><a href="../classes/Glider.html">Glider</a> </li>
                                <li><a href="../classes/Grid.html">Grid</a> </li>
                                <li><a href="../classes/Group.html">Group</a> </li>
                                <li><a href="../classes/Hatch.html">Hatch</a> </li>
                                <li><a href="../classes/Hyperbola.html">Hyperbola</a> </li>
                                <li><a href="../classes/Image.html">Image</a> </li>
                                <li><a href="../classes/Incenter.html">Incenter</a> </li>
                                <li><a href="../classes/Incircle.html">Incircle</a> </li>
                                <li><a href="../classes/Inequality.html">Inequality</a> </li>
                                <li><a href="../classes/Input.html">Input</a> </li>
                                <li><a href="../classes/Integral.html">Integral</a> </li>
                                <li><a href="../classes/Intersection.html">Intersection</a> </li>
                                <li><a href="../classes/JXG.html">JXG</a> </li>
                                <li><a href="../classes/JXG.AbstractRenderer.html">JXG.AbstractRenderer</a> </li>
                                <li><a href="../classes/JXG.Board.html">JXG.Board</a> </li>
                                <li><a href="../classes/JXG.C.html">JXG.C</a> </li>
                                <li><a href="../classes/JXG.CanvasRenderer.html">JXG.CanvasRenderer</a> </li>
                                <li><a href="../classes/JXG.Chart.html">JXG.Chart</a> </li>
                                <li><a href="../classes/JXG.Circle.html">JXG.Circle</a> </li>
                                <li><a href="../classes/JXG.Complex.html">JXG.Complex</a> </li>
                                <li><a href="../classes/JXG.Composition.html">JXG.Composition</a> </li>
                                <li><a href="../classes/JXG.Coords.html">JXG.Coords</a> </li>
                                <li><a href="../classes/JXG.CoordsElement.html">JXG.CoordsElement</a> </li>
                                <li><a href="../classes/JXG.Curve.html">JXG.Curve</a> </li>
                                <li><a href="../classes/JXG.GeometryElement.html">JXG.GeometryElement</a> </li>
                                <li><a href="../classes/JXG.Group.html">JXG.Group</a> </li>
                                <li><a href="../classes/JXG.Image.html">JXG.Image</a> </li>
                                <li><a href="../classes/JXG.JSXGraph.html">JXG.JSXGraph</a> </li>
                                <li><a href="../classes/JXG.Line.html">JXG.Line</a> </li>
                                <li><a href="../classes/JXG.Math.html">JXG.Math</a> </li>
                                <li><a href="../classes/JXG.Math.Geometry.html">JXG.Math.Geometry</a> </li>
                                <li><a href="../classes/JXG.Math.Numerics.html">JXG.Math.Numerics</a> </li>
                                <li><a href="../classes/JXG.Math.Poly.html">JXG.Math.Poly</a> </li>
                                <li><a href="../classes/JXG.Math.Poly.Monomial.html">JXG.Math.Poly.Monomial</a> </li>
                                <li><a href="../classes/JXG.Math.Poly.Polynomial.html">JXG.Math.Poly.Polynomial</a> </li>
                                <li><a href="../classes/JXG.Math.Poly.Ring.html">JXG.Math.Poly.Ring</a> </li>
                                <li><a href="../classes/JXG.Math.Quadtree.html">JXG.Math.Quadtree</a> </li>
                                <li><a href="../classes/JXG.Math.Statistics.html">JXG.Math.Statistics</a> </li>
                                <li><a href="../classes/JXG.Math.Symbolic.html">JXG.Math.Symbolic</a> </li>
                                <li><a href="../classes/JXG.NoRenderer.html">JXG.NoRenderer</a> </li>
                                <li><a href="../classes/JXG.Options.html">JXG.Options</a> </li>
                                <li><a href="../classes/JXG.Point.html">JXG.Point</a> </li>
                                <li><a href="../classes/JXG.Polygon.html">JXG.Polygon</a> </li>
                                <li><a href="../classes/JXG.SVGRenderer.html">JXG.SVGRenderer</a> </li>
                                <li><a href="../classes/JXG.Text.html">JXG.Text</a> </li>
                                <li><a href="../classes/JXG.Ticks.html">JXG.Ticks</a> </li>
                                <li><a href="../classes/JXG.Transformation.html">JXG.Transformation</a> </li>
                                <li><a href="../classes/JXG.Turtle.html">JXG.Turtle</a> </li>
                                <li><a href="../classes/JXG.Util.Base64.html">JXG.Util.Base64</a> </li>
                                <li><a href="../classes/JXG.Util.Unzip.html">JXG.Util.Unzip</a> </li>
                                <li><a href="../classes/JXG.VMLRenderer.html">JXG.VMLRenderer</a> </li>
                                <li><a href="../classes/Line.html">Line</a> </li>
                                <li><a href="../classes/Locus.html">Locus</a> </li>
                                <li><a href="../classes/MajorArc.html">MajorArc</a> </li>
                                <li><a href="../classes/Midpoint.html">Midpoint</a> </li>
                                <li><a href="../classes/MinorArc.html">MinorArc</a> </li>
                                <li><a href="../classes/MinorSector.html">MinorSector</a> </li>
                                <li><a href="../classes/Mirrorpoint.html">Mirrorpoint</a> </li>
                                <li><a href="../classes/NonReflexAngle.html">NonReflexAngle</a> </li>
                                <li><a href="../classes/Normal.html">Normal</a> </li>
                                <li><a href="../classes/Orthogonalprojection.html">Orthogonalprojection</a> </li>
                                <li><a href="../classes/OtherIntersection.html">OtherIntersection</a> </li>
                                <li><a href="../classes/Parabola.html">Parabola</a> </li>
                                <li><a href="../classes/Parallel.html">Parallel</a> </li>
                                <li><a href="../classes/Parallelpoint.html">Parallelpoint</a> </li>
                                <li><a href="../classes/Perpendicular.html">Perpendicular</a> </li>
                                <li><a href="../classes/PerpendicularPoint.html">PerpendicularPoint</a> </li>
                                <li><a href="../classes/PerpendicularSegment.html">PerpendicularSegment</a> </li>
                                <li><a href="../classes/Point.html">Point</a> </li>
                                <li><a href="../classes/PolarLine.html">PolarLine</a> </li>
                                <li><a href="../classes/PolePoint.html">PolePoint</a> </li>
                                <li><a href="../classes/Polygon.html">Polygon</a> </li>
                                <li><a href="../classes/RadicalAxis.html">RadicalAxis</a> </li>
                                <li><a href="../classes/Reflection.html">Reflection</a> </li>
                                <li><a href="../classes/ReflexAngle.html">ReflexAngle</a> </li>
                                <li><a href="../classes/registerReader.html">registerReader</a> </li>
                                <li><a href="../classes/RegularPolygon.html">RegularPolygon</a> </li>
                                <li><a href="../classes/Riemannsum.html">Riemannsum</a> </li>
                                <li><a href="../classes/Sector.html">Sector</a> </li>
                                <li><a href="../classes/Segment.html">Segment</a> </li>
                                <li><a href="../classes/Semicircle.html">Semicircle</a> </li>
                                <li><a href="../classes/Slider.html">Slider</a> </li>
                                <li><a href="../classes/Slopetriangle.html">Slopetriangle</a> </li>
                                <li><a href="../classes/Spline.html">Spline</a> </li>
                                <li><a href="../classes/Stepfunction.html">Stepfunction</a> </li>
                                <li><a href="../classes/Tangent.html">Tangent</a> </li>
                                <li><a href="../classes/Tapemeasure.html">Tapemeasure</a> </li>
                                <li><a href="../classes/Text.html">Text</a> </li>
                                <li><a href="../classes/Ticks.html">Ticks</a> </li>
                                <li><a href="../classes/Tracecurve.html">Tracecurve</a> </li>
                                <li><a href="../classes/Transformation.html">Transformation</a> </li>
                                <li><a href="../classes/Turtle.html">Turtle</a> </li>
                            </ul>
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="../modules/JXG.html">JXG</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: src/base/point.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/*
    Copyright 2008-2015
        Matthias Ehmann,
        Michael Gerhaeuser,
        Carsten Miller,
        Bianca Valentin,
        Alfred Wassermann,
        Peter Wilfahrt

    This file is part of JSXGraph.

    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.

    You can redistribute it and/or modify it under the terms of the

      * GNU Lesser General Public License as published by
        the Free Software Foundation, either version 3 of the License, or
        (at your option) any later version
      OR
      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT

    JSXGraph is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License and
    the MIT License along with JSXGraph. If not, see &lt;http://www.gnu.org/licenses/&gt;
    and &lt;http://opensource.org/licenses/MIT/&gt;.
 */


/*global JXG: true, define: true, console: true, window: true*/
/*jslint nomen: true, plusplus: true*/

/* depends:
 jxg
 options
 math/math
 math/geometry
 math/numerics
 base/coords
 base/constants
 base/element
 parser/geonext
 utils/type
  elements:
   transform
 */

/**
 * @fileoverview The geometry object Point is defined in this file. Point stores all
 * style and functional properties that are required to draw and move a point on
 * a board.
 */

define([
    &#x27;jxg&#x27;, &#x27;options&#x27;, &#x27;math/math&#x27;, &#x27;math/geometry&#x27;, &#x27;math/numerics&#x27;, &#x27;base/coords&#x27;, &#x27;base/constants&#x27;, &#x27;base/element&#x27;,
    &#x27;parser/geonext&#x27;, &#x27;utils/type&#x27;, &#x27;base/transformation&#x27;, &#x27;base/coordselement&#x27;
], function (JXG, Options, Mat, Geometry, Numerics, Coords, Const, GeometryElement, GeonextParser, Type, Transform, CoordsElement) {

    &quot;use strict&quot;;

    /**
     * A point is the basic geometric element. Based on points lines and circles can be constructed which can be intersected
     * which in turn are points again which can be used to construct new lines, circles, polygons, etc. This class holds methods for
     * all kind of points like free points, gliders, and intersection points.
     *
     * Creates a new point object. Do not use this constructor to create a point. Use {@link JXG.Board#create} with
     * type {@link Point}, {@link Glider}, or {@link Intersection} instead.
     *
     * @class JXG.Point
     * @extends JXG.CoordsElement
     * @param {string|JXG.Board} board The board the new point is drawn on.
     * @param {Array} coordinates An array with the user coordinates of the point.
     * @param {Object} attributes An object containing visual properties like in {@link JXG.Options#point} and
     * {@link JXG.Options#elements}, and optional a name and an id.
     * @see JXG.Board#generateName
     */
    JXG.Point = function (board, coordinates, attributes) {
        this.constructor(board, attributes, Const.OBJECT_TYPE_POINT, Const.OBJECT_CLASS_POINT);

        /**
         * Anchor element which define the origin for the relative coordinates.
         * If defined the coordinates of the point are relative coordinates.
         *
         * @property element
         * @type {JXG.CoordsElement}
         * @private
         */
        this.element = this.board.select(attributes.anchor);

        this.coordsConstructor(coordinates);

        this.elType = &#x27;point&#x27;;

        /* Register point at board. */
        this.id = this.board.setId(this, &#x27;P&#x27;);
        this.board.renderer.drawPoint(this);
        this.board.finalizeAdding(this);

        this.createLabel();
    };

    /**
     * Inherits here from {@link JXG.GeometryElement}.
     */
    JXG.Point.prototype = new GeometryElement();
    Type.copyPrototypeMethods(JXG.Point, CoordsElement, &#x27;coordsConstructor&#x27;);

    JXG.extend(JXG.Point.prototype, /** @lends JXG.Point.prototype */ {
        /**
         * Checks whether (x,y) is near the point.
         *
         * @method hasPoint
         * @param {Number} x Coordinate in x direction, screen coordinates.
         * @param {Number} y Coordinate in y direction, screen coordinates.
         * @return {Boolean} True if (x,y) is near the point, False otherwise.
         * @private
         */
        hasPoint: function (x, y) {
            var coordsScr = this.coords.scrCoords, r;
            r = parseFloat(this.visProp.size) + parseFloat(this.visProp.strokewidth) * 0.5;
            if (r &lt; this.board.options.precision.hasPoint) {
                r = this.board.options.precision.hasPoint;
            }

            return ((Math.abs(coordsScr[1] - x) &lt; r + 2) &amp;&amp; (Math.abs(coordsScr[2] - y) &lt; r + 2));
        },

        // Documented in GeometryElement
        update: function (fromParent) {
            if (!this.needsUpdate) {
                return this;
            }

            this.updateCoords(fromParent);

            if (this.visProp.trace) {
                this.cloneToBackground(true);
            }

            return this;
        },

         // Documented in GeometryElement
        updateTransform: function () {
            var c, i;

            if (this.transformations.length === 0 || this.baseElement === null) {
                return this;
            }

            // case of bindTo
            if (this === this.baseElement) {
                c = this.transformations[0].apply(this.baseElement, &#x27;self&#x27;);
            // case of board.create(&#x27;point&#x27;,[baseElement,transform]);
            } else {
                c = this.transformations[0].apply(this.baseElement);
            }

            this.coords.setCoordinates(Const.COORDS_BY_USER, c);

            for (i = 1; i &lt; this.transformations.length; i++) {
                this.coords.setCoordinates(Const.COORDS_BY_USER, this.transformations[i].apply(this));
            }
            return this;
        },

        // Documented in GeometryElement
        updateRenderer: function () {
            if (this.visProp.size &gt; 0) {
                this.updateRendererGeneric(&#x27;updatePoint&#x27;);
            }
            return this;
        },

        // documented in JXG.GeometryElement
        bounds: function () {
            return this.coords.usrCoords.slice(1).concat(this.coords.usrCoords.slice(1));
        },

        /**
         * Convert the point into an intersection point and update the construction.
         * To move the point visual onto the intersection, a subsequent call of board update is necessary.
         * Uses &#x60;addConstraint&#x60; to set the defining functions for this point.
         *
         * @method makeIntersection
         * @param {String|JXG.GeometryElement} el1 First object to be intersected
         * @param {String|JXG.GeometryElement} el2 Second object to be intersected
         * @param {Number} i The ith intersection point between &#x60;el1&#x60; and &#x60;el2&#x60; is determined
         * @param {Number} j Unused
         * @return {JXG.Point} Reference to the point object.
         * @chainable
         **/
        makeIntersection: function (el1, el2, i, j) {
            var func;

            el1 = this.board.select(el1);
            el2 = this.board.select(el2);

            func = Geometry.intersectionFunction(this.board, el1, el2, i, j, this.visProp.alwaysintersect);
            this.addConstraint([func]);

            try {
                el1.addChild(this);
                el2.addChild(this);
            } catch (e) {
                throw new Error(&quot;JSXGraph: Can&#x27;t create &#x27;intersection&#x27; with parent types &#x27;&quot; +
                    (typeof el1) + &quot;&#x27; and &#x27;&quot; + (typeof el2) + &quot;&#x27;.&quot;);
            }

            this.type = Const.OBJECT_TYPE_INTERSECTION;
            this.elType = &#x27;intersection&#x27;;
            this.parents = [el1.id, el2.id, i, j];

            this.generatePolynomial = function () {
                var poly1 = el1.generatePolynomial(this),
                    poly2 = el2.generatePolynomial(this);

                if ((poly1.length === 0) || (poly2.length === 0)) {
                    return [];
                }

                return [poly1[0], poly2[0]];
            };

            this.prepareUpdate().update();

            return this;
        },

        /**
         * Set the style of a point.
         * Used for GEONExT import and should not be used to set the point&#x27;s face and size.
         *
         * @method setStyle
         * @param {Number} i Integer to determine the style.
         * @private
         * @return {JXG.Point} Reference to the point object.
         * @chainable
         */
        setStyle: function (i) {
            var facemap = [
                // 0-2
                &#x27;cross&#x27;, &#x27;cross&#x27;, &#x27;cross&#x27;,
                // 3-6
                &#x27;circle&#x27;, &#x27;circle&#x27;, &#x27;circle&#x27;, &#x27;circle&#x27;,
                // 7-9
                &#x27;square&#x27;, &#x27;square&#x27;, &#x27;square&#x27;,
                // 10-12
                &#x27;plus&#x27;, &#x27;plus&#x27;, &#x27;plus&#x27;
            ], sizemap = [
                // 0-2
                2, 3, 4,
                // 3-6
                1, 2, 3, 4,
                // 7-9
                2, 3, 4,
                // 10-12
                2, 3, 4
            ];

            this.visProp.face = facemap[i];
            this.visProp.size = sizemap[i];

            this.board.renderer.changePointStyle(this);
            return this;
        },

        /**
         * Use JXG#normalizePointFace instead
         *
         * @method normalizeFace
         * @deprecated
         * @param s
         * @return {*}
         */
        normalizeFace: function (s) {
            JXG.deprecated(&#x27;Point.normalizeFace()&#x27;, &#x27;JXG.normalizePointFace()&#x27;);
            return Options.normalizePointFace(s);
        },

        /**
         * Set the face of a point element. Use &#x60;setAttribute()&#x60;&#x60; instead.
         *
         * @method face
         * @param {String} f String which determines the face of the point. See {@link JXG.GeometryElement#face} for a list of available faces.
         * @see JXG.GeometryElement#face
         * @deprecated
         */
        face: function (f) {
            JXG.deprecated(&#x27;Point.face()&#x27;, &#x27;Point.setAttribute()&#x27;);
            this.setAttribute({face: f});
        },

        /**
         * Set the size of a point element. Use &#x60;setAttribute()&#x60; instead.
         *
         * @method size
         * @param {Number} s Integer which determines the size of the point.
         * @see JXG.GeometryElement#size
         * @deprecated
         */
        size: function (s) {
            JXG.deprecated(&#x27;Point.size()&#x27;, &#x27;Point.setAttribute()&#x27;);
            this.setAttribute({size: s});
        },

        // already documented in GeometryElement
        cloneToBackground: function () {
            var copy = {};

            copy.id = this.id + &#x27;T&#x27; + this.numTraces;
            this.numTraces += 1;

            copy.coords = this.coords;
            copy.visProp = Type.deepCopy(this.visProp, this.visProp.traceattributes, true);
            copy.visProp.layer = this.board.options.layer.trace;
            copy.elementClass = Const.OBJECT_CLASS_POINT;
            copy.board = this.board;
            Type.clearVisPropOld(copy);

            this.board.renderer.drawPoint(copy);
            this.traces[copy.id] = copy.rendNode;

            return this;
        }
    });


    /**
     * This element is used to provide a constructor for a general point. A free point is created if the given parent elements are all numbers
     * and the property fixed is not set or set to false. If one or more parent elements is not a number but a string containing a GEONE&lt;sub&gt;x&lt;/sub&gt;T
     * constraint or a function the point will be considered as constrained). That means that the user won&#x27;t be able to change the point&#x27;s
     * position directly.
     *
     * @pseudo
     * @class  Point
     * @extends JXG.Point
     * @constructor
     * @type JXG.Point
     * @throws {Exception} If the element cannot be constructed with the given parent objects an exception is thrown.
     * @param {Number,string,function_Number,string,function_Number,string,function} z_,x,y Parent elements can be two or three elements of type number, a string containing a GEONE&lt;sub&gt;x&lt;/sub&gt;T
     * constraint, or a function which takes no parameter and returns a number. Every parent element determines one coordinate. If a coordinate is
     * given by a number, the number determines the initial position of a free point. If given by a string or a function that coordinate will be constrained
     * that means the user won&#x27;t be able to change the point&#x27;s position directly by mouse because it will be calculated automatically depending on the string
     * or the function&#x27;s return value. If two parent elements are given the coordinates will be interpreted as 2D affine Euclidean coordinates, if three such
     * parent elements are given they will be interpreted as homogeneous coordinates.
     * @param {JXG.Point_JXG.Transformation} Point,Transformation A point can also be created providing a transformation.
     * The resulting point is a clone of the base
     * point transformed by the given Transformation. {@see JXG.Transformation}.
     *
     * @example
     *
     *     // Create a free point using affine euclidean coordinates
     *     var p1 = board.create(&#x27;point&#x27;, [3.5, 2.0]);
     * &lt;div id=&quot;672f1764-7dfa-4abc-a2c6-81fbbf83e44b&quot; style=&quot;width: 200px; height: 200px;&quot;&gt;&lt;/div&gt;
     * &lt;script type=&quot;text/javascript&quot;&gt;
     * (function(){
     *   var board = JXG.JSXGraph.initBoard(&#x27;672f1764-7dfa-4abc-a2c6-81fbbf83e44b&#x27;, {boundingbox: [-1, 5, 5, -1], axis: true, showcopyright: false, shownavigation: false});
     *   var p1 = board.create(&#x27;point&#x27;, [3.5, 2.0]);
     * })();
     * &lt;/script&gt;
     *
     * @example
     *
     *     // Create a constrained point using anonymous function
     *     var p2 = board.create(&#x27;point&#x27;, [3.5, function () { return p1.X(); }]);
     * &lt;div id=&quot;4fd4410c-3383-4e80-b1bb-961f5eeef224&quot; style=&quot;width: 200px; height: 200px;&quot;&gt;&lt;/div&gt;
     * &lt;script type=&quot;text/javascript&quot;&gt;
     * (function(){
     *   var board = JXG.JSXGraph.initBoard(&#x27;4fd4410c-3383-4e80-b1bb-961f5eeef224&#x27;, {boundingbox: [-1, 5, 5, -1], axis: true, showcopyright: false, shownavigation: false});
     *   var p1 = board.create(&#x27;point&#x27;, [3.5, 2.0]);
     *   var p2 = board.create(&#x27;point&#x27;, [3.5, function () { return p1.X(); }]);
     * })();
     * &lt;/script&gt;
     *
     * @example
     *     // Create a point using transformations
     *     var trans = board.create(&#x27;transform&#x27;, [2, 0.5], {type:&#x27;scale&#x27;});
     *     var p3 = board.create(&#x27;point&#x27;, [p2, trans]);
     * &lt;div id=&quot;630afdf3-0a64-46e0-8a44-f51bd197bb8d&quot; style=&quot;width: 400px; height: 400px;&quot;&gt;&lt;/div&gt;
     * &lt;script type=&quot;text/javascript&quot;&gt;
     * (function(){
     *   var board = JXG.JSXGraph.initBoard(&#x27;630afdf3-0a64-46e0-8a44-f51bd197bb8d&#x27;, {boundingbox: [-1, 9, 9, -1], axis: true, showcopyright: false, shownavigation: false});
     *   var trans = board.create(&#x27;transform&#x27;, [2, 0.5], {type:&#x27;scale&#x27;});
     *   var p2 = board.create(&#x27;point&#x27;, [3.5, 2.0]);
     *   var p3 = board.create(&#x27;point&#x27;, [p2, trans]);
     * })();
     * &lt;/script&gt;
     */
    JXG.createPoint = function (board, parents, attributes) {
        var el, attr;

        attr = Type.copyAttributes(attributes, board.options, &#x27;point&#x27;);
        el = CoordsElement.create(JXG.Point, board, parents, attr);
        if (!el) {
            throw new Error(&quot;JSXGraph: Can&#x27;t create point with parent types &#x27;&quot; +
                    (typeof parents[0]) + &quot;&#x27; and &#x27;&quot; + (typeof parents[1]) + &quot;&#x27;.&quot; +
                    &quot;\nPossible parent types: [x,y], [z,x,y], [element,transformation]&quot;);
        }

        return el;
    };

    /**
     * This element is used to provide a constructor for a glider point.
     * A glider is a point which lives on another geometric element like a line, circle, curve, turtle.
     *
     * @pseudo
     * @class Glider
     * @extends JXG.Point
     * @constructor
     * @type JXG.Point
     * @throws {Exception} If the element cannot be constructed with the given parent objects an exception is thrown.
     * @param {Number_Number_Number_JXG.GeometryElement} z_,x_,y_,GlideObject Parent elements can be two or three elements of type number and the object the glider lives on.
     * The coordinates are completely optional. If not given the origin is used. If you provide two numbers for coordinates they will be interpreted as affine euclidean
     * coordinates, otherwise they will be interpreted as homogeneous coordinates. In any case the point will be projected on the glide object.
     *
     * @example
     *
     *     // Create a glider with user defined coordinates. If the coordinates are not on
     *     // the circle (like in this case) the point will be projected onto the circle.
     *     var p1 = board.create(&#x27;point&#x27;, [2.0, 2.0]);
     *     var c1 = board.create(&#x27;circle&#x27;, [p1, 2.0]);
     *     var p2 = board.create(&#x27;glider&#x27;, [2.0, 1.5, c1]);
     * &lt;div id=&quot;4f65f32f-e50a-4b50-9b7c-f6ec41652930&quot; style=&quot;width: 300px; height: 300px;&quot;&gt;&lt;/div&gt;
     * &lt;script type=&quot;text/javascript&quot;&gt;
     * (function(){
     *   var board = JXG.JSXGraph.initBoard(&#x27;4f65f32f-e50a-4b50-9b7c-f6ec41652930&#x27;, {boundingbox: [-1, 5, 5, -1], axis: true, showcopyright: false, shownavigation: false});
     *   var p1 = board.create(&#x27;point&#x27;, [2.0, 2.0]);
     *   var c1 = board.create(&#x27;circle&#x27;, [p1, 2.0]);
     *   var p2 = board.create(&#x27;glider&#x27;, [2.0, 1.5, c1]);
     *  })();
     * &lt;/script&gt;
     * @example
     *     // Create a glider with default coordinates (1,0,0). Same premises as above.
     *     var p1 = board.create(&#x27;point&#x27;, [2.0, 2.0]);
     *     var c1 = board.create(&#x27;circle&#x27;, [p1, 2.0]);
     *     var p2 = board.create(&#x27;glider&#x27;, [c1]);
     * &lt;div id=&quot;4de7f181-631a-44b1-a12f-bc4d995609e8&quot; style=&quot;width: 200px; height: 200px;&quot;&gt;&lt;/div&gt;
     * &lt;script type=&quot;text/javascript&quot;&gt;
     * (function(){
     *   var board = JXG.JSXGraph.initBoard(&#x27;4de7f181-631a-44b1-a12f-bc4d995609e8&#x27;, {boundingbox: [-1, 5, 5, -1], axis: true, showcopyright: false, shownavigation: false});
     *   var p1 = board.create(&#x27;point&#x27;, [2.0, 2.0]);
     *   var c1 = board.create(&#x27;circle&#x27;, [p1, 2.0]);
     *   var p2 = board.create(&#x27;glider&#x27;, [c1]);
     *  })();
     * &lt;/script&gt;
     */
    JXG.createGlider = function (board, parents, attributes) {
        var el, coords,
            attr = Type.copyAttributes(attributes, board.options, &#x27;glider&#x27;);

        if (parents.length === 1) {
            coords = [0, 0];
        } else {
            coords = parents.slice(0, 2);
        }
        el = board.create(&#x27;point&#x27;, coords, attr);

        // eltype is set in here
        el.makeGlider(parents[parents.length - 1]);

        return el;
    };


    /**
     * This element is used to provide a constructor for an intersection point.
     *
     * An intersection point is a point which lives on two Lines or Circles or one Line and one Circle at the same time, i.e.
     * an intersection point of the two elements.
     *
     * @pseudo
     * @class Intersection
     * @extends JXG.Point
     * @constructor
     * @type JXG.Point
     * @throws {Exception} If the element cannot be constructed with the given parent objects an exception is thrown.
     * @param {JXG.Line,JXG.Circle_JXG.Line,JXG.Circle_Number} el1,el2,i The result will be a intersection point on el1 and el2. i determines the
     * intersection point if two points are available: &lt;ul&gt;
     *   &lt;li&gt;i==0: use the positive square root,&lt;/li&gt;
     *   &lt;li&gt;i==1: use the negative square root.&lt;/li&gt;&lt;/ul&gt;
     *
     * @example
     *     // Create an intersection point of circle and line
     *     var p1 = board.create(&#x27;point&#x27;, [2.0, 2.0]);
     *     var c1 = board.create(&#x27;circle&#x27;, [p1, 2.0]);
     *
     *     var p2 = board.create(&#x27;point&#x27;, [2.0, 2.0]);
     *     var p3 = board.create(&#x27;point&#x27;, [2.0, 2.0]);
     *     var l1 = board.create(&#x27;line&#x27;, [p2, p3]);
     *
     *     var i = board.create(&#x27;intersection&#x27;, [c1, l1, 0]);
     * &lt;div id=&quot;e5b0e190-5200-4bc3-b995-b6cc53dc5dc0&quot; style=&quot;width: 300px; height: 300px;&quot;&gt;&lt;/div&gt;
     * &lt;script type=&quot;text/javascript&quot;&gt;
     * (function(){
     *   var board = JXG.JSXGraph.initBoard(&#x27;e5b0e190-5200-4bc3-b995-b6cc53dc5dc0&#x27;, {boundingbox: [-1, 7, 7, -1], axis: true, showcopyright: false, shownavigation: false});
     *   var p1 = board.create(&#x27;point&#x27;, [4.0, 4.0]);
     *   var c1 = board.create(&#x27;circle&#x27;, [p1, 2.0]);
     *   var p2 = board.create(&#x27;point&#x27;, [1.0, 1.0]);
     *   var p3 = board.create(&#x27;point&#x27;, [5.0, 3.0]);
     *   var l1 = board.create(&#x27;line&#x27;, [p2, p3]);
     *   var i = board.create(&#x27;intersection&#x27;, [c1, l1, 0]);
     *  })();
     * &lt;/script&gt;
     */
    JXG.createIntersectionPoint = function (board, parents, attributes) {
        var el, el1, el2, func, i, j,
            attr = Type.copyAttributes(attributes, board.options, &#x27;intersection&#x27;);

        // make sure we definitely have the indices
        parents.push(0, 0);

        el1 = board.select(parents[0]);
        el2 = board.select(parents[1]);

        i = parents[2] || 0;
        j = parents[3] || 0;

        el = board.create(&#x27;point&#x27;, [0, 0, 0], attr);

        func = Geometry.intersectionFunction(board, el1, el2, i, j, el.visProp.alwaysintersect);
        el.addConstraint([func]);

        try {
            el1.addChild(el);
            el2.addChild(el);
        } catch (e) {
            throw new Error(&quot;JSXGraph: Can&#x27;t create &#x27;intersection&#x27; with parent types &#x27;&quot; +
                (typeof parents[0]) + &quot;&#x27; and &#x27;&quot; + (typeof parents[1]) + &quot;&#x27;.&quot;);
        }

        el.type = Const.OBJECT_TYPE_INTERSECTION;
        el.elType = &#x27;intersection&#x27;;
        el.setParents([el1.id, el2.id]);

        /**
         * Array of length 2 containing the numbers i and j.
         * The intersection point is i-th intersection point.
         * j is unused.
         * @type Array
         * @private
         */
        el.intersectionNumbers = [i, j];
        el.getParents = function() {
            return this.parents.concat(this.intersectionNumbers);
        };

        el.generatePolynomial = function () {
            var poly1 = el1.generatePolynomial(el),
                poly2 = el2.generatePolynomial(el);

            if ((poly1.length === 0) || (poly2.length === 0)) {
                return [];
            }

            return [poly1[0], poly2[0]];
        };

        return el;
    };

    /**
     * This element is used to provide a constructor for the &quot;other&quot; intersection point.
     * An intersection point is a point which lives on two
     * lines or circles or one line and one circle at the same time, i.e.
     * an intersection point of the two elements.
     *
     * Additionally, one intersection point is provided.
     * The function returns the other intersection point.
     *
     * @pseudo
     * @description
     * @class OtherIntersection
     * @extends JXG.Point
     * @constructor
     * @type JXG.Point
     * @throws {Exception} If the element cannot be constructed with the given parent objects an exception is thrown.
     * @param {JXG.Line,JXG.Circle_JXG.Line,JXG.Circle_JXG.Point} el1,el2,p The result will be a intersection point on el1 and el2. i determines the
     * intersection point different from p.
     *
     * @example
     *     // Create an intersection point of circle and line
     *     var p1 = board.create(&#x27;point&#x27;, [2.0, 2.0]);
     *     var c1 = board.create(&#x27;circle&#x27;, [p1, 2.0]);
     *
     *     var p2 = board.create(&#x27;point&#x27;, [2.0, 2.0]);
     *     var p3 = board.create(&#x27;point&#x27;, [2.0, 2.0]);
     *     var l1 = board.create(&#x27;line&#x27;, [p2, p3]);
     *
     *     var i = board.create(&#x27;intersection&#x27;, [c1, l1, 0]);
     *     var j = board.create(&#x27;otherintersection&#x27;, [c1, l1, i]);
     * &lt;div id=&quot;45e25f12-a1de-4257-a466-27a2ae73614c&quot; style=&quot;width: 300px; height: 300px;&quot;&gt;&lt;/div&gt;
     * &lt;script type=&quot;text/javascript&quot;&gt;
     * (function(){
     *   var board = JXG.JSXGraph.initBoard(&#x27;45e25f12-a1de-4257-a466-27a2ae73614c&#x27;, {boundingbox: [-1, 7, 7, -1], axis: true, showcopyright: false, shownavigation: false});
     *   var p1 = board.create(&#x27;point&#x27;, [4.0, 4.0]);
     *   var c1 = board.create(&#x27;circle&#x27;, [p1, 2.0]);
     *   var p2 = board.create(&#x27;point&#x27;, [1.0, 1.0]);
     *   var p3 = board.create(&#x27;point&#x27;, [5.0, 3.0]);
     *   var l1 = board.create(&#x27;line&#x27;, [p2, p3]);
     *   var i = board.create(&#x27;intersection&#x27;, [c1, l1, 0], {name:&#x27;D&#x27;});
     *   var j = board.create(&#x27;otherintersection&#x27;, [c1, l1, i], {name:&#x27;E&#x27;});
     *  })();
     * &lt;/script&gt;
     */
    JXG.createOtherIntersectionPoint = function (board, parents, attributes) {
        var el, el1, el2, other;

        if (parents.length !== 3 ||
                !Type.isPoint(parents[2]) ||
                (parents[0].elementClass !== Const.OBJECT_CLASS_LINE &amp;&amp; parents[0].elementClass !== Const.OBJECT_CLASS_CIRCLE) ||
                (parents[1].elementClass !== Const.OBJECT_CLASS_LINE &amp;&amp; parents[1].elementClass !== Const.OBJECT_CLASS_CIRCLE)) {
            // Failure
            throw new Error(&quot;JSXGraph: Can&#x27;t create &#x27;other intersection point&#x27; with parent types &#x27;&quot; +
                (typeof parents[0]) + &quot;&#x27;,  &#x27;&quot; + (typeof parents[1]) + &quot;&#x27;and  &#x27;&quot; + (typeof parents[2]) + &quot;&#x27;.&quot; +
                &quot;\nPossible parent types: [circle|line,circle|line,point]&quot;);
        }

        el1 = board.select(parents[0]);
        el2 = board.select(parents[1]);
        other = board.select(parents[2]);

        el = board.create(&#x27;point&#x27;, [function () {
            var c = Geometry.meet(el1.stdform, el2.stdform, 0, el1.board);

            if (Math.abs(other.X() - c.usrCoords[1]) &gt; Mat.eps ||
                    Math.abs(other.Y() - c.usrCoords[2]) &gt; Mat.eps ||
                    Math.abs(other.Z() - c.usrCoords[0]) &gt; Mat.eps) {
                return c;
            }

            return Geometry.meet(el1.stdform, el2.stdform, 1, el1.board);
        }], attributes);

        el.type = Const.OBJECT_TYPE_INTERSECTION;
        el.elType = &#x27;otherintersection&#x27;;
        el.setParents([el1.id, el2.id, other]);

        el1.addChild(el);
        el2.addChild(el);

        el.generatePolynomial = function () {
            var poly1 = el1.generatePolynomial(el),
                poly2 = el2.generatePolynomial(el);

            if ((poly1.length === 0) || (poly2.length === 0)) {
                return [];
            }

            return [poly1[0], poly2[0]];
        };

        return el;
    };

    /**
     * This element is used to provide a constructor for the pole point of a line with respect to a conic or a circle.
     *
     * The pole point is the unique reciprocal relationship of a line with respect to a conic.
     * The lines tangent to the intersections of a conic and a line intersect at the pole point of that line with respect to that conic.
     * A line tangent to a conic has the pole point of that line with respect to that conic as the tangent point.
     * See {@link http://en.wikipedia.org/wiki/Pole_and_polar} for more information on pole and polar.
     *
     * @pseudo
     * @class PolePoint
     * @extends JXG.Point
     * @constructor
     * @type JXG.Point
     * @throws {Exception} If the element cannot be constructed with the given parent objects an exception is thrown.
     * @param {JXG.Conic,JXG.Circle_JXG.Point} el1,el2 or
     * @param {JXG.Point_JXG.Conic,JXG.Circle} el1,el2 The result will be the pole point of the line with respect to the conic or the circle.
     * @example
     *     // Create the pole point of a line with respect to a conic
     *     var p1 = board.create(&#x27;point&#x27;, [-1, 2]);
     *     var p2 = board.create(&#x27;point&#x27;, [ 1, 4]);
     *     var p3 = board.create(&#x27;point&#x27;, [-1,-2]);
     *     var p4 = board.create(&#x27;point&#x27;, [ 0, 0]);
     *     var p5 = board.create(&#x27;point&#x27;, [ 4,-2]);
     *     var c1 = board.create(&#x27;conic&#x27;,[p1,p2,p3,p4,p5]);
     *     var p6 = board.create(&#x27;point&#x27;, [-1, 4]);
     *     var p7 = board.create(&#x27;point&#x27;, [2, -2]);
     *     var l1 = board.create(&#x27;line&#x27;, [p6, p7]);
     *     var p8 = board.create(&#x27;polepoint&#x27;, [c1, l1]);
     * &lt;div id=&#x27;7b7233a0-f363-47dd-9df5-8018d0d17a98&#x27; class=&#x27;jxgbox&#x27; style=&#x27;width:400px; height:400px;&#x27;&gt;&lt;/div&gt;
     * &lt;script type=&#x27;text/javascript&#x27;&gt;
     * (function(){
     * var board = JXG.JSXGraph.initBoard(&#x27;7b7233a0-f363-47dd-9df5-8018d0d17a98&#x27;, {boundingbox: [-3, 5, 5, -3], axis: true, showcopyright: false, shownavigation: false});
     * var p1 = board.create(&#x27;point&#x27;, [-1, 2]);
     * var p2 = board.create(&#x27;point&#x27;, [ 1, 4]);
     * var p3 = board.create(&#x27;point&#x27;, [-1,-2]);
     * var p4 = board.create(&#x27;point&#x27;, [ 0, 0]);
     * var p5 = board.create(&#x27;point&#x27;, [ 4,-2]);
     * var c1 = board.create(&#x27;conic&#x27;,[p1,p2,p3,p4,p5]);
     * var p6 = board.create(&#x27;point&#x27;, [-1, 4]);
     * var p7 = board.create(&#x27;point&#x27;, [2, -2]);
     * var l1 = board.create(&#x27;line&#x27;, [p6, p7]);
     * var p8 = board.create(&#x27;polepoint&#x27;, [c1, l1]);
     * })();
     * &lt;/script&gt;
     *
     * @example
     *     // Create the pole point of a line with respect to a circle
     *     var p1 = board.create(&#x27;point&#x27;, [1, 1]);
     *     var p2 = board.create(&#x27;point&#x27;, [2, 3]);
     *     var c1 = board.create(&#x27;circle&#x27;,[p1,p2]);
     *     var p3 = board.create(&#x27;point&#x27;, [-1, 4]);
     *     var p4 = board.create(&#x27;point&#x27;, [4, -1]);
     *     var l1 = board.create(&#x27;line&#x27;, [p3, p4]);
     *     var p5 = board.create(&#x27;polepoint&#x27;, [c1, l1]);
     * &lt;div id=&#x27;7b7233a0-f363-47dd-9df5-9018d0d17a98&#x27; class=&#x27;jxgbox&#x27; style=&#x27;width:400px; height:400px;&#x27;&gt;&lt;/div&gt;
     * &lt;script type=&#x27;text/javascript&#x27;&gt;
     * (function(){
     * var board = JXG.JSXGraph.initBoard(&#x27;7b7233a0-f363-47dd-9df5-9018d0d17a98&#x27;, {boundingbox: [-3, 7, 7, -3], axis: true, showcopyright: false, shownavigation: false});
     * var p1 = board.create(&#x27;point&#x27;, [1, 1]);
     * var p2 = board.create(&#x27;point&#x27;, [2, 3]);
     * var c1 = board.create(&#x27;circle&#x27;,[p1,p2]);
     * var p3 = board.create(&#x27;point&#x27;, [-1, 4]);
     * var p4 = board.create(&#x27;point&#x27;, [4, -1]);
     * var l1 = board.create(&#x27;line&#x27;, [p3, p4]);
     * var p5 = board.create(&#x27;polepoint&#x27;, [c1, l1]);
     * })();
     * &lt;/script&gt;
     */
    JXG.createPolePoint = function (board, parents, attributes) {
        var el, el1, el2,
            firstParentIsConic, secondParentIsConic,
            firstParentIsLine, secondParentIsLine;

        if (parents.length &gt; 1) {
            firstParentIsConic = (parents[0].type === Const.OBJECT_TYPE_CONIC ||
                parents[0].elementClass === Const.OBJECT_CLASS_CIRCLE);
            secondParentIsConic = (parents[1].type === Const.OBJECT_TYPE_CONIC ||
                parents[1].elementClass === Const.OBJECT_CLASS_CIRCLE);

            firstParentIsLine = (parents[0].elementClass === Const.OBJECT_CLASS_LINE);
            secondParentIsLine = (parents[1].elementClass === Const.OBJECT_CLASS_LINE);
        }

/*        if (parents.length !== 2 || !((
                parents[0].type === Const.OBJECT_TYPE_CONIC ||
                parents[0].elementClass === Const.OBJECT_CLASS_CIRCLE) &amp;&amp;
                parents[1].elementClass === Const.OBJECT_CLASS_LINE ||
                parents[0].elementClass === Const.OBJECT_CLASS_LINE &amp;&amp; (
                parents[1].type === Const.OBJECT_TYPE_CONIC ||
                parents[1].elementClass === Const.OBJECT_CLASS_CIRCLE))) {*/
        if (parents.length !== 2 ||
                !((firstParentIsConic &amp;&amp; secondParentIsLine) ||
                    (firstParentIsLine &amp;&amp; secondParentIsConic))) {
            // Failure
            throw new Error(&quot;JSXGraph: Can&#x27;t create &#x27;pole point&#x27; with parent types &#x27;&quot; +
                (typeof parents[0]) + &quot;&#x27; and &#x27;&quot; + (typeof parents[1]) + &quot;&#x27;.&quot; +
                &quot;\nPossible parent type: [conic|circle,line], [line,conic|circle]&quot;);
        }

        if (secondParentIsLine) {
            el1 = board.select(parents[0]);
            el2 = board.select(parents[1]);
        } else {
            el1 = board.select(parents[1]);
            el2 = board.select(parents[0]);
        }

        el = board.create(&#x27;point&#x27;,
            [function () {
                var q = el1.quadraticform,
                    s = el2.stdform.slice(0, 3);

                return [JXG.Math.Numerics.det([s, q[1], q[2]]),
                        JXG.Math.Numerics.det([q[0], s, q[2]]),
                        JXG.Math.Numerics.det([q[0], q[1], s])];
            }], attributes);

        el.elType = &#x27;polepoint&#x27;;
        el.setParents([el1.id, el2.id]);

        el1.addChild(el);
        el2.addChild(el);

        return el;
    };

    JXG.registerElement(&#x27;point&#x27;, JXG.createPoint);
    JXG.registerElement(&#x27;glider&#x27;, JXG.createGlider);
    JXG.registerElement(&#x27;intersection&#x27;, JXG.createIntersectionPoint);
    JXG.registerElement(&#x27;otherintersection&#x27;, JXG.createOtherIntersectionPoint);
    JXG.registerElement(&#x27;polepoint&#x27;, JXG.createPolePoint);

    return {
        Point: JXG.Point,
        createPoint: JXG.createPoint,
        createGlider: JXG.createGlider,
        createIntersection: JXG.createIntersectionPoint,
        createOtherIntersection: JXG.createOtherIntersectionPoint,
        createPolePoint: JXG.createPolePoint
    };
});

    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>

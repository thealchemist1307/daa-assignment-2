<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src/parser/jessiescript.js - JSXGraph</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="../assets/js/jsxgraphcore.js"></script>
    <link rel="stylesheet" href="../assets/css/jsxgraph.css">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../assets/css/logo_blue.png" title="JSXGraph" width="117" height="52"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.99.4</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/Angle.html">Angle</a> </li>
                                <li><a href="../classes/Arc.html">Arc</a> </li>
                                <li><a href="../classes/Arrow.html">Arrow</a> </li>
                                <li><a href="../classes/Arrowparallel.html">Arrowparallel</a> </li>
                                <li><a href="../classes/Axis.html">Axis</a> </li>
                                <li><a href="../classes/Bisector.html">Bisector</a> </li>
                                <li><a href="../classes/Bisectorlines.html">Bisectorlines</a> </li>
                                <li><a href="../classes/Button.html">Button</a> </li>
                                <li><a href="../classes/Checkbox.html">Checkbox</a> </li>
                                <li><a href="../classes/Circle.html">Circle</a> </li>
                                <li><a href="../classes/Circumcenter.html">Circumcenter</a> </li>
                                <li><a href="../classes/Circumcircle.html">Circumcircle</a> </li>
                                <li><a href="../classes/CircumcircleArc.html">CircumcircleArc</a> </li>
                                <li><a href="../classes/CircumcircleSector.html">CircumcircleSector</a> </li>
                                <li><a href="../classes/Conic.html">Conic</a> </li>
                                <li><a href="../classes/Curve.html">Curve</a> </li>
                                <li><a href="../classes/Ellipse.html">Ellipse</a> </li>
                                <li><a href="../classes/EventEmitter.html">EventEmitter</a> </li>
                                <li><a href="../classes/Functiongraph.html">Functiongraph</a> </li>
                                <li><a href="../classes/Glider.html">Glider</a> </li>
                                <li><a href="../classes/Grid.html">Grid</a> </li>
                                <li><a href="../classes/Group.html">Group</a> </li>
                                <li><a href="../classes/Hatch.html">Hatch</a> </li>
                                <li><a href="../classes/Hyperbola.html">Hyperbola</a> </li>
                                <li><a href="../classes/Image.html">Image</a> </li>
                                <li><a href="../classes/Incenter.html">Incenter</a> </li>
                                <li><a href="../classes/Incircle.html">Incircle</a> </li>
                                <li><a href="../classes/Inequality.html">Inequality</a> </li>
                                <li><a href="../classes/Input.html">Input</a> </li>
                                <li><a href="../classes/Integral.html">Integral</a> </li>
                                <li><a href="../classes/Intersection.html">Intersection</a> </li>
                                <li><a href="../classes/JXG.html">JXG</a> </li>
                                <li><a href="../classes/JXG.AbstractRenderer.html">JXG.AbstractRenderer</a> </li>
                                <li><a href="../classes/JXG.Board.html">JXG.Board</a> </li>
                                <li><a href="../classes/JXG.C.html">JXG.C</a> </li>
                                <li><a href="../classes/JXG.CanvasRenderer.html">JXG.CanvasRenderer</a> </li>
                                <li><a href="../classes/JXG.Chart.html">JXG.Chart</a> </li>
                                <li><a href="../classes/JXG.Circle.html">JXG.Circle</a> </li>
                                <li><a href="../classes/JXG.Complex.html">JXG.Complex</a> </li>
                                <li><a href="../classes/JXG.Composition.html">JXG.Composition</a> </li>
                                <li><a href="../classes/JXG.Coords.html">JXG.Coords</a> </li>
                                <li><a href="../classes/JXG.CoordsElement.html">JXG.CoordsElement</a> </li>
                                <li><a href="../classes/JXG.Curve.html">JXG.Curve</a> </li>
                                <li><a href="../classes/JXG.GeometryElement.html">JXG.GeometryElement</a> </li>
                                <li><a href="../classes/JXG.Group.html">JXG.Group</a> </li>
                                <li><a href="../classes/JXG.Image.html">JXG.Image</a> </li>
                                <li><a href="../classes/JXG.JSXGraph.html">JXG.JSXGraph</a> </li>
                                <li><a href="../classes/JXG.Line.html">JXG.Line</a> </li>
                                <li><a href="../classes/JXG.Math.html">JXG.Math</a> </li>
                                <li><a href="../classes/JXG.Math.Geometry.html">JXG.Math.Geometry</a> </li>
                                <li><a href="../classes/JXG.Math.Numerics.html">JXG.Math.Numerics</a> </li>
                                <li><a href="../classes/JXG.Math.Poly.html">JXG.Math.Poly</a> </li>
                                <li><a href="../classes/JXG.Math.Poly.Monomial.html">JXG.Math.Poly.Monomial</a> </li>
                                <li><a href="../classes/JXG.Math.Poly.Polynomial.html">JXG.Math.Poly.Polynomial</a> </li>
                                <li><a href="../classes/JXG.Math.Poly.Ring.html">JXG.Math.Poly.Ring</a> </li>
                                <li><a href="../classes/JXG.Math.Quadtree.html">JXG.Math.Quadtree</a> </li>
                                <li><a href="../classes/JXG.Math.Statistics.html">JXG.Math.Statistics</a> </li>
                                <li><a href="../classes/JXG.Math.Symbolic.html">JXG.Math.Symbolic</a> </li>
                                <li><a href="../classes/JXG.NoRenderer.html">JXG.NoRenderer</a> </li>
                                <li><a href="../classes/JXG.Options.html">JXG.Options</a> </li>
                                <li><a href="../classes/JXG.Point.html">JXG.Point</a> </li>
                                <li><a href="../classes/JXG.Polygon.html">JXG.Polygon</a> </li>
                                <li><a href="../classes/JXG.SVGRenderer.html">JXG.SVGRenderer</a> </li>
                                <li><a href="../classes/JXG.Text.html">JXG.Text</a> </li>
                                <li><a href="../classes/JXG.Ticks.html">JXG.Ticks</a> </li>
                                <li><a href="../classes/JXG.Transformation.html">JXG.Transformation</a> </li>
                                <li><a href="../classes/JXG.Turtle.html">JXG.Turtle</a> </li>
                                <li><a href="../classes/JXG.Util.Base64.html">JXG.Util.Base64</a> </li>
                                <li><a href="../classes/JXG.Util.Unzip.html">JXG.Util.Unzip</a> </li>
                                <li><a href="../classes/JXG.VMLRenderer.html">JXG.VMLRenderer</a> </li>
                                <li><a href="../classes/Line.html">Line</a> </li>
                                <li><a href="../classes/Locus.html">Locus</a> </li>
                                <li><a href="../classes/MajorArc.html">MajorArc</a> </li>
                                <li><a href="../classes/Midpoint.html">Midpoint</a> </li>
                                <li><a href="../classes/MinorArc.html">MinorArc</a> </li>
                                <li><a href="../classes/MinorSector.html">MinorSector</a> </li>
                                <li><a href="../classes/Mirrorpoint.html">Mirrorpoint</a> </li>
                                <li><a href="../classes/NonReflexAngle.html">NonReflexAngle</a> </li>
                                <li><a href="../classes/Normal.html">Normal</a> </li>
                                <li><a href="../classes/Orthogonalprojection.html">Orthogonalprojection</a> </li>
                                <li><a href="../classes/OtherIntersection.html">OtherIntersection</a> </li>
                                <li><a href="../classes/Parabola.html">Parabola</a> </li>
                                <li><a href="../classes/Parallel.html">Parallel</a> </li>
                                <li><a href="../classes/Parallelpoint.html">Parallelpoint</a> </li>
                                <li><a href="../classes/Perpendicular.html">Perpendicular</a> </li>
                                <li><a href="../classes/PerpendicularPoint.html">PerpendicularPoint</a> </li>
                                <li><a href="../classes/PerpendicularSegment.html">PerpendicularSegment</a> </li>
                                <li><a href="../classes/Point.html">Point</a> </li>
                                <li><a href="../classes/PolarLine.html">PolarLine</a> </li>
                                <li><a href="../classes/PolePoint.html">PolePoint</a> </li>
                                <li><a href="../classes/Polygon.html">Polygon</a> </li>
                                <li><a href="../classes/RadicalAxis.html">RadicalAxis</a> </li>
                                <li><a href="../classes/Reflection.html">Reflection</a> </li>
                                <li><a href="../classes/ReflexAngle.html">ReflexAngle</a> </li>
                                <li><a href="../classes/registerReader.html">registerReader</a> </li>
                                <li><a href="../classes/RegularPolygon.html">RegularPolygon</a> </li>
                                <li><a href="../classes/Riemannsum.html">Riemannsum</a> </li>
                                <li><a href="../classes/Sector.html">Sector</a> </li>
                                <li><a href="../classes/Segment.html">Segment</a> </li>
                                <li><a href="../classes/Semicircle.html">Semicircle</a> </li>
                                <li><a href="../classes/Slider.html">Slider</a> </li>
                                <li><a href="../classes/Slopetriangle.html">Slopetriangle</a> </li>
                                <li><a href="../classes/Spline.html">Spline</a> </li>
                                <li><a href="../classes/Stepfunction.html">Stepfunction</a> </li>
                                <li><a href="../classes/Tangent.html">Tangent</a> </li>
                                <li><a href="../classes/Tapemeasure.html">Tapemeasure</a> </li>
                                <li><a href="../classes/Text.html">Text</a> </li>
                                <li><a href="../classes/Ticks.html">Ticks</a> </li>
                                <li><a href="../classes/Tracecurve.html">Tracecurve</a> </li>
                                <li><a href="../classes/Transformation.html">Transformation</a> </li>
                                <li><a href="../classes/Turtle.html">Turtle</a> </li>
                            </ul>
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="../modules/JXG.html">JXG</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: src/parser/jessiescript.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/*
    Copyright 2008-2013
        Matthias Ehmann,
        Michael Gerhaeuser,
        Carsten Miller,
        Bianca Valentin,
        Alfred Wassermann,
        Peter Wilfahrt

    This file is part of JSXGraph.

    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.
    
    You can redistribute it and/or modify it under the terms of the
    
      * GNU Lesser General Public License as published by
        the Free Software Foundation, either version 3 of the License, or
        (at your option) any later version
      OR
      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT
    
    JSXGraph is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.
    
    You should have received a copy of the GNU Lesser General Public License and
    the MIT License along with JSXGraph. If not, see &lt;http://www.gnu.org/licenses/&gt;
    and &lt;http://opensource.org/licenses/MIT/&gt;.
 */


/**
 * @param {String} string A string containing construction(s) in JSXGraph Construction Syntax.
 * @param {String} mode Possible values seem are &quot;normal&quot; or &quot;macro&quot;
 * @param {Array} params Parameters, only used in macro mode
 * @param {Array} paraIn Parameters, only used in macro mode
 * @param {String} macroName Name of the macro, only used in macro mode
 * @type object
 * @return An object consisting of several arrays (lines, circles, points, angles, ...) where the created elements are stored.
 */
JXG.Board.prototype.construct = function(string, mode, params, paraIn, macroName) {
    var splitted, i, j, output = {}, objName, defElements, obj, type, possibleNames, tmp, noMacro, k,l, pattern, createdNames, found,
        mac, prop, propName, propValue, attributes;
    if(!JXG.exists(mode)) {
        mode = &quot;normal&quot;;
    }
    else { // mode = &#x27;macro&#x27;
        createdNames = [];
    }
    output.lines = [];
    output.circles = [];
    output.points = [];
    output.intersections = [];
    output.angles = [];
    output.macros = [];
    output.functions = [];
    output.texts = [];
    output.polygons = [];
    if(string.search(/\{/) != -1) { // Macros finden! Innerhalb der {} darf nicht am ; getrennt werden. Noch nicht getestet: mehrere Makros hintereinander in einem construct.
        tmp = string.match(/\{/);
        tmp = tmp.length;
        l=0;
        for(j=0; j&lt;tmp; j++) {
            k = string.slice(l).search(/\{/);
            mac = string.slice(k);
            mac = mac.slice(0,mac.search(/\}/)+1);
            mac = mac.replace(/;/g,&#x27;?&#x27;);   // Achtung! Fragezeichen duerfen daher nicht im Code eines Macros vorkommen!
            string = string.slice(0,k) + mac + string.slice(k+mac.length);
            l=k+1;
        }
    }
    splitted = string.split(&#x27;;&#x27;);
    for(i=0; i&lt; splitted.length; i++) {
        // Leerzeichen am Anfang und am Ende entfernen
        splitted[i] = splitted[i].replace (/^\s+/, &#x27;&#x27;).replace (/\s+$/, &#x27;&#x27;);
        if(splitted[i].search(/\{/) != -1) {
            splitted[i] = splitted[i].replace(/\?/g,&#x27;;&#x27;);
        }
        if(splitted[i].search(/Macro/) != -1) {
            this.addMacro(splitted[i]);
        }
        else {
            if(splitted[i].length &gt; 0) {
                prop = false;
                if(splitted[i].search(/=/) != -1) {
                    objName = splitted[i].split(&#x27;=&#x27;);
                    propValue = objName[1];
                    propValue = propValue.replace (/^\s+/, &#x27;&#x27;).replace (/\s+$/, &#x27;&#x27;);
                    if(objName[0].search(/\./) != -1) {
                        prop = true;
                    
                        objName = objName[0].split(&#x27;.&#x27;);
                        propName = objName[objName.length-1];
                        propName = propName.replace (/^\s+/, &#x27;&#x27;).replace (/\s+$/, &#x27;&#x27;);
                        objName.pop();
                        objName = objName.join(&quot;.&quot;);
                        if(mode == &#x27;macro&#x27;) {
                            for(j=0; j&lt;params.length; j++) {
                                if(objName == params[j]) {
                                    objName = paraIn[j];
                                }
                            }
                        }                    
                        //alert(&quot;_&quot;+objName+&quot;_&quot;+propName+&quot;_&quot;+propValue+&quot;_&quot;);
                        //alert(JXG.getReference(this,objName).name);
                        JXG.getReference(this,objName).setAttribute(propName+&quot;:&quot;+propValue);
                        
                    }
                }
                if(!prop) { // nicht nur eine Eigenschaft setzen, sondern neues Element konstruieren
                    if(splitted[i].search(/=/) != -1) {
                        objName = splitted[i].split(&#x27;=&#x27;);
                        splitted[i] = objName[1].replace (/^\s+/, &#x27;&#x27;); // Leerzeichen am Anfang entfernen
                        objName = objName[0].replace (/\s+$/, &#x27;&#x27;); // Leerzeichen am Ende entfernen
                    }
                    else {
                        objName = &#x27;&#x27;;
                    }
                    attributes = {};
                    found = true;
                    while(found) {
                        if(splitted[i].search(/(.*)draft$/) != -1) {
                            attributes.draft = true;
                            splitted[i] = RegExp.$1;
                            splitted[i] = splitted[i].replace (/\s+$/, &#x27;&#x27;); // Leerzeichen am Ende entfernen
                        }
                        if(splitted[i].search(/(.*)invisible$/) != -1) {
                            attributes.visible = false;
                            splitted[i] = RegExp.$1;
                            splitted[i] = splitted[i].replace (/\s+$/, &#x27;&#x27;); // Leerzeichen am Ende entfernen
                        }
                        if(splitted[i].search(/(.*)nolabel$/) != -1) {
                            attributes.withLabel = false;
                            splitted[i] = RegExp.$1;
                            splitted[i] = splitted[i].replace (/\s+$/, &#x27;&#x27;); // Leerzeichen am Ende entfernen
                        }
                        if(splitted[i].search(/nolabel|invisible|draft/) == -1) {
                            found = false;
                        }
                    }
                    noMacro = true;
                    if(this.definedMacros) {
                        for(j=0; j&lt;this.definedMacros.macros.length; j++) {
                            pattern = new RegExp(&quot;^&quot;+this.definedMacros.macros[j][0]+&quot;\\s*\\(&quot;);
                            if(splitted[i].search(pattern) != -1) { // TODO: testen, was mit den Macros xxx und yxxx passiert
                                //alert(&quot;MACRO!&quot;+splitted[i]+&quot;_&quot;+this.definedMacros.macros[j][2]);
                                noMacro = false;
                                // Parameter aufdroeseln
                                splitted[i].match(/\((.*)\)/);
                                tmp = RegExp.$1;
                                tmp = tmp.split(&#x27;,&#x27;);
                                for(k=0; k &lt; tmp.length; k++) {
                                    tmp[k].match(/\s*(\S*)\s*/);
                                    tmp[k] = RegExp.$1;
                                }
                                output[objName] = this.construct(this.definedMacros.macros[j][2],&#x27;macro&#x27;,this.definedMacros.macros[j][1], tmp, objName);
                                output.macros.push(output[objName]);
                                break;
                            }
                        }
                    }
                    if(noMacro) { // splitted[i] war kein Macro-Aufruf
                        if(splitted[i].search(/^[\[\]].*[\[\]]$/) != -1) { // Gerade, Halbgerade oder Segment
                            splitted[i].match(/([\[\]])(.*)([\[\]])/);
                            attributes.straightFirst = (RegExp.$1 != &#x27;[&#x27;);
                            attributes.straightLast = (RegExp.$3 == &#x27;[&#x27;);
                            defElements = (RegExp.$2).replace (/^\s+/, &#x27;&#x27;).replace (/\s+$/, &#x27;&#x27;);
                            if(defElements.search(/ /) != -1) {
                                defElements.match(/(\S*) +(\S*)/);
                                defElements = [];
                                defElements[0] = RegExp.$1;
                                defElements[1] = RegExp.$2;
                            } // sonst wird die Gerade durch zwei Punkte definiert, die einen Namen haben, der aus nur jeweils einem Buchstaben besteht
                            if(objName != &#x27;&#x27;) {
                                if(!JXG.exists(attributes.withLabel)) {
                                    attributes.withLabel = true;
                                }
                                attributes.name = objName;
                                if(mode == &#x27;macro&#x27;) {
                                    createdNames.push(objName);
                                }
                            }
                            if(mode == &#x27;macro&#x27;) {
                                if(macroName != &#x27;&#x27;) {
                                    for(j=0; j&lt;createdNames.length; j++) { // vorher oder nachher?
                                        if(defElements[0] == createdNames[j]) {
                                            defElements[0] = macroName+&quot;.&quot;+defElements[0];
                                        }
                                        if(defElements[1] == createdNames[j]) {
                                            defElements[1] = macroName+&quot;.&quot;+defElements[1];
                                        }
                                    }
                                }
                                for(j=0; j&lt;params.length; j++) {
                                    if(defElements[0] == params[j]) {
                                        defElements = [paraIn[j], defElements[1]];
                                    }
                                    if(defElements[1] == params[j]) {
                                        defElements = [defElements[0], paraIn[j]];
                                    }
                                }
                                if(macroName != &#x27;&#x27;) {
                                    attributes.id = macroName+&quot;.&quot;+objName;
                                }
                            }
                            if(typeof defElements == &#x27;string&#x27;) {
                                defElements = [JXG.getReference(this,defElements.charAt(0)), JXG.getReference(this,defElements.charAt(1))];
                            }
                            else {
                                defElements = [JXG.getReference(this,defElements[0]), JXG.getReference(this,defElements[1])];
                            }
                            output.lines.push(this.create(&#x27;line&#x27;,
                                                    defElements,
                                                    attributes));
                            if(objName != &#x27;&#x27;) {
                                output[objName] = output.lines[output.lines.length-1];
                            }
                        }
                        else if(splitted[i].search(/k\s*\(.*/) != -1) { // Kreis
                            splitted[i].match(/k\s*\(\s*(\S.*\S|\S)\s*,\s*(\S.*\S|\S)\s*\)/);
                            defElements = [];
                            defElements[0] = RegExp.$1;
                            defElements[1] = RegExp.$2;
                            for(j=0; j&lt;=1; j++) {
                                if(defElements[j].search(/[\[\]]/) != -1) { // Linie, definiert durch [P_1 P_2] , ist bei den Parametern dabei
                                    defElements[j].match(/^[\[\]]\s*(\S.*\S)\s*[\[\]]$/);
                                    defElements[j] = RegExp.$1;
                                    if(defElements[j].search(/ /) != -1) {
                                        defElements[j].match(/(\S*) +(\S*)/);
                                        defElements[j] = [];
                                        defElements[j][0] = RegExp.$1;
                                        defElements[j][1] = RegExp.$2;
                                    } // sonst wird die Gerade durch zwei Punkte definiert, die einen Namen haben, der aus nur jeweils einem Buchstaben besteht
                                    if(mode == &#x27;macro&#x27;) {
                                        if(macroName != &#x27;&#x27;) {
                                            for(k=0; k&lt;createdNames.length; k++) { // vorher oder nachher?
                                                if(defElements[j][0] == createdNames[k]) {
                                                    defElements[j][0] = macroName+&quot;.&quot;+defElements[j][0];
                                                }
                                                if(defElements[j][1] == createdNames[k]) {
                                                    defElements[j][1] = macroName+&quot;.&quot;+defElements[j][1];
                                                }
                                            }
                                        }
                                        for(k=0; k&lt;params.length; k++) {
                                            if(defElements[j][0] == params[k]) {
                                                defElements[j] = [paraIn[k], defElements[j][1]];
                                            }
                                            if(defElements[j][1] == params[k]) {
                                                defElements[j] = [defElements[j][0], paraIn[k]];
                                            }
                                        }
                                    }
                                    if(typeof defElements[j] == &#x27;string&#x27;) {
                                        defElements[j] = (function(el, board) { return function() {
                                                                    return JXG.getReference(board,el.charAt(0)).Dist(JXG.getReference(board,el.charAt(1))); // TODO
                                                               }}
                                                  )(defElements[j], this);
                                    }
                                    else {
                                        defElements[j] = (function(el, board) { return function() {
                                                                    return JXG.getReference(board,el[0]).Dist(JXG.getReference(board,el[1])); // TODO
                                                               }}
                                                  )(defElements[j], this);
                                    }
                                    
                                }
                                else if(defElements[j].search(/[0-9\.\s]+/) != -1){ // Radius als Zahl
                                    defElements[j] = 1.0*defElements[j];
                                }
                                else { // Element mit Name
                                    if(mode == &#x27;macro&#x27;) {
                                        if(macroName != &#x27;&#x27;) {
                                            for(k=0; k&lt;createdNames.length; k++) { // vorher oder nachher?
                                                if(defElements[j] == createdNames[k]) {
                                                    defElements[j] = macroName+&quot;.&quot;+createdNames[k];
                                                }
                                            }
                                        }
                                        for(k=0; k&lt;params.length; k++) {
                                            if(defElements[j] == params[k]) {
                                                defElements[j] = paraIn[k];
                                            }
                                        }
                                    }
                                    defElements[j] = JXG.getReference(this,defElements[j]);
                                }
                            }
                            if(objName != &#x27;&#x27;) {
                                if(!JXG.exists(attributes.withLabel)) {
                                    attributes.withLabel = true;
                                }
                                attributes.name = objName;
                                if(mode == &#x27;macro&#x27;) {
                                    if(macroName != &#x27;&#x27;) {
                                        attributes.id = macroName+&quot;.&quot;+objName;
                                    }
                                    createdNames.push(objName);
                                }
                            }
                            output.circles.push(this.create(&#x27;circle&#x27;,defElements,attributes));
                            if(objName != &#x27;&#x27;) {
                                output[objName] = output.circles[output.circles.length-1];
                            }
                        }
                        else if(splitted[i].search(/^[A-Z]+.*\(\s*[0-9\.\-]+\s*[,\|]\s*[0-9\.\-]+\s*\)/) != -1
                                &amp;&amp; splitted[i].search(/Macro\((.*)\)/) == -1) { // Punkt, startet mit einem Grossbuchstaben! (definiert durch Koordinaten)
                            splitted[i].match(/^([A-Z]+\S*)\s*\(\s*(.*)\s*[,\|]\s*(.*)\s*\)$/);
                            objName = RegExp.$1; // Name
                            attributes.name = objName;
                            if(mode == &#x27;macro&#x27;) {
                                if(macroName != &#x27;&#x27;) {
                                    attributes.id = macroName+&quot;.&quot;+objName;
                                }
                                createdNames.push(objName);
                            }
                            output.points.push(this.create(&#x27;point&#x27;,[1.0*RegExp.$2,1.0*RegExp.$3],attributes));
                            output[objName] = output.points[output.points.length-1];
                        }
                        else if(splitted[i].search(/^[A-Z]+.*\(.+(([,\|]\s*[0-9\.\-]+\s*){2})?/) != -1
                                &amp;&amp; splitted[i].search(/Macro\((.*)\)/) == -1) { // Gleiter, mit oder ohne Koordinaten
                            splitted[i].match(/([A-Z]+.*)\((.*)\)/);
                            objName = RegExp.$1;
                            defElements = RegExp.$2;
                            objName = objName.replace (/^\s+/, &#x27;&#x27;).replace (/\s+$/, &#x27;&#x27;);
                            defElements = defElements.replace (/^\s+/, &#x27;&#x27;).replace (/\s+$/, &#x27;&#x27;);
                            if(defElements.search(/[,\|]/) != -1) { // Koordinaten angegeben
                                defElements.match(/(\S*)\s*[,\|]\s*([0-9\.]+)\s*[,\|]\s*([0-9\.]+)\s*/);
                                defElements = [];
                                defElements[0] = RegExp.$1;
                                defElements[1] = 1.0*RegExp.$2;
                                defElements[2] = 1.0*RegExp.$3;
                            }
                            else { // keine Koordinaten
                                obj = defElements;
                                defElements = [];
                                defElements[0] = obj; // Name des definierenden Elements
                                defElements[1] = 0; // (0,0) als Gleiterkoordinaten vorgeben...
                                defElements[2] = 0;
                            }
                            attributes.name = objName;
                            if(mode == &#x27;macro&#x27;) {
                                if(macroName != &#x27;&#x27;) {
                                    for(k=0; k&lt;createdNames.length; k++) { // vorher oder nachher?
                                        if(defElements[0] == createdNames[k]) {
                                            defElements[0] = macroName+&quot;.&quot;+createdNames[k];
                                        }
                                    }
                                }
                                for(k=0; k&lt;params.length; k++) {
                                    if(defElements[0] == params[k]) {
                                        defElements[0] = paraIn[k];
                                    }
                                }
                                if(macroName != &#x27;&#x27;) {
                                    attributes.id = macroName+&quot;.&quot;+objName;
                                }
                                createdNames.push(objName);
                            }
                            output.points.push(this.create(&#x27;glider&#x27;,
                                                                  [defElements[1],defElements[2],JXG.getReference(this,defElements[0])],
                                                                  attributes));
                            output[objName] = output.points[output.points.length-1];
                        }
                        else if(splitted[i].search(/&amp;/) != -1) { // Schnittpunkt
                            splitted[i].match(/(.*)&amp;(.*)/);
                            defElements = [];
                            defElements[0] = RegExp.$1;
                            defElements[1] = RegExp.$2;
                            defElements[0] = defElements[0].replace(/\s+$/, &#x27;&#x27;); // Leerzeichen am Ende entfernen
                            defElements[1] = defElements[1].replace (/^\s+/, &#x27;&#x27;); // Leerzeichen am Anfang entfernen
                            if(mode == &#x27;macro&#x27;) {
                                for(j=0; j&lt;=1; j++) {
                                    if(macroName != &#x27;&#x27;) {
                                        for(k=0; k&lt;createdNames.length; k++) { // vorher oder nachher?
                                            if(defElements[j] == createdNames[k]) {
                                                defElements[j] = macroName+&quot;.&quot;+createdNames[k];
                                            }
                                        }
                                    }
                                    for(k=0; k&lt;params.length; k++) {
                                        if(defElements[j] == params[k]) {
                                            defElements[j] = paraIn[k];
                                        }
                                    }
                                }
                            }
                            defElements[0] = JXG.getReference(this,defElements[0]);
                            defElements[1] = JXG.getReference(this,defElements[1]);
                            if ((defElements[0].elementClass==JXG.OBJECT_CLASS_LINE || defElements[0].elementClass==JXG.OBJECT_CLASS_CURVE) &amp;&amp;
                                (defElements[1].elementClass==JXG.OBJECT_CLASS_LINE || defElements[1].elementClass==JXG.OBJECT_CLASS_CURVE)) {
                                if(objName != &#x27;&#x27;) {
                                    attributes.name = objName;
                                    if(mode == &#x27;macro&#x27;) {
                                        if(macroName != &#x27;&#x27;) {
                                            attributes.id = macroName+&quot;.&quot;+objName;
                                        }
                                        createdNames.push(objName);
                                    }
                                }                          
                                obj = this.create(&#x27;intersection&#x27;,[defElements[0],defElements[1],0],attributes);
                                output.intersections.push(obj);
                                if(objName != &#x27;&#x27;) {
                                    output[attributes.name] = obj;
                                }
                            }
                            else {
                                if(objName != &#x27;&#x27;) {
                                    attributes.name = objName+&quot;_1&quot;;
                                    if(mode == &#x27;macro&#x27;) {
                                        if(macroName != &#x27;&#x27;) {
                                            attributes.id = macroName+&quot;.&quot;+objName+&quot;_1&quot;;
                                        }
                                        createdNames.push(objName+&quot;_1&quot;);
                                    }
                                }
                                obj = this.create(&#x27;intersection&#x27;,[defElements[0],defElements[1],0],attributes);
                                output.intersections.push(obj);
                                if(objName != &#x27;&#x27;) {
                                    output[attributes.name] = obj;
                                }
                                if(objName != &#x27;&#x27;) {
                                    attributes.name = objName+&quot;_2&quot;;
                                    if(mode == &#x27;macro&#x27;) {
                                        if(macroName != &#x27;&#x27;) {
                                            attributes.id = macroName+&quot;.&quot;+objName+&quot;_2&quot;;
                                        }
                                        createdNames.push(objName+&quot;_2&quot;);
                                    }
                                }
                                obj = this.create(&#x27;intersection&#x27;,[defElements[0],defElements[1],1],attributes);
                                output.intersections.push(obj);
                                if(objName != &#x27;&#x27;) {
                                    output[attributes.name] = obj;
                                }
                            }
                        }
                        else if(splitted[i].search(/\|[\|_]\s*\(/) != -1) { // Parallele oder Senkrechte
                            splitted[i].match(/\|([\|_])\s*\(\s*(\S*)\s*,\s*(\S*)\s*\)/);
                            type = RegExp.$1;
                            if(type == &#x27;|&#x27;) {
                                type = &#x27;parallel&#x27;;
                            }
                            else { // type == &#x27;_&#x27;
                                type = &#x27;normal&#x27;;
                            }
                            defElements = [];
                            defElements[0] = RegExp.$2;
                            defElements[1] = RegExp.$3;
                            if(mode == &#x27;macro&#x27;) {
                                for(j=0; j&lt;=1; j++) {
                                    if(macroName != &#x27;&#x27;) {
                                        for(k=0; k&lt;createdNames.length; k++) { // vorher oder nachher?
                                            if(defElements[j] == createdNames[k]) {
                                                defElements[j] = macroName+&quot;.&quot;+createdNames[k];
                                            }
                                        }
                                    }
                                    for(k=0; k&lt;params.length; k++) {
                                        if(defElements[j] == params[k]) {
                                            defElements[j] = paraIn[k];
                                        }
                                    }
                                }
                            }
                            if(objName != &#x27;&#x27;) {
                                attributes.name = objName;
                                if(!JXG.exists(attributes.withLabel)) {
                                    attributes.withLabel = true;
                                }
                                if(mode == &#x27;macro&#x27;) {
                                    if(macroName != &#x27;&#x27;) {
                                        attributes.id = macroName+&quot;.&quot;+objName;
                                    }
                                    createdNames.push(objName);
                                }
                            }
                            output.lines.push(this.create(type,
                                                                 [JXG.getReference(this,defElements[0]),JXG.getReference(this,defElements[1])],
                                                                 attributes));

                            if(objName != &#x27;&#x27;) {
                                output[objName] = output.lines[output.lines.length-1];
                            }
                        }
                        else if(splitted[i].search(/^&lt;/) != -1) { // Winkel
                            splitted[i].match(/&lt;\s*\(\s*(\S*)\s*,\s*(\S*)\s*,\s*(\S*)\s*\)/);
                            defElements = [];
                            defElements[0] = RegExp.$1;
                            defElements[1] = RegExp.$2;
                            defElements[2] = RegExp.$3;
                            if(mode == &#x27;macro&#x27;) {
                                for(j=0; j&lt;=2; j++) {
                                    if(macroName != &#x27;&#x27;) {
                                        for(k=0; k&lt;createdNames.length; k++) { // vorher oder nachher?
                                            if(defElements[j] == createdNames[k]) {
                                                defElements[j] = macroName+&quot;.&quot;+createdNames[k];
                                            }
                                        }
                                    }
                                    for(k=0; k&lt;params.length; k++) {
                                        if(defElements[j] == params[k]) {
                                            defElements[j] = paraIn[k];
                                        }
                                    }
                                }
                            }
                            if(objName == &#x27;&#x27;) {
                                output.lines.push(this.create(&#x27;angle&#x27;,
                                                                    [JXG.getReference(this,defElements[0]),
                                                                     JXG.getReference(this,defElements[1]),
                                                                     JXG.getReference(this,defElements[2])],
                                                                     attributes));
                            }
                            else {
                                possibleNames = [&#x27;alpha&#x27;, &#x27;beta&#x27;, &#x27;gamma&#x27;, &#x27;delta&#x27;, &#x27;epsilon&#x27;, &#x27;zeta&#x27;, &#x27;eta&#x27;, &#x27;theta&#x27;,
                                            &#x27;iota&#x27;, &#x27;kappa&#x27;, &#x27;lambda&#x27;, &#x27;mu&#x27;, &#x27;nu&#x27;, &#x27;xi&#x27;, &#x27;omicron&#x27;, &#x27;pi&#x27;, &#x27;rho&#x27;,
                                            &#x27;sigmaf&#x27;, &#x27;sigma&#x27;, &#x27;tau&#x27;, &#x27;upsilon&#x27;, &#x27;phi&#x27;, &#x27;chi&#x27;, &#x27;psi&#x27;, &#x27;omega&#x27;];
                                type = &#x27;&#x27;;
                                for(j=0; j&lt;possibleNames.length;j++) {
                                    if(objName == possibleNames[j]) {
                                        attributes.text = &#x27;&amp;&#x27;+objName+&#x27;;&#x27;;
                                        attributes.name = &#x27;&amp;&#x27;+objName+&#x27;;&#x27;;
                                        type = &#x27;greek&#x27;;
                                        break;
                                    }
                                    else {
                                        if(j == possibleNames.length -1) {
                                            attributes.text = objName;
                                            attributes.name = objName;
                                        }
                                    }
                                }
                                if(!JXG.exists(attributes.withLabel)) {
                                    attributes.withLabel = true;
                                }
                                if(mode == &#x27;macro&#x27;) {
                                    if(macroName != &#x27;&#x27;) {
                                        attributes.id = macroName+&quot;.&quot;+objName;
                                    }
                                    createdNames.push(objName);
                                }
                                output.angles.push(this.create(&#x27;angle&#x27;,
                                                                     [JXG.getReference(this,defElements[0]),
                                                                      JXG.getReference(this,defElements[1]),
                                                                      JXG.getReference(this,defElements[2])],
                                                                     attributes));
                                output[objName] = output.angles[output.angles.length-1];
                            }
                        }
                        else if(splitted[i].search(/([0-9]+)\/([0-9]+)\(\s*(\S*)\s*,\s*(\S*)\s*\)/) != -1) { // Punkt mit Teilverhaeltnis, z.B. Mittelpunkt
                            defElements = [];
                            defElements[0] = 1.0*(RegExp.$1)/(1.0*(RegExp.$2));
                            defElements[1] = RegExp.$3;
                            defElements[2] = RegExp.$4;
                            if(mode == &#x27;macro&#x27;) {
                                for(j=1; j&lt;=2; j++) {
                                    if(macroName != &#x27;&#x27;) {
                                        for(k=0; k&lt;createdNames.length; k++) { // vorher oder nachher?
                                            if(defElements[j] == createdNames[k]) {
                                                defElements[j] = macroName+&quot;.&quot;+createdNames[k];
                                            }
                                        }
                                    }
                                    for(k=0; k&lt;params.length; k++) {
                                        if(defElements[j] == params[k]) {
                                            defElements[j] = paraIn[k];
                                        }
                                    }
                                }
                            }
                            defElements[1] = JXG.getReference(this,RegExp.$3);
                            defElements[2] = JXG.getReference(this,RegExp.$4);
                            obj = [];
                            obj[0] = (function(el, board) { return function() {
                                                                          return (1-el[0])*el[1].coords.usrCoords[1]+el[0]*el[2].coords.usrCoords[1];
                                                           }}
                                              )(defElements, this);
                            obj[1] = (function(el, board) { return function() {
                                                                          return (1-el[0])*el[1].coords.usrCoords[2]+el[0]*el[2].coords.usrCoords[2];
                                                           }}
                                              )(defElements, this);
                            if(objName != &#x27;&#x27;) {
                                attributes.name = objName;
                                if(mode == &#x27;macro&#x27;) {
                                    if(macroName != &#x27;&#x27;) {
                                        attributes.id = macroName+&quot;.&quot;+objName;
                                    }
                                    createdNames.push(objName);
                                }
                            }
                            output.points.push(this.create(&#x27;point&#x27;,[obj[0],obj[1]],attributes));
                            if(objName != &#x27;&#x27;) {
                                output[objName] = output.points[output.points.length-1];
                            }
                        }
                        else if(splitted[i].search(/(\S*)\s*:\s*(.*)/) != -1) { // Funktionsgraph
                            objName = RegExp.$1;
                            tmp = JXG.GeonextParser.geonext2JS(RegExp.$2, this);
                            defElements = [new Function(&#x27;x&#x27;,&#x27;var y = &#x27;+tmp+&#x27;; return y;&#x27;)];
                            attributes.name = objName;
                            output.functions.push(this.create(&#x27;functiongraph&#x27;,defElements,attributes));
                            output[objName] = output.functions[output.functions.length-1];
                        }
                        else if(splitted[i].search(/#(.*)\(\s*([0-9])\s*[,|]\s*([0-9])\s*\)/) != -1) { // Text element
                            defElements = []; // [0-9\.\-]+
                            defElements[0] = RegExp.$1;
                            defElements[1] = 1.0*RegExp.$2;
                            defElements[2] = 1.0*RegExp.$3;
                            defElements[0] = defElements[0].replace (/^\s+/, &#x27;&#x27;).replace (/\s+$/, &#x27;&#x27;); // trim
                            output.texts.push(this.create(&#x27;text&#x27;,[defElements[1],defElements[2],defElements[0]], attributes));
                        }
                        else if(splitted[i].search(/(\S*)\s*\[(.*)\]/) != -1) { // Polygon
                            attributes.name = RegExp.$1;
                            if(!JXG.exists(attributes.withLabel)) {
                                attributes.withLabel = true;
                            }
                            defElements = RegExp.$2;
                            defElements = defElements.split(&#x27;,&#x27;);
                            for(j=0; j&lt;defElements.length; j++) {
                                defElements[j] = defElements[j].replace (/^\s+/, &#x27;&#x27;).replace (/\s+$/, &#x27;&#x27;); // trim
                                if(mode == &#x27;macro&#x27;) {
                                    if(macroName != &#x27;&#x27;) {
                                        for(k=0; k&lt;createdNames.length; k++) { // vorher oder nachher?
                                            if(defElements[j] == createdNames[k]) {
                                                defElements[j] = macroName+&quot;.&quot;+createdNames[k];
                                            }
                                        }
                                    }
                                    for(k=0; k&lt;params.length; k++) {
                                        if(defElements[j] == params[k]) {
                                            defElements[j] = paraIn[k];
                                        }
                                    }
                                }
                                defElements[j] = JXG.getReference(this,defElements[j]);
                            }
                            output.polygons.push(this.create(&#x27;polygon&#x27;,defElements,attributes));
                            output[attributes.name] = output.polygons[output.polygons.length-1];
                        }
                    }
                }
            }
        }
    }
    this.update();
    return output;
};

/**
 * Parses a string like&lt;br /&gt;
 * &lt;tt&gt;&amp;lt;macro-name&amp;gt; = Macro(A, B, C) { &lt;Command in JSXGraph Construction syntax&gt;; ...&lt;Command in JXG-Construct syntax&gt;; }&lt;/tt&gt;&lt;br /&gt;
 * and adds it as a macro so it can be used in the JSXGraph Construction Syntax.
 * @param {String} string A string like the one in the methods description.
 * @see #construct
 */
JXG.Board.prototype.addMacro = function(string) {
    var defHead, defBody, defName = &#x27;&#x27;, i;
    string.match(/(.*)\{(.*)\}/);
    defHead = RegExp.$1;
    defBody = RegExp.$2;
    if(defHead.search(/=/) != -1) {
        defHead.match(/\s*(\S*)\s*=.*/);
        defName = RegExp.$1;
        defHead = (defHead.split(&#x27;=&#x27;))[1];
    }
    defHead.match(/Macro\((.*)\)/);
    defHead = RegExp.$1;
    defHead = defHead.split(&#x27;,&#x27;);
    for(i=0; i &lt; defHead.length; i++) {
        defHead[i].match(/\s*(\S*)\s*/);
        defHead[i] = RegExp.$1;
    }

    if(this.definedMacros == null) {
        this.definedMacros = {};
        this.definedMacros.macros = [];
    }

    this.definedMacros.macros.push([defName, defHead, defBody]);
    if(defName != &#x27;&#x27;) {
        this.definedMacros.defName = this.definedMacros.macros[this.definedMacros.macros.length-1];
    }
};

    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src/renderer/abstract.js - JSXGraph</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="../assets/js/jsxgraphcore.js"></script>
    <link rel="stylesheet" href="../assets/css/jsxgraph.css">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../assets/css/logo_blue.png" title="JSXGraph" width="117" height="52"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.99.4</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/Angle.html">Angle</a> </li>
                                <li><a href="../classes/Arc.html">Arc</a> </li>
                                <li><a href="../classes/Arrow.html">Arrow</a> </li>
                                <li><a href="../classes/Arrowparallel.html">Arrowparallel</a> </li>
                                <li><a href="../classes/Axis.html">Axis</a> </li>
                                <li><a href="../classes/Bisector.html">Bisector</a> </li>
                                <li><a href="../classes/Bisectorlines.html">Bisectorlines</a> </li>
                                <li><a href="../classes/Button.html">Button</a> </li>
                                <li><a href="../classes/Checkbox.html">Checkbox</a> </li>
                                <li><a href="../classes/Circle.html">Circle</a> </li>
                                <li><a href="../classes/Circumcenter.html">Circumcenter</a> </li>
                                <li><a href="../classes/Circumcircle.html">Circumcircle</a> </li>
                                <li><a href="../classes/CircumcircleArc.html">CircumcircleArc</a> </li>
                                <li><a href="../classes/CircumcircleSector.html">CircumcircleSector</a> </li>
                                <li><a href="../classes/Conic.html">Conic</a> </li>
                                <li><a href="../classes/Curve.html">Curve</a> </li>
                                <li><a href="../classes/Ellipse.html">Ellipse</a> </li>
                                <li><a href="../classes/EventEmitter.html">EventEmitter</a> </li>
                                <li><a href="../classes/Functiongraph.html">Functiongraph</a> </li>
                                <li><a href="../classes/Glider.html">Glider</a> </li>
                                <li><a href="../classes/Grid.html">Grid</a> </li>
                                <li><a href="../classes/Group.html">Group</a> </li>
                                <li><a href="../classes/Hatch.html">Hatch</a> </li>
                                <li><a href="../classes/Hyperbola.html">Hyperbola</a> </li>
                                <li><a href="../classes/Image.html">Image</a> </li>
                                <li><a href="../classes/Incenter.html">Incenter</a> </li>
                                <li><a href="../classes/Incircle.html">Incircle</a> </li>
                                <li><a href="../classes/Inequality.html">Inequality</a> </li>
                                <li><a href="../classes/Input.html">Input</a> </li>
                                <li><a href="../classes/Integral.html">Integral</a> </li>
                                <li><a href="../classes/Intersection.html">Intersection</a> </li>
                                <li><a href="../classes/JXG.html">JXG</a> </li>
                                <li><a href="../classes/JXG.AbstractRenderer.html">JXG.AbstractRenderer</a> </li>
                                <li><a href="../classes/JXG.Board.html">JXG.Board</a> </li>
                                <li><a href="../classes/JXG.C.html">JXG.C</a> </li>
                                <li><a href="../classes/JXG.CanvasRenderer.html">JXG.CanvasRenderer</a> </li>
                                <li><a href="../classes/JXG.Chart.html">JXG.Chart</a> </li>
                                <li><a href="../classes/JXG.Circle.html">JXG.Circle</a> </li>
                                <li><a href="../classes/JXG.Complex.html">JXG.Complex</a> </li>
                                <li><a href="../classes/JXG.Composition.html">JXG.Composition</a> </li>
                                <li><a href="../classes/JXG.Coords.html">JXG.Coords</a> </li>
                                <li><a href="../classes/JXG.CoordsElement.html">JXG.CoordsElement</a> </li>
                                <li><a href="../classes/JXG.Curve.html">JXG.Curve</a> </li>
                                <li><a href="../classes/JXG.GeometryElement.html">JXG.GeometryElement</a> </li>
                                <li><a href="../classes/JXG.Group.html">JXG.Group</a> </li>
                                <li><a href="../classes/JXG.Image.html">JXG.Image</a> </li>
                                <li><a href="../classes/JXG.JSXGraph.html">JXG.JSXGraph</a> </li>
                                <li><a href="../classes/JXG.Line.html">JXG.Line</a> </li>
                                <li><a href="../classes/JXG.Math.html">JXG.Math</a> </li>
                                <li><a href="../classes/JXG.Math.Geometry.html">JXG.Math.Geometry</a> </li>
                                <li><a href="../classes/JXG.Math.Numerics.html">JXG.Math.Numerics</a> </li>
                                <li><a href="../classes/JXG.Math.Poly.html">JXG.Math.Poly</a> </li>
                                <li><a href="../classes/JXG.Math.Poly.Monomial.html">JXG.Math.Poly.Monomial</a> </li>
                                <li><a href="../classes/JXG.Math.Poly.Polynomial.html">JXG.Math.Poly.Polynomial</a> </li>
                                <li><a href="../classes/JXG.Math.Poly.Ring.html">JXG.Math.Poly.Ring</a> </li>
                                <li><a href="../classes/JXG.Math.Quadtree.html">JXG.Math.Quadtree</a> </li>
                                <li><a href="../classes/JXG.Math.Statistics.html">JXG.Math.Statistics</a> </li>
                                <li><a href="../classes/JXG.Math.Symbolic.html">JXG.Math.Symbolic</a> </li>
                                <li><a href="../classes/JXG.NoRenderer.html">JXG.NoRenderer</a> </li>
                                <li><a href="../classes/JXG.Options.html">JXG.Options</a> </li>
                                <li><a href="../classes/JXG.Point.html">JXG.Point</a> </li>
                                <li><a href="../classes/JXG.Polygon.html">JXG.Polygon</a> </li>
                                <li><a href="../classes/JXG.SVGRenderer.html">JXG.SVGRenderer</a> </li>
                                <li><a href="../classes/JXG.Text.html">JXG.Text</a> </li>
                                <li><a href="../classes/JXG.Ticks.html">JXG.Ticks</a> </li>
                                <li><a href="../classes/JXG.Transformation.html">JXG.Transformation</a> </li>
                                <li><a href="../classes/JXG.Turtle.html">JXG.Turtle</a> </li>
                                <li><a href="../classes/JXG.Util.Base64.html">JXG.Util.Base64</a> </li>
                                <li><a href="../classes/JXG.Util.Unzip.html">JXG.Util.Unzip</a> </li>
                                <li><a href="../classes/JXG.VMLRenderer.html">JXG.VMLRenderer</a> </li>
                                <li><a href="../classes/Line.html">Line</a> </li>
                                <li><a href="../classes/Locus.html">Locus</a> </li>
                                <li><a href="../classes/MajorArc.html">MajorArc</a> </li>
                                <li><a href="../classes/Midpoint.html">Midpoint</a> </li>
                                <li><a href="../classes/MinorArc.html">MinorArc</a> </li>
                                <li><a href="../classes/MinorSector.html">MinorSector</a> </li>
                                <li><a href="../classes/Mirrorpoint.html">Mirrorpoint</a> </li>
                                <li><a href="../classes/NonReflexAngle.html">NonReflexAngle</a> </li>
                                <li><a href="../classes/Normal.html">Normal</a> </li>
                                <li><a href="../classes/Orthogonalprojection.html">Orthogonalprojection</a> </li>
                                <li><a href="../classes/OtherIntersection.html">OtherIntersection</a> </li>
                                <li><a href="../classes/Parabola.html">Parabola</a> </li>
                                <li><a href="../classes/Parallel.html">Parallel</a> </li>
                                <li><a href="../classes/Parallelpoint.html">Parallelpoint</a> </li>
                                <li><a href="../classes/Perpendicular.html">Perpendicular</a> </li>
                                <li><a href="../classes/PerpendicularPoint.html">PerpendicularPoint</a> </li>
                                <li><a href="../classes/PerpendicularSegment.html">PerpendicularSegment</a> </li>
                                <li><a href="../classes/Point.html">Point</a> </li>
                                <li><a href="../classes/PolarLine.html">PolarLine</a> </li>
                                <li><a href="../classes/PolePoint.html">PolePoint</a> </li>
                                <li><a href="../classes/Polygon.html">Polygon</a> </li>
                                <li><a href="../classes/RadicalAxis.html">RadicalAxis</a> </li>
                                <li><a href="../classes/Reflection.html">Reflection</a> </li>
                                <li><a href="../classes/ReflexAngle.html">ReflexAngle</a> </li>
                                <li><a href="../classes/registerReader.html">registerReader</a> </li>
                                <li><a href="../classes/RegularPolygon.html">RegularPolygon</a> </li>
                                <li><a href="../classes/Riemannsum.html">Riemannsum</a> </li>
                                <li><a href="../classes/Sector.html">Sector</a> </li>
                                <li><a href="../classes/Segment.html">Segment</a> </li>
                                <li><a href="../classes/Semicircle.html">Semicircle</a> </li>
                                <li><a href="../classes/Slider.html">Slider</a> </li>
                                <li><a href="../classes/Slopetriangle.html">Slopetriangle</a> </li>
                                <li><a href="../classes/Spline.html">Spline</a> </li>
                                <li><a href="../classes/Stepfunction.html">Stepfunction</a> </li>
                                <li><a href="../classes/Tangent.html">Tangent</a> </li>
                                <li><a href="../classes/Tapemeasure.html">Tapemeasure</a> </li>
                                <li><a href="../classes/Text.html">Text</a> </li>
                                <li><a href="../classes/Ticks.html">Ticks</a> </li>
                                <li><a href="../classes/Tracecurve.html">Tracecurve</a> </li>
                                <li><a href="../classes/Transformation.html">Transformation</a> </li>
                                <li><a href="../classes/Turtle.html">Turtle</a> </li>
                            </ul>
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="../modules/JXG.html">JXG</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: src/renderer/abstract.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/*
    Copyright 2008-2015
        Matthias Ehmann,
        Michael Gerhaeuser,
        Carsten Miller,
        Bianca Valentin,
        Alfred Wassermann,
        Peter Wilfahrt

    This file is part of JSXGraph.

    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.

    You can redistribute it and/or modify it under the terms of the

      * GNU Lesser General Public License as published by
        the Free Software Foundation, either version 3 of the License, or
        (at your option) any later version
      OR
      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT

    JSXGraph is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License and
    the MIT License along with JSXGraph. If not, see &lt;http://www.gnu.org/licenses/&gt;
    and &lt;http://opensource.org/licenses/MIT/&gt;.
 */


/*global JXG: true, define: true, AMprocessNode: true, MathJax: true, document: true, window: true */

/*
    nomen:    Allow underscores to indicate private class members. Might be replaced by local variables.
    plusplus: Only allowed in for-loops
    newcap:   AsciiMathMl exposes non-constructor functions beginning with upper case letters
*/
/*jslint nomen: true, plusplus: true, newcap:true*/

/* depends:
 jxg
 options
 base/coords
 base/constants
 math/math
 math/geometry
 utils/type
 utils/env
*/

/**
 * @fileoverview JSXGraph can use various technologies to render the contents of a construction, e.g.
 * SVG, VML, and HTML5 Canvas. To accomplish this, The rendering and the logic and control mechanisms
 * are completely separated from each other. Every rendering technology has it&#x27;s own class, called
 * Renderer, e.g. SVGRenderer for SVG, the same for VML and Canvas. The common base for all available
 * renderers is the class AbstractRenderer defined in this file.
 */

define([
    &#x27;jxg&#x27;, &#x27;options&#x27;, &#x27;base/coords&#x27;, &#x27;base/constants&#x27;, &#x27;math/math&#x27;, &#x27;math/geometry&#x27;, &#x27;utils/type&#x27;, &#x27;utils/env&#x27;
], function (JXG, Options, Coords, Const, Mat, Geometry, Type, Env) {

    &quot;use strict&quot;;

    /**
     * This class defines the interface to the graphics part of JSXGraph. This class is an abstract class, it
     * actually does not render anything. This is up to the {@link JXG.SVGRenderer}, {@link JXG.VMLRenderer},
     * and {@link JXG.CanvasRenderer} classes. We strongly discourage you from using the methods in these classes
     * directly. Only the methods which are defined in this class and are not marked as private are guaranteed
     * to exist in any renderer instance you can access via {@link JXG.Board#renderer}. But not all methods may
     * work as expected.&lt;/p&gt;
     * &lt;p&gt;The methods of this renderer can be divided into different categories:
     * &lt;dl&gt;
     *     &lt;dt&gt;Draw basic elements&lt;/dt&gt;
     *     &lt;dd&gt;In this category we find methods to draw basic elements like {@link JXG.Point}, {@link JXG.Line},
     *     and {@link JXG.Curve} as well as assisting methods tightly bound to these basic painters. You do not
     *     need to implement these methods in a descendant renderer but instead implement the primitive drawing
     *     methods described below. This approach is encouraged when you&#x27;re using a XML based rendering engine
     *     like VML and SVG. If you want to use a bitmap based rendering technique you are supposed to override
     *     these methods instead of the primitive drawing methods.&lt;/dd&gt;
     *     &lt;dt&gt;Draw primitives&lt;/dt&gt;
     *     &lt;dd&gt;This category summarizes methods to handle primitive nodes. As creation and management of these nodes
     *     is different among different the rendering techniques most of these methods are purely virtual and need
     *     proper implementation if you choose to not overwrite the basic element drawing methods.&lt;/dd&gt;
     *     &lt;dt&gt;Attribute manipulation&lt;/dt&gt;
     *     &lt;dd&gt;In XML based renders you have to manipulate XML nodes and their attributes to change the graphics.
     *     For that purpose attribute manipulation methods are defined to set the color, opacity, and other things.
     *     Please note that some of these methods are required in bitmap based renderers, too, because some elements
     *     like {@link JXG.Text} can be HTML nodes floating over the construction.&lt;/dd&gt;
     *     &lt;dt&gt;Renderer control&lt;/dt&gt;
     *     &lt;dd&gt;Methods to clear the drawing board or to stop and to resume the rendering engine.&lt;/dd&gt;
     * &lt;/dl&gt;&lt;/p&gt;
     *
     * @class JXG.AbstractRenderer
     * @constructor
     * @see JXG.SVGRenderer
     * @see JXG.VMLRenderer
     * @see JXG.CanvasRenderer
     */
    JXG.AbstractRenderer = function () {

        // WHY THIS IS A CLASS INSTEAD OF A SINGLETON OBJECT:
        //
        // The renderers need to keep track of some stuff which is not always the same on different boards,
        // like enhancedRendering, reference to the container object, and resolution in VML. Sure, those
        // things could be stored in board. But they are rendering related and JXG.Board is already very
        // very big.
        //
        // And we can&#x27;t save the rendering related data in {SVG,VML,Canvas}Renderer and make only the
        // JXG.AbstractRenderer a singleton because of that:
        //
        // Given an object o with property a set to true
        //     var o = {a: true};
        // and a class c doing nothing
        //     c = function() {};
        // Set c&#x27;s prototype to o
        //     c.prototype = o;
        // and create an instance of c we get i.a to be true
        //     i = new c();
        //     i.a;
        //     &gt; true
        // But we can overwrite this property via
        //     c.prototype.a = false;
        //     i.a;
        //     &gt; false

        /**
         * The vertical offset for {@link Text} elements. Every {@link Text} element will
         * be placed this amount of pixels below the user given coordinates.
         *
         * @property vOffsetText
         * @type number
         * @default 8
         */
        this.vOffsetText = 0;

        /**
         * If this property is set to &lt;tt&gt;true&lt;/tt&gt; the visual properties of the elements are updated
         * on every update. Visual properties means: All the stuff stored in the
         * {@link JXG.GeometryElement#visProp} property won&#x27;t be set if enhancedRendering is &lt;tt&gt;false&lt;/tt&gt;
         *
         * @property enhancedRendering
         * @type Boolean
         * @default true
         */
        this.enhancedRendering = true;

        /**
         * The HTML element that stores the JSXGraph board in it.
         * @property container
         * @type Node
         */
        this.container = null;

        /**
         * This is used to easily determine which renderer we are using.
         * Possible values are &#x27;svg&#x27;, &#x27;vml&#x27;, &#x27;canvas&#x27;, &#x27;no&#x27;.
         *
         * @property type
         * @example
         *
         *     if (board.renderer.type === &#x27;vml&#x27;) {
          *        // do something
         *     }
         * @type String
         */
        this.type = &#x27;&#x27;;

        /**
         * True if the browsers&#x27; SVG engine supports foreignObject.
         * Not supporting browsers are IE 9 - 11.
         *
         * @property supportsForeignObject
         * @type Boolean
         * @private
         */
        this.supportsForeignObject = false;
    };

    JXG.extend(JXG.AbstractRenderer.prototype, /** @lends JXG.AbstractRenderer.prototype */ {

        /* ******************************** *
         *    private methods               *
         *    should not be called from     *
         *    outside AbstractRenderer      *
         * ******************************** */

        /**
         * Update visual properties, but only if {@link JXG.AbstractRenderer#enhancedRendering} or &lt;tt&gt;enhanced&lt;/tt&gt; is set to true.
         *
         * @method _updateVisual
         * @param {JXG.GeometryElement} element The element to update
         * @param {Object} [not={}] Select properties you don&#x27;t want to be updated: &lt;tt&gt;{fill: true, dash: true}&lt;/tt&gt; updates
         * everything except for fill and dash. Possible values are &lt;tt&gt;stroke, fill, dash, shadow, gradient&lt;/tt&gt;.
         * @param {Boolean} [enhanced=false] If true, {@link JXG.AbstractRenderer#enhancedRendering} is assumed to be true.
         * @private
         */
        _updateVisual: function (element, not, enhanced) {
            var rgbo;

            if (enhanced || this.enhancedRendering) {
                not = not || {};

                if (!element.visProp.draft) {
                    if (!not.stroke) {
                        this.setObjectStrokeColor(element, element.visProp.strokecolor, element.visProp.strokeopacity);
                        this.setObjectStrokeWidth(element, element.visProp.strokewidth);
                    }

                    if (!not.fill) {
                        this.setObjectFillColor(element, element.visProp.fillcolor, element.visProp.fillopacity);
                    }

                    if (!not.dash) {
                        this.setDashStyle(element, element.visProp);
                    }

                    if (!not.shadow) {
                        this.setShadow(element);
                    }

                    if (!not.gradient) {
                        this.setShadow(element);
                    }
                } else {
                    this.setDraft(element);
                }
            }
        },


        /* ******************************** *
         *    Point drawing and updating    *
         * ******************************** */

        /**
         * Draws a point on the {@link JXG.Board}.
         *
         * @method drawPoint
         * @param {JXG.Point} element Reference to a {@link JXG.Point} object that has to be drawn.
         * @see Point
         * @see JXG.Point
         * @see JXG.AbstractRenderer#updatePoint
         * @see JXG.AbstractRenderer#changePointStyle
         */
        drawPoint: function (element) {
            var prim,
                // sometimes element is not a real point and lacks the methods of a JXG.Point instance,
                // in these cases to not use element directly.
                face = Options.normalizePointFace(element.visProp.face);

            // determine how the point looks like
            if (face === &#x27;o&#x27;) {
                prim = &#x27;ellipse&#x27;;
            } else if (face === &#x27;[]&#x27;) {
                prim = &#x27;rect&#x27;;
            } else {
                // cross/x, diamond/&lt;&gt;, triangleup/a/^, triangledown/v, triangleleft/&lt;,
                // triangleright/&gt;, plus/+,
                prim = &#x27;path&#x27;;
            }

            element.rendNode = this.appendChildPrim(this.createPrim(prim, element.id), element.visProp.layer);
            this.appendNodesToElement(element, prim);

            // adjust visual propertys
            this._updateVisual(element, {dash: true, shadow: true}, true);


            // By now we only created the xml nodes and set some styles, in updatePoint
            // the attributes are filled with data.
            this.updatePoint(element);
        },

        /**
         * Updates visual appearance of the renderer element assigned to the given {@link JXG.Point}.
         *
         * @method updatePoint
         * @param {JXG.Point} element Reference to a {@link JXG.Point} object, that has to be updated.
         * @see Point
         * @see JXG.Point
         * @see JXG.AbstractRenderer#drawPoint
         * @see JXG.AbstractRenderer#changePointStyle
         */
        updatePoint: function (element) {
            var size = element.visProp.size,
                // sometimes element is not a real point and lacks the methods of a JXG.Point instance,
                // in these cases to not use element directly.
                face = Options.normalizePointFace(element.visProp.face);

            if (!isNaN(element.coords.scrCoords[2] + element.coords.scrCoords[1])) {
                this._updateVisual(element, {dash: false, shadow: false});
                size *= ((!element.board || !element.board.options.point.zoom) ? 1.0 : Math.sqrt(element.board.zoomX * element.board.zoomY));

                if (face === &#x27;o&#x27;) { // circle
                    this.updateEllipsePrim(element.rendNode, element.coords.scrCoords[1], element.coords.scrCoords[2], size + 1, size + 1);
                } else if (face === &#x27;[]&#x27;) { // rectangle
                    this.updateRectPrim(element.rendNode, element.coords.scrCoords[1] - size, element.coords.scrCoords[2] - size, size * 2, size * 2);
                } else { // x, +, &lt;&gt;, ^, v, &lt;, &gt;
                    this.updatePathPrim(element.rendNode, this.updatePathStringPoint(element, size, face), element.board);
                }
                this.setShadow(element);
            }
        },

        /**
         * Changes the style of a {@link JXG.Point}. This is required because the point styles differ in what
         * elements have to be drawn, e.g. if the point is marked by a &quot;x&quot; or a &quot;+&quot; two lines are drawn, if
         * it&#x27;s marked by spot a circle is drawn. This method removes the old renderer element(s) and creates
         * the new one(s).
         *
         * @method changePointStyle
         * @param {JXG.Point} element Reference to a {@link JXG.Point} object, that&#x27;s style is changed.
         * @see Point
         * @see JXG.Point
         * @see JXG.AbstractRenderer#updatePoint
         * @see JXG.AbstractRenderer#drawPoint
         */
        changePointStyle: function (element) {
            var node = this.getElementById(element.id);

            // remove the existing point rendering node
            if (Type.exists(node)) {
                this.remove(node);
            }

            // and make a new one
            this.drawPoint(element);
            Type.clearVisPropOld(element);

            if (!element.visProp.visible) {
                this.hide(element);
            }

            if (element.visProp.draft) {
                this.setDraft(element);
            }
        },

        /* ******************************** *
         *           Lines                  *
         * ******************************** */

        /**
         * Draws a line on the {@link JXG.Board}.
         *
         * @method drawLine
         * @param {JXG.Line} element Reference to a line object, that has to be drawn.
         * @see Line
         * @see JXG.Line
         * @see JXG.AbstractRenderer#updateLine
         */
        drawLine: function (element) {
            element.rendNode = this.appendChildPrim(this.createPrim(&#x27;line&#x27;, element.id), element.visProp.layer);
            this.appendNodesToElement(element, &#x27;lines&#x27;);
            this.updateLine(element);
        },

        /**
         * Updates visual appearance of the renderer element assigned to the given {@link JXG.Line}.
         *
         * @method updateLine
         * @param {JXG.Line} element Reference to the {@link JXG.Line} object that has to be updated.
         * @see Line
         * @see JXG.Line
         * @see JXG.AbstractRenderer#drawLine
         */
        updateLine: function (element) {
            var s, s1, s2, d, d1x, d1y, d2x, d2y,
                c1 = new Coords(Const.COORDS_BY_USER, element.point1.coords.usrCoords, element.board),
                c2 = new Coords(Const.COORDS_BY_USER, element.point2.coords.usrCoords, element.board),
                minlen = 10,
                margin = null;

            if (element.visProp.firstarrow || element.visProp.lastarrow) {
                margin = -4;
            }
            Geometry.calcStraight(element, c1, c2, margin);

            d1x = d1y = d2x = d2y = 0.0;
            /*
               Handle arrow heads.

               The arrow head is an equilateral triangle with base length 10 and height 10.
               These 10 units are scaled to strokeWidth*3 pixels or minlen pixels.
            */
            if (element.visProp.lastarrow || element.visProp.firstarrow) {

                s1 = element.point1.visProp.size;
                s2 = element.point2.visProp.size;
                s = s1 + s2;
                if (element.visProp.lastarrow &amp;&amp; element.visProp.touchlastpoint) {
                    d = c1.distance(Const.COORDS_BY_SCREEN, c2);
                    if (d &gt; s) {
                        d2x = (c2.scrCoords[1] - c1.scrCoords[1]) * s2 / d;
                        d2y = (c2.scrCoords[2] - c1.scrCoords[2]) * s2 / d;
                        c2 = new Coords(Const.COORDS_BY_SCREEN, [c2.scrCoords[1] - d2x, c2.scrCoords[2] - d2y], element.board);
                    }
                }
                if (element.visProp.firstarrow &amp;&amp; element.visProp.touchfirstpoint) {
                    d = c1.distance(Const.COORDS_BY_SCREEN, c2);
                    if (d &gt; s) {
                        d1x = (c2.scrCoords[1] - c1.scrCoords[1]) * s1 / d;
                        d1y = (c2.scrCoords[2] - c1.scrCoords[2]) * s1 / d;
                        c1 = new Coords(Const.COORDS_BY_SCREEN, [c1.scrCoords[1] + d1x, c1.scrCoords[2] + d1y], element.board);
                    }
                }

                s = Math.max(parseInt(element.visProp.strokewidth, 10) * 3, minlen);
                d = c1.distance(Const.COORDS_BY_SCREEN, c2);
                if (element.visProp.lastarrow &amp;&amp; element.board.renderer.type !== &#x27;vml&#x27; &amp;&amp; d &gt;= minlen) {
                    d2x = (c2.scrCoords[1] - c1.scrCoords[1]) * s / d;
                    d2y = (c2.scrCoords[2] - c1.scrCoords[2]) * s / d;
                }
                if (element.visProp.firstarrow &amp;&amp; element.board.renderer.type !== &#x27;vml&#x27; &amp;&amp; d &gt;= minlen) {
                    d1x = (c2.scrCoords[1] - c1.scrCoords[1]) * s / d;
                    d1y = (c2.scrCoords[2] - c1.scrCoords[2]) * s / d;
                }
            }

            this.updateLinePrim(element.rendNode,
                c1.scrCoords[1] + d1x, c1.scrCoords[2] + d1y,
                c2.scrCoords[1] - d2x, c2.scrCoords[2] - d2y, element.board);

            this.makeArrows(element);
            this._updateVisual(element);
        },

        /**
         * Creates a rendering node for ticks added to a line.
         *
         * @method drawTicks
         * @param {JXG.Line} element A arbitrary line.
         * @see Line
         * @see Ticks
         * @see JXG.Line
         * @see JXG.Ticks
         * @see JXG.AbstractRenderer#updateTicks
         */
        drawTicks: function (element) {
            element.rendNode = this.appendChildPrim(this.createPrim(&#x27;path&#x27;, element.id), element.visProp.layer);
            this.appendNodesToElement(element, &#x27;path&#x27;);
        },

        /**
         * Update {@link Ticks} on a {@link JXG.Line}. This method is only a stub and has to be implemented
         * in any descendant renderer class.
         *
         * @method updateTicks
         * @param {JXG.Ticks} element Reference of a ticks object that has to be updated.
         * @see Line
         * @see Ticks
         * @see JXG.Line
         * @see JXG.Ticks
         * @see JXG.AbstractRenderer#drawTicks
         */
        updateTicks: function (element) { /* stub */ },

        /* **************************
         *    Curves
         * **************************/

        /**
         * Draws a {@link JXG.Curve} on the {@link JXG.Board}.
         *
         * @method drawCurve
         * @param {JXG.Curve} element Reference to a graph object, that has to be plotted.
         * @see Curve
         * @see JXG.Curve
         * @see JXG.AbstractRenderer#updateCurve
         */
        drawCurve: function (element) {
            element.rendNode = this.appendChildPrim(this.createPrim(&#x27;path&#x27;, element.id), element.visProp.layer);
            this.appendNodesToElement(element, &#x27;path&#x27;);
            this._updateVisual(element, {shadow: true}, true);
            this.updateCurve(element);
        },

        /**
         * Updates visual appearance of the renderer element assigned to the given {@link JXG.Curve}.
         * @param {JXG.Curve} element Reference to a {@link JXG.Curve} object, that has to be updated.
         *
         * @method updateCurve
         * @see Curve
         * @see JXG.Curve
         * @see JXG.AbstractRenderer#drawCurve
         */
        updateCurve: function (element) {
            this._updateVisual(element);
            if (element.visProp.handdrawing) {
                this.updatePathPrim(element.rendNode, this.updatePathStringBezierPrim(element), element.board);
            } else {
                this.updatePathPrim(element.rendNode, this.updatePathStringPrim(element), element.board);
            }
            if (element.numberPoints &gt; 1) {
                this.makeArrows(element);
            }
        },

        /* -------------------------
         *    Circle related stuff
         * -------------------------*/

        /**
         * Draws a {@link JXG.Circle}
         *
         * @method drawEllipse
         * @param {JXG.Circle} element Reference to a {@link JXG.Circle} object that has to be drawn.
         * @see Circle
         * @see JXG.Circle
         * @see JXG.AbstractRenderer#updateEllipse
         */
        drawEllipse: function (element) {
            element.rendNode = this.appendChildPrim(this.createPrim(&#x27;ellipse&#x27;, element.id), element.visProp.layer);
            this.appendNodesToElement(element, &#x27;ellipse&#x27;);
            this.updateEllipse(element);
        },

        /**
         * Updates visual appearance of a given {@link JXG.Circle} on the {@link JXG.Board}.
         *
         * @method updateEllipse
         * @param {JXG.Circle} element Reference to a {@link JXG.Circle} object, that has to be updated.
         * @see Circle
         * @see JXG.Circle
         * @see JXG.AbstractRenderer#drawEllipse
         */
        updateEllipse: function (element) {
            this._updateVisual(element);

            var radius = element.Radius();

            if (radius &gt; 0.0 &amp;&amp;
                    Math.abs(element.center.coords.usrCoords[0]) &gt; Mat.eps &amp;&amp;
                    !isNaN(radius + element.center.coords.scrCoords[1] + element.center.coords.scrCoords[2]) &amp;&amp;
                    radius * element.board.unitX &lt; 2000000) {
                this.updateEllipsePrim(element.rendNode, element.center.coords.scrCoords[1],
                    element.center.coords.scrCoords[2], (radius * element.board.unitX), (radius * element.board.unitY));
            }
        },


        /* --------------------------
         *   Polygon related stuff
         * -------------------------*/

        /**
         * Draws a {@link JXG.Polygon} on the {@link JXG.Board}.
         *
         * @method drawPolygon
         * @param {JXG.Polygon} element Reference to a Polygon object, that is to be drawn.
         * @see Polygon
         * @see JXG.Polygon
         * @see JXG.AbstractRenderer#updatePolygon
         */
        drawPolygon: function (element) {
            element.rendNode = this.appendChildPrim(this.createPrim(&#x27;polygon&#x27;, element.id), element.visProp.layer);
            this.appendNodesToElement(element, &#x27;polygon&#x27;);
            this.updatePolygon(element);
        },

        /**
         * Updates properties of a {@link JXG.Polygon}&#x27;s rendering node.
         *
         * @method updatePolygon
         * @param {JXG.Polygon} element Reference to a {@link JXG.Polygon} object, that has to be updated.
         * @see Polygon
         * @see JXG.Polygon
         * @see JXG.AbstractRenderer#drawPolygon
         */
        updatePolygon: function (element) {
            var i, len, polIsReal;

            // here originally strokecolor wasn&#x27;t updated but strokewidth was
            // but if there&#x27;s no strokecolor i don&#x27;t see why we should update strokewidth.
            this._updateVisual(element, {stroke: true, dash: true});
            this.updatePolygonPrim(element.rendNode, element);

            len = element.vertices.length;
            polIsReal = true;
            for (i = 0; i &lt; len; ++i) {
                if (!element.vertices[i].isReal) {
                    polIsReal = false;
                    break;
                }
            }

            len = element.borders.length;
            for (i = 0; i &lt; len; ++i) {
                if (polIsReal &amp;&amp; element.borders[i].visProp.visible) {
                    this.show(element.borders[i]);
                } else {
                    this.hide(element.borders[i]);
                }
            }
        },

        /* --------------------------
         *    Text related stuff
         * -------------------------*/

        /**
         * Shows a small copyright notice in the top left corner of the board.
         *
         * @method displayCopyright
         * @param {String} str The copyright notice itself
         * @param {Number} fontsize Size of the font the copyright notice is written in
         */
        displayCopyright: function (str, fontsize) { /* stub */ },

        /**
         * An internal text is a {@link JXG.Text} element which is drawn using only
         * the given renderer but no HTML. This method is only a stub, the drawing
         * is done in the special renderers.
         *
         * @method drawInternalText
         * @param {JXG.Text} element Reference to a {@link JXG.Text} object
         * @see Text
         * @see JXG.Text
         * @see JXG.AbstractRenderer#updateInternalText
         * @see JXG.AbstractRenderer#drawText
         * @see JXG.AbstractRenderer#updateText
         * @see JXG.AbstractRenderer#updateTextStyle
         */
        drawInternalText: function (element) { /* stub */ },

        /**
         * Updates visual properties of an already existing {@link JXG.Text} element.
         *
         * @method updateInternalText
         * @param {JXG.Text} element Reference to an {@link JXG.Text} object, that has to be updated.
         * @see Text
         * @see JXG.Text
         * @see JXG.AbstractRenderer#drawInternalText
         * @see JXG.AbstractRenderer#drawText
         * @see JXG.AbstractRenderer#updateText
         * @see JXG.AbstractRenderer#updateTextStyle
         */
        updateInternalText: function (element) { /* stub */ },

        /**
         * Displays a {@link JXG.Text} on the {@link JXG.Board} by putting a HTML div over it.
         *
         * @method drawText
         * @param {JXG.Text} element Reference to an {@link JXG.Text} object, that has to be displayed
         * @see Text
         * @see JXG.Text
         * @see JXG.AbstractRenderer#drawInternalText
         * @see JXG.AbstractRenderer#updateText
         * @see JXG.AbstractRenderer#updateInternalText
         * @see JXG.AbstractRenderer#updateTextStyle
         */
        drawText: function (element) {
            var node, z, level;

            if (element.visProp.display === &#x27;html&#x27; &amp;&amp; Env.isBrowser) {
                node = this.container.ownerDocument.createElement(&#x27;div&#x27;);
                node.style.position = &#x27;absolute&#x27;;

                node.className = element.visProp.cssclass;

                /* SVG renderer - beside IE 9-11 - support foreignObject. This
                   is used to host the HTML. Then, conversion to canvas works also
                   for HTML text.
                 */
                if (this.supportsForeignObject) {
                    level = element.visProp.layer;
                    if (!Type.exists(level)) { // trace nodes have level not set
                        level = 0;
                    } else if (level &gt;= Options.layer.numlayers) {
                        level = Options.layer.numlayers - 1;
                    }
                    this.foreignObjLayer[level].appendChild(node);
                } else {
                    if (this.container.style.zIndex === &#x27;&#x27;) {
                        z = 0;
                    } else {
                        z = parseInt(this.container.style.zIndex, 10);
                    }

                    node.style.zIndex = z + element.board.options.layer.text;
                    this.container.appendChild(node);
                }

                node.setAttribute(&#x27;id&#x27;, this.container.id + &#x27;_&#x27; + element.id);
            } else {
                node = this.drawInternalText(element);
            }

            element.rendNode = node;
            element.htmlStr = &#x27;&#x27;;
            this.updateText(element);
        },

        /**
         * Updates visual properties of an already existing {@link JXG.Text} element.
         *
         * @method updateText
         * @param {JXG.Text} el Reference to an {@link JXG.Text} object, that has to be updated.
         * @see Text
         * @see JXG.Text
         * @see JXG.AbstractRenderer#drawText
         * @see JXG.AbstractRenderer#drawInternalText
         * @see JXG.AbstractRenderer#updateInternalText
         * @see JXG.AbstractRenderer#updateTextStyle
         */
        updateText: function (el) {
            var content = el.plaintext, v, c, parentNode;

            if (el.visProp.visible) {
                this.updateTextStyle(el, false);

                if (el.visProp.display === &#x27;html&#x27;) {
                    // Set the position
                    if (!isNaN(el.coords.scrCoords[1] + el.coords.scrCoords[2])) {

                        // Horizontal
                        c = el.coords.scrCoords[1];
                        // webkit seems to fail for extremely large values for c.
                        c = Math.abs(c) &lt; 1000000 ? c : 1000000;

                        if (el.visProp.anchorx === &#x27;right&#x27;) {
                            v = Math.floor(el.board.canvasWidth - c);
                        } else if (el.visProp.anchorx === &#x27;middle&#x27;) {
                            v = Math.floor(c - 0.5 * el.size[0]);
                        } else { // &#x27;left&#x27;
                            v = Math.floor(c);
                        }

                        if (el.visPropOld.left !== (el.visProp.anchorx + v)) {
                            if (el.visProp.anchorx === &#x27;right&#x27;) {
                                el.rendNode.style.right = v + &#x27;px&#x27;;
                                el.rendNode.style.left = &#x27;auto&#x27;;
                            } else {
                                el.rendNode.style.left = v + &#x27;px&#x27;;
                                el.rendNode.style.right = &#x27;auto&#x27;;
                            }
                            el.visPropOld.left = el.visProp.anchorx + v;
                        }

                        // Vertical
                        c = el.coords.scrCoords[2] + this.vOffsetText;
                        c = Math.abs(c) &lt; 1000000 ? c : 1000000;

                        if (el.visProp.anchory === &#x27;bottom&#x27;) {
                            v = Math.floor(el.board.canvasHeight - c);
                        } else if (el.visProp.anchory === &#x27;middle&#x27;) {
                            v = Math.floor(c - 0.5 * el.size[1]);
                        } else { // top
                            v = Math.floor(c);
                        }

                        if (el.visPropOld.top !== (el.visProp.anchory + v)) {
                            if (el.visProp.anchory === &#x27;bottom&#x27;) {
                                el.rendNode.style.top = &#x27;auto&#x27;;
                                el.rendNode.style.bottom = v + &#x27;px&#x27;;
                            } else {
                                el.rendNode.style.bottom = &#x27;auto&#x27;;
                                el.rendNode.style.top = v + &#x27;px&#x27;;
                            }
                            el.visPropOld.top = el.visProp.anchory + v;
                        }
                    }

                    // Set the content
                    if (el.htmlStr !== content) {
                        try {
                            el.rendNode.innerHTML = content;
                        } catch (e) {
                            // Setting innerHTML sometimes fails in IE8. A workaround is to
                            // take the node off the DOM, assign innerHTML, then append back.
                            // Works for text elements as they are absolutely positioned.
                            parentNode = el.rendNode.parentNode;
                            el.rendNode.parentNode.removeChild(el.rendNode);
                            el.rendNode.innerHTML = content;
                            parentNode.appendChild(el.rendNode);
                        }
                        el.htmlStr = content;

                        if (el.visProp.usemathjax) {
                            // typesetting directly might not work because mathjax was not loaded completely
                            // see http://www.mathjax.org/docs/1.1/typeset.html
                            MathJax.Hub.Queue([&#x27;Typeset&#x27;, MathJax.Hub, el.rendNode]);
                        } else if (el.visProp.useasciimathml) {
                            // This is not a constructor.
                            // See http://www1.chapman.edu/~jipsen/mathml/asciimath.html for more information
                            // about AsciiMathML and the project&#x27;s source code.
                            AMprocessNode(el.rendNode, false);
                        }
                    }
                    this.transformImage(el, el.transformations);
                } else {
                    this.updateInternalText(el);
                }
            }
        },

        /**
         * Updates font-size, color and opacity propertiey and CSS style properties of a {@link JXG.Text} node.
         * This function is also called by highlight() and nohighlight().
         *
         * @method updateTextStyle
         * @param {JXG.Text} element Reference to the {@link JXG.Text} object, that has to be updated.
         * @param {Boolean} doHighlight
         * @see Text
         * @see JXG.Text
         * @see JXG.AbstractRenderer#drawText
         * @see JXG.AbstractRenderer#drawInternalText
         * @see JXG.AbstractRenderer#updateText
         * @see JXG.AbstractRenderer#updateInternalText
         * @see JXG.AbstractRenderer#updateInternalTextStyle
         */
        updateTextStyle: function (element, doHighlight) {
            var fs, so, sc, css,
                ev = element.visProp,
                display = Env.isBrowser ? ev.display : &#x27;internal&#x27;;

            if (doHighlight) {
                sc = ev.highlightstrokecolor;
                so = ev.highlightstrokeopacity;
                css = ev.highlightcssclass;
            } else {
                sc = ev.strokecolor;
                so = ev.strokeopacity;
                css = ev.cssclass;
            }

            // This part is executed for all text elements except internal texts in canvas.
            if (display === &#x27;html&#x27; || (this.type !== &#x27;canvas&#x27; &amp;&amp; this.type !== &#x27;no&#x27;)) {
                fs = Type.evaluate(element.visProp.fontsize);
                if (element.visPropOld.fontsize !== fs) {
                    element.needsSizeUpdate = true;
                    try {
                        element.rendNode.style.fontSize = fs + &#x27;px&#x27;;
                    } catch (e) {
                        // IE needs special treatment.
                        element.rendNode.style.fontSize = fs;
                    }
                    element.visPropOld.fontsize = fs;
                }

            }

            if (display === &#x27;html&#x27;) {
                if (element.visPropOld.cssclass !== css) {
                    element.rendNode.className = css;
                    element.visPropOld.cssclass = css;
                    element.needsSizeUpdate = true;
                }
                this.setObjectStrokeColor(element, sc, so);
            } else {
                this.updateInternalTextStyle(element, sc, so);
            }
            return this;
        },

        /**
         * Set color and opacity of internal texts.
         * This method is used for Canvas and VML.
         * SVG needs its own version.
         *
         * @method updateInternalTextStyle
         * @private
         * @see JXG.AbstractRenderer#updateTextStyle
         * @see JXG.SVGRenderer#updateInternalTextStyle
         */
        updateInternalTextStyle: function (element, strokeColor, strokeOpacity) {
            this.setObjectStrokeColor(element, strokeColor, strokeOpacity);
        },

        /* -------------------------
         *    Image related stuff
         * ------------------------*/

        /**
         * Draws an {@link JXG.Image} on a board; This is just a template that has to be implemented by special
         * renderers.
         * @method drawImage
         * @param {JXG.Image} element Reference to the image object that is to be drawn
         * @see Image
         * @see JXG.Image
         * @see JXG.AbstractRenderer#updateImage
         */
        drawImage: function (element) { /* stub */ },

        /**
         * Updates the properties of an {@link JXG.Image} element.
         *
         * @method updateImage
         * @param {JXG.Image} element Reference to an {@link JXG.Image} object, that has to be updated.
         * @see Image
         * @see JXG.Image
         * @see JXG.AbstractRenderer#drawImage
         */
        updateImage: function (element) {
            this.updateRectPrim(element.rendNode, element.coords.scrCoords[1],
                element.coords.scrCoords[2] - element.size[1], element.size[0], element.size[1]);

            this.updateImageURL(element);
            this.transformImage(element, element.transformations);
            this._updateVisual(element, {stroke: true, dash: true}, true);
        },

        /**
         * Multiplication of transformations without updating. That means, at that point it is expected that the
         * matrices contain numbers only. First, the origin in user coords is translated to &lt;tt&gt;(0,0)&lt;/tt&gt; in screen
         * coords. Then, the stretch factors are divided out. After the transformations in user coords, the stretch
         * factors are multiplied in again, and the origin in user coords is translated back to its position. This
         * method does not have to be implemented in a new renderer.
         *
         * @method joinTransforms
         * @param {JXG.GeometryElement} element A JSXGraph element. We only need its board property.
         * @param {Array} transformations An array of JXG.Transformations.
         * @return {Array} A matrix represented by a two dimensional array of numbers.
         * @see JXG.AbstractRenderer#transformImage
         */
        joinTransforms: function (element, transformations) {
            var i,
                ox = element.board.origin.scrCoords[1],
                oy = element.board.origin.scrCoords[2],
                ux = element.board.unitX,
                uy = element.board.unitY,
                // Translate to 0,0 in screen coords
                /*
                m = [[1, 0, 0], [0, 1, 0], [0, 0, 1]],
                mpre1 =  [[1,   0, 0],
                    [-ox, 1, 0],
                    [-oy, 0, 1]],
                // Scale
                mpre2 =  [[1, 0,     0],
                    [0, 1 / ux,  0],
                    [0, 0, -1 / uy]],
                // Scale back
                mpost2 = [[1, 0,   0],
                    [0, ux,  0],
                    [0, 0, -uy]],
                // Translate back
                mpost1 = [[1,  0, 0],
                    [ox, 1, 0],
                    [oy, 0, 1]],
                */
                len = transformations.length,
                // Translate to 0,0 in screen coords and then scale
                m = [[1,        0,       0],
                     [-ox / ux, 1 / ux,  0],
                     [ oy / uy, 0, -1 / uy]];

            for (i = 0; i &lt; len; i++) {
                //m = Mat.matMatMult(mpre1, m);
                //m = Mat.matMatMult(mpre2, m);
                m = Mat.matMatMult(transformations[i].matrix, m);
                //m = Mat.matMatMult(mpost2, m);
                //m = Mat.matMatMult(mpost1, m);
            }
            // Scale back and then translate back
            m = Mat.matMatMult([[1,   0, 0],
                                [ox, ux, 0],
                                [oy,  0, -uy]], m);
            return m;
        },

        /**
         * Applies transformations on images and text elements. This method is just a stub and has to be implemented in
         * all descendant classes where text and image transformations are to be supported.
         *
         * @method transformImage
         * @param {JXG.Image|JXG.Text} element A {@link JXG.Image} or {@link JXG.Text} object.
         * @param {Array} transformations An array of {@link JXG.Transformation} objects. This is usually the
         * transformations property of the given element &lt;tt&gt;el&lt;/tt&gt;.
         */
        transformImage: function (element, transformations) { /* stub */ },

        /**
         * If the URL of the image is provided by a function the URL has to be updated during updateImage()
         * @param {JXG.Image} element Reference to an image object.
         *
         * @method updateImageURL
         * @see JXG.AbstractRenderer#updateImage
         */
        updateImageURL: function (element) { /* stub */ },

        /**
         * Updates CSS style properties of a {@link JXG.Image} node.
         * In SVGRenderer opacity is the only available style element.
         * This function is called by highlight() and nohighlight().
         * This function works for VML.
         * It does not work for Canvas.
         * SVGRenderer overwrites this method.
         *
         * @method updateImageStyle
         * @param {JXG.Text} el Reference to the {@link JXG.Image} object, that has to be updated.
         * @param {Boolean} doHighlight
         * @see Image
         * @see JXG.Image
         * @see JXG.AbstractRenderer#highlight
         * @see JXG.AbstractRenderer#noHighlight
         */
        updateImageStyle: function (el, doHighlight) {
            el.rendNode.className = doHighlight ? el.visProp.highlightcssclass : el.visProp.cssclass;
        },


        /* -------------------------
         * Render primitive objects
         * ------------------------*/

        /**
         * Appends a node to a specific layer level. This is just an abstract method and has to be implemented
         * in all renderers that want to use the &lt;tt&gt;createPrim&lt;/tt&gt; model to draw.
         *
         * @method appendChildPrim
         * @param {Node} node A DOM tree node.
         * @param {Number} level The layer the node is attached to. This is the index of the layer in
         * {@link JXG.SVGRenderer#layer} or the &lt;tt&gt;z-index&lt;/tt&gt; style property of the node in VMLRenderer.
         */
        appendChildPrim: function (node, level) { /* stub */ },

        /**
         * Stores the rendering nodes. This is an abstract method which has to be implemented in all renderers that use
         * the &lt;tt&gt;createPrim&lt;/tt&gt; method.
         *
         * @method appendNodesToElement
         * @param {JXG.GeometryElement} element A JSXGraph element.
         * @param {String} type The XML node name. Only used in VMLRenderer.
         */
        appendNodesToElement: function (element, type) { /* stub */ },

        /**
         * Creates a node of a given type with a given id.
         *
         * @method createPrim
         * @param {String} type The type of the node to create.
         * @param {String} id Set the id attribute to this.
         * @return {Node} Reference to the created node.
         */
        createPrim: function (type, id) {
            /* stub */
            return null;
        },

        /**
         * Removes an element node. Just a stub.
         *
         * @method remove
         * @param {Node} node The node to remove.
         */
        remove: function (node) { /* stub */ },

        /**
         * Can be used to create the nodes to display arrows. This is an abstract method which has to be implemented
         * in any descendant renderer.
         *
         * @method makeArrows
         * @param {JXG.GeometryElement} element The element the arrows are to be attached to.
         */
        makeArrows: function (element) { /* stub */ },

        /**
         * Updates an ellipse node primitive. This is an abstract method which has to be implemented in all renderers
         * that use the &lt;tt&gt;createPrim&lt;/tt&gt; method.
         *
         * @method updateEllipsePrim
         * @param {Node} node Reference to the node.
         * @param {Number} x Centre X coordinate
         * @param {Number} y Centre Y coordinate
         * @param {Number} rx The x-axis radius.
         * @param {Number} ry The y-axis radius.
         */
        updateEllipsePrim: function (node, x, y, rx, ry) { /* stub */ },

        /**
         * Refreshes a line node. This is an abstract method which has to be implemented in all renderers that use
         * the &lt;tt&gt;createPrim&lt;/tt&gt; method.
         *
         * @method updateLinePrim
         * @param {Node} node The node to be refreshed.
         * @param {Number} p1x The first point&#x27;s x coordinate.
         * @param {Number} p1y The first point&#x27;s y coordinate.
         * @param {Number} p2x The second point&#x27;s x coordinate.
         * @param {Number} p2y The second point&#x27;s y coordinate.
         * @param {JXG.Board} board
         */
        updateLinePrim: function (node, p1x, p1y, p2x, p2y, board) { /* stub */ },

        /**
         * Updates a path element. This is an abstract method which has to be implemented in all renderers that use
         * the &lt;tt&gt;createPrim&lt;/tt&gt; method.
         *
         * @method updatePathPrim
         * @param {Node} node The path node.
         * @param {String} pathString A string formatted like e.g. &lt;em&gt;&#x27;M 1,2 L 3,1 L5,5&#x27;&lt;/em&gt;. The format of the string
         * depends on the rendering engine.
         * @param {JXG.Board} board Reference to the element&#x27;s board.
         */
        updatePathPrim: function (node, pathString, board) { /* stub */ },

        /**
         * Builds a path data string to draw a point with a face other than &lt;em&gt;rect&lt;/em&gt; and &lt;em&gt;circle&lt;/em&gt;. Since
         * the format of such a string usually depends on the renderer this method
         * is only an abstract method. Therefore, it has to be implemented in the descendant renderer itself unless
         * the renderer does not use the createPrim interface but the draw* interfaces to paint.
         *
         * @method updatePathStringPoint
         * @param {JXG.Point} element The point element
         * @param {Number} size A positive number describing the size. Usually the half of the width and height of
         * the drawn point.
         * @param {String} type A string describing the point&#x27;s face. This method only accepts the shortcut version of
         * each possible face: &lt;tt&gt;x, +, &lt;&gt;, ^, v, &gt;, &lt;
         */
        updatePathStringPoint: function (element, size, type) { /* stub */ },

        /**
         * Builds a path data string from a {@link JXG.Curve} element. Since the path data strings heavily depend on the
         * underlying rendering technique this method is just a stub. Although such a path string is of no use for the
         * CanvasRenderer, this method is used there to draw a path directly.
         *
         * @method updatePathStringPrim
         * @param element
         */
        updatePathStringPrim: function (element) { /* stub */ },

        /**
         * Builds a path data string from a {@link JXG.Curve} element such that the curve looks like hand drawn. Since
         * the path data strings heavily depend on the underlying rendering technique this method is just a stub.
         * Although such a path string is of no use for the CanvasRenderer, this method is used there to draw a path
         * directly.
         *
         * @method updatePathStringBezierPrim
         * @param element
         */
        updatePathStringBezierPrim: function (element) { /* stub */ },

        /**
         * Update a polygon primitive.
         *
         * @method updatePolygonPrim
         * @param {Node} node
         * @param {JXG.Polygon} element A JSXGraph element of type {@link JXG.Polygon}
         */
        updatePolygonPrim: function (node, element) { /* stub */ },

        /**
         * Update a rectangle primitive. This is used only for points with face of type &#x27;rect&#x27;.
         *
         * @method updateRectPrim
         * @param {Node} node The node yearning to be updated.
         * @param {Number} x x coordinate of the top left vertex.
         * @param {Number} y y coordinate of the top left vertex.
         * @param {Number} w Width of the rectangle.
         * @param {Number} h The rectangle&#x27;s height.
         */
        updateRectPrim: function (node, x, y, w, h) { /* stub */ },

        /* --------------------------
         *  Set Attributes
         * -------------------------*/

        /**
         * Sets a node&#x27;s attribute.
         *
         * @method setPropertyPrim
         * @param {Node} node The node that is to be updated.
         * @param {String} key Name of the attribute.
         * @param {String} val New value for the attribute.
         */
        setPropertyPrim: function (node, key, val) { /* stub */ },

        /**
         * Shows a hidden element on the canvas; Only a stub, requires implementation in the derived renderer.
         *
         * @method show
         * @param {JXG.GeometryElement} element Reference to the object that has to appear.
         * @see JXG.AbstractRenderer#hide
         */
        show: function (element) { /* stub */ },

        /**
         * Hides an element on the canvas; Only a stub, requires implementation in the derived renderer.
         *
         * @method hide
         * @param {JXG.GeometryElement} element Reference to the geometry element that has to disappear.
         * @see JXG.AbstractRenderer#show
         */
        hide: function (element) { /* stub */ },

        /**
         * Sets the buffering as recommended by SVGWG. Until now only Opera supports this and will be ignored by other
         * browsers. Although this feature is only supported by SVG we have this method in {@link JXG.AbstractRenderer}
         * because it is called from outside the renderer.
         *
         * @method setBuffering
         * @param {Node} node The SVG DOM Node which buffering type to update.
         * @param {String} type Either &#x27;auto&#x27;, &#x27;dynamic&#x27;, or &#x27;static&#x27;. For an explanation see
         *   {@link http://www.w3.org/TR/SVGTiny12/painting.html#BufferedRenderingProperty}.
         */
        setBuffering: function (node, type) { /* stub */ },

        /**
         * Sets an element&#x27;s dash style.
         *
         * @method setDashStyle
         * @param {JXG.GeometryElement} element An JSXGraph element.
         */
        setDashStyle: function (element) { /* stub */ },

        /**
         * Puts an object into draft mode, i.e. it&#x27;s visual appearance will be changed. For GEONE&lt;sub&gt;x&lt;/sub&gt;T backwards
         * compatibility.
         *
         * @method setDraft
         * @param {JXG.GeometryElement} element Reference of the object that is in draft mode.
         */
        setDraft: function (element) {
            if (!element.visProp.draft) {
                return;
            }
            var draftColor = element.board.options.elements.draft.color,
                draftOpacity = element.board.options.elements.draft.opacity;

            if (element.type === Const.OBJECT_TYPE_POLYGON) {
                this.setObjectFillColor(element, draftColor, draftOpacity);
            } else {
                if (element.elementClass === Const.OBJECT_CLASS_POINT) {
                    this.setObjectFillColor(element, draftColor, draftOpacity);
                } else {
                    this.setObjectFillColor(element, &#x27;none&#x27;, 0);
                }
                this.setObjectStrokeColor(element, draftColor, draftOpacity);
                this.setObjectStrokeWidth(element, element.board.options.elements.draft.strokeWidth);
            }
        },

        /**
         * Puts an object from draft mode back into normal mode.
         *
         * @method removeDraft
         * @param {JXG.GeometryElement} element Reference of the object that no longer is in draft mode.
         */
        removeDraft: function (element) {
            if (element.type === Const.OBJECT_TYPE_POLYGON) {
                this.setObjectFillColor(element, element.visProp.fillcolor, element.visProp.fillopacity);
            } else {
                if (element.type === Const.OBJECT_CLASS_POINT) {
                    this.setObjectFillColor(element, element.visProp.fillcolor, element.visProp.fillopacity);
                }
                this.setObjectStrokeColor(element, element.visProp.strokecolor, element.visProp.strokeopacity);
                this.setObjectStrokeWidth(element, element.visProp.strokewidth);
            }
        },

        /**
         * Sets up nodes for rendering a gradient fill.
         *
         * @method setGradient
         * @param element
         */
        setGradient: function (element) { /* stub */ },

        /**
         * Updates the gradient fill.
         *
         * @method updateGradient
         * @param {JXG.GeometryElement} element An JSXGraph element with an area that can be filled.
         */
        updateGradient: function (element) { /* stub */ },

        /**
         * Sets an objects fill color.
         *
         * @method setObjectFillColor
         * @param {JXG.GeometryElement} element Reference of the object that wants a new fill color.
         * @param {String} color Color in a HTML/CSS compatible format. If you don&#x27;t want any fill color at all, choose
         * &#x27;none&#x27;.
         * @param {Number} opacity Opacity of the fill color. Must be between 0 and 1.
         */
        setObjectFillColor: function (element, color, opacity) { /* stub */ },

        /**
         * Changes an objects stroke color to the given color.
         *
         * @method setObjectStrokeColor
         * @param {JXG.GeometryElement} element Reference of the {@link JXG.GeometryElement} that gets a new stroke
         * color.
         * @param {String} color Color value in a HTML compatible format, e.g. &lt;strong&gt;#00ff00&lt;/strong&gt; or
         * &lt;strong&gt;green&lt;/strong&gt; for green.
         * @param {Number} opacity Opacity of the fill color. Must be between 0 and 1.
         */
        setObjectStrokeColor: function (element, color, opacity) { /* stub */ },

        /**
         * Sets an element&#x27;s stroke width.
         *
         * @method setObjectStrokeWidth
         * @param {JXG.GeometryElement} element Reference to the geometry element.
         * @param {Number} width The new stroke width to be assigned to the element.
         */
        setObjectStrokeWidth: function (element, width) { /* stub */ },

        /**
         * Sets the shadow properties to a geometry element. This method is only a stub, it is implemented in the actual
         * renderers.
         *
         * @method setShadow
         * @param {JXG.GeometryElement} element Reference to a geometry object, that should get a shadow
         */
        setShadow: function (element) { /* stub */ },

        /**
         * Highlights an object, i.e. changes the current colors of the object to its highlighting colors
         *
         * @method highlight
         * @param {JXG.GeometryElement} element Reference of the object that will be highlighted.
         * @return {JXG.AbstractRenderer} Reference to the renderer
         * @see JXG.AbstractRenderer#updateTextStyle
         */
        highlight: function (element) {
            var i, ev = element.visProp;

            if (!ev.draft) {
                if (element.type === Const.OBJECT_TYPE_POLYGON) {
                    this.setObjectFillColor(element, ev.highlightfillcolor, ev.highlightfillopacity);
                    for (i = 0; i &lt; element.borders.length; i++) {
                        this.setObjectStrokeColor(element.borders[i], element.borders[i].visProp.highlightstrokecolor,
                            element.borders[i].visProp.highlightstrokeopacity);
                    }
                } else {
                    if (element.elementClass === Const.OBJECT_CLASS_TEXT) {
                        this.updateTextStyle(element, true);
                    } else if (element.type === Const.OBJECT_TYPE_IMAGE) {
                        this.updateImageStyle(element, true);
                    } else {
                        this.setObjectStrokeColor(element, ev.highlightstrokecolor, ev.highlightstrokeopacity);
                        this.setObjectFillColor(element, ev.highlightfillcolor, ev.highlightfillopacity);
                    }
                }
                if (ev.highlightstrokewidth) {
                    this.setObjectStrokeWidth(element, Math.max(ev.highlightstrokewidth, ev.strokewidth));
                }
            }

            return this;
        },

        /**
         * Uses the normal colors of an object, i.e. the opposite of {@link JXG.AbstractRenderer#highlight}.
         *
         * @method noHighlight
         * @param {JXG.GeometryElement} element Reference of the object that will get its normal colors.
         * @return {JXG.AbstractRenderer} Reference to the renderer
         * @see JXG.AbstractRenderer#updateTextStyle
         */
        noHighlight: function (element) {
            var i, ev = element.visProp;

            if (!element.visProp.draft) {
                if (element.type === Const.OBJECT_TYPE_POLYGON) {
                    this.setObjectFillColor(element, ev.fillcolor, ev.fillopacity);
                    for (i = 0; i &lt; element.borders.length; i++) {
                        this.setObjectStrokeColor(element.borders[i], element.borders[i].visProp.strokecolor,
                            element.borders[i].visProp.strokeopacity);
                    }
                } else {
                    if (element.elementClass === Const.OBJECT_CLASS_TEXT) {
                        this.updateTextStyle(element, false);
                    } else if (element.type === Const.OBJECT_TYPE_IMAGE) {
                        this.updateImageStyle(element, false);
                    } else {
                        this.setObjectStrokeColor(element, ev.strokecolor, ev.strokeopacity);
                        this.setObjectFillColor(element, ev.fillcolor, ev.fillopacity);
                    }
                }
                this.setObjectStrokeWidth(element, ev.strokewidth);
            }

            return this;
        },

        /* -------------------------
         * renderer control
         * ------------------------*/

        /**
         * Stop redraw. This method is called before every update, so a non-vector-graphics based renderer can use this
         * method to delete the contents of the drawing panel. This is an abstract method every descendant renderer
         * should implement, if appropriate.
         *
         * @method suspendRedraw
         * @see JXG.AbstractRenderer#unsuspendRedraw
         */
        suspendRedraw: function () { /* stub */ },

        /**
         * Restart redraw. This method is called after updating all the rendering node attributes.
         *
         * @method unsuspendRedraw
         * @see JXG.AbstractRenderer#suspendRedraw
         */
        unsuspendRedraw: function () { /* stub */ },

        /**
         * The tiny zoom bar shown on the bottom of a board (if showNavigation on board creation is true).
         *
         * @method drawZoomBar
         * @param {JXG.Board} board Reference to a JSXGraph board.
         */
        drawZoomBar: function (board) {
            var doc,
                node,
                cancelbubble = function (e) {
                    if (!e) {
                        e = window.event;
                    }

                    if (e.stopPropagation) {
                        // Non IE&lt;=8
                        e.stopPropagation();
                    } else {
                        e.cancelBubble = true;
                    }
                },
                createButton = function (label, handler) {
                    var button;

                    button = doc.createElement(&#x27;span&#x27;);
                    node.appendChild(button);
                    button.appendChild(doc.createTextNode(label));
                    Env.addEvent(button, &#x27;mouseover&#x27;, function () {
                        this.style.backgroundColor = board.options.navbar.highlightFillColor;
                    }, button);
                    Env.addEvent(button, &#x27;mouseover&#x27;, function () {
                        this.style.backgroundColor = board.options.navbar.highlightFillColor;
                    }, button);
                    Env.addEvent(button, &#x27;mouseout&#x27;, function () {
                        this.style.backgroundColor = board.options.navbar.fillColor;
                    }, button);

                    Env.addEvent(button, &#x27;click&#x27;, function(e) { (Type.bind(handler, board))(); return false; }, board);
                    // prevent the click from bubbling down to the board
                    Env.addEvent(button, &#x27;mouseup&#x27;, cancelbubble, board);
                    Env.addEvent(button, &#x27;mousedown&#x27;, cancelbubble, board);
                    Env.addEvent(button, &#x27;touchend&#x27;, cancelbubble, board);
                    Env.addEvent(button, &#x27;touchstart&#x27;, cancelbubble, board);
                };

            if (Env.isBrowser) {
                doc = board.containerObj.ownerDocument;
                node = doc.createElement(&#x27;div&#x27;);

                node.setAttribute(&#x27;id&#x27;, board.containerObj.id + &#x27;_navigationbar&#x27;);

                node.style.color = board.options.navbar.strokeColor;
                node.style.backgroundColor = board.options.navbar.fillColor;
                node.style.padding = board.options.navbar.padding;
                node.style.position = board.options.navbar.position;
                node.style.fontSize = board.options.navbar.fontSize;
                node.style.cursor = board.options.navbar.cursor;
                node.style.zIndex = board.options.navbar.zIndex;
                board.containerObj.appendChild(node);
                node.style.right = board.options.navbar.right;
                node.style.bottom = board.options.navbar.bottom;

                // For XHTML we need unicode instead of HTML entities

                if (board.attr.showreload) {
                    // full reload circle: \u27F2
                    // the board.reload() method does not exist during the creation
                    // of this button. That&#x27;s why this anonymous function wrapper is required.
                    createButton(&#x27;\u00A0\u21BB\u00A0&#x27;, function () {
                        board.reload();
                    });
                }

                if (board.attr.showcleartraces) {
                    // clear traces symbol (otimes): \u27F2
                    createButton(&#x27;\u00A0\u2297\u00A0&#x27;, function () {
                        board.clearTraces();
                    });
                }

                if (board.attr.shownavigation) {
                    createButton(&#x27;\u00A0\u2013\u00A0&#x27;, board.zoomOut);
                    createButton(&#x27;\u00A0o\u00A0&#x27;, board.zoom100);
                    createButton(&#x27;\u00A0+\u00A0&#x27;, board.zoomIn);
                    createButton(&#x27;\u00A0\u2190\u00A0&#x27;, board.clickLeftArrow);
                    createButton(&#x27;\u00A0\u2193\u00A0&#x27;, board.clickUpArrow);
                    createButton(&#x27;\u00A0\u2191\u00A0&#x27;, board.clickDownArrow);
                    createButton(&#x27;\u00A0\u2192\u00A0&#x27;, board.clickRightArrow);
                }
            }
        },

        /**
         * Wrapper for getElementById for maybe other renderers which elements are not directly accessible by DOM
         * methods like document.getElementById().
         *
         * @method getElementById
         * @param {String} id Unique identifier for element.
         * @return {Object} Reference to a JavaScript object. In case of SVG/VMLRenderer it&#x27;s a reference to a SVG/VML
         * node.
         */
        getElementById: function (id) {
            return this.container.ownerDocument.getElementById(this.container.id + &#x27;_&#x27; + id);
        },

        /**
         * Remove an element and provide a function that inserts it into its original position. This method
         * is taken from this article {@link https://developers.google.com/speed/articles/javascript-dom}.
         *
         * @method removeToInsertLater
         * @author KeeKim Heng, Google Web Developer
         * @param {Element} element The element to be temporarily removed
         * @return {Function} A function that inserts the element into its original position
         */
        removeToInsertLater: function (element) {
            var parentNode = element.parentNode,
                nextSibling = element.nextSibling;

            parentNode.removeChild(element);

            return function () {
                if (nextSibling) {
                    parentNode.insertBefore(element, nextSibling);
                } else {
                    parentNode.appendChild(element);
                }
            };
        },

        /**
         * Resizes the rendering element
         *
         * @method resize
         * @param {Number} w New width
         * @param {Number} h New height
         */
        resize: function (w, h) { /* stub */},

        /**
         * Create crosshair elements (Fadenkreuz) for presentations.
         *
         * @method createTouchpoints
         * @param {Number} n Number of crosshairs.
         */
        createTouchpoints: function (n) {},

        /**
         * Show a specific crosshair.
         *
         * @method showTouchpoint
         * @param {Number} i Number of the crosshair to show
         */
        showTouchpoint: function (i) {},

        /**
         * Hide a specific crosshair.
         *
         * @method hideTouchpoint
         * @param {Number} i Number of the crosshair to show
         */
        hideTouchpoint: function (i) {},

        /**
         * Move a specific crosshair.
         *
         * @method updateTouchpoint
         * @param {Number} i Number of the crosshair to show
         * @param {Array} pos New positon in screen coordinates
         */
        updateTouchpoint: function (i, pos) {},

        /**
         * Convert SVG construction to canvas.
         * Only available on SVGRenderer.
         *
         * @method dumpToCanvas
         * @see JXG.SVGRenderer#dumpToCanvas
         */
        dumpToCanvas: function(canvasId) {}
    });

    return JXG.AbstractRenderer;
});

    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>

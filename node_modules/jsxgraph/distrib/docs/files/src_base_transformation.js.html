<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src/base/transformation.js - JSXGraph</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="../assets/js/jsxgraphcore.js"></script>
    <link rel="stylesheet" href="../assets/css/jsxgraph.css">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../assets/css/logo_blue.png" title="JSXGraph" width="117" height="52"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.99.4</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/Angle.html">Angle</a> </li>
                                <li><a href="../classes/Arc.html">Arc</a> </li>
                                <li><a href="../classes/Arrow.html">Arrow</a> </li>
                                <li><a href="../classes/Arrowparallel.html">Arrowparallel</a> </li>
                                <li><a href="../classes/Axis.html">Axis</a> </li>
                                <li><a href="../classes/Bisector.html">Bisector</a> </li>
                                <li><a href="../classes/Bisectorlines.html">Bisectorlines</a> </li>
                                <li><a href="../classes/Button.html">Button</a> </li>
                                <li><a href="../classes/Checkbox.html">Checkbox</a> </li>
                                <li><a href="../classes/Circle.html">Circle</a> </li>
                                <li><a href="../classes/Circumcenter.html">Circumcenter</a> </li>
                                <li><a href="../classes/Circumcircle.html">Circumcircle</a> </li>
                                <li><a href="../classes/CircumcircleArc.html">CircumcircleArc</a> </li>
                                <li><a href="../classes/CircumcircleSector.html">CircumcircleSector</a> </li>
                                <li><a href="../classes/Conic.html">Conic</a> </li>
                                <li><a href="../classes/Curve.html">Curve</a> </li>
                                <li><a href="../classes/Ellipse.html">Ellipse</a> </li>
                                <li><a href="../classes/EventEmitter.html">EventEmitter</a> </li>
                                <li><a href="../classes/Functiongraph.html">Functiongraph</a> </li>
                                <li><a href="../classes/Glider.html">Glider</a> </li>
                                <li><a href="../classes/Grid.html">Grid</a> </li>
                                <li><a href="../classes/Group.html">Group</a> </li>
                                <li><a href="../classes/Hatch.html">Hatch</a> </li>
                                <li><a href="../classes/Hyperbola.html">Hyperbola</a> </li>
                                <li><a href="../classes/Image.html">Image</a> </li>
                                <li><a href="../classes/Incenter.html">Incenter</a> </li>
                                <li><a href="../classes/Incircle.html">Incircle</a> </li>
                                <li><a href="../classes/Inequality.html">Inequality</a> </li>
                                <li><a href="../classes/Input.html">Input</a> </li>
                                <li><a href="../classes/Integral.html">Integral</a> </li>
                                <li><a href="../classes/Intersection.html">Intersection</a> </li>
                                <li><a href="../classes/JXG.html">JXG</a> </li>
                                <li><a href="../classes/JXG.AbstractRenderer.html">JXG.AbstractRenderer</a> </li>
                                <li><a href="../classes/JXG.Board.html">JXG.Board</a> </li>
                                <li><a href="../classes/JXG.C.html">JXG.C</a> </li>
                                <li><a href="../classes/JXG.CanvasRenderer.html">JXG.CanvasRenderer</a> </li>
                                <li><a href="../classes/JXG.Chart.html">JXG.Chart</a> </li>
                                <li><a href="../classes/JXG.Circle.html">JXG.Circle</a> </li>
                                <li><a href="../classes/JXG.Complex.html">JXG.Complex</a> </li>
                                <li><a href="../classes/JXG.Composition.html">JXG.Composition</a> </li>
                                <li><a href="../classes/JXG.Coords.html">JXG.Coords</a> </li>
                                <li><a href="../classes/JXG.CoordsElement.html">JXG.CoordsElement</a> </li>
                                <li><a href="../classes/JXG.Curve.html">JXG.Curve</a> </li>
                                <li><a href="../classes/JXG.GeometryElement.html">JXG.GeometryElement</a> </li>
                                <li><a href="../classes/JXG.Group.html">JXG.Group</a> </li>
                                <li><a href="../classes/JXG.Image.html">JXG.Image</a> </li>
                                <li><a href="../classes/JXG.JSXGraph.html">JXG.JSXGraph</a> </li>
                                <li><a href="../classes/JXG.Line.html">JXG.Line</a> </li>
                                <li><a href="../classes/JXG.Math.html">JXG.Math</a> </li>
                                <li><a href="../classes/JXG.Math.Geometry.html">JXG.Math.Geometry</a> </li>
                                <li><a href="../classes/JXG.Math.Numerics.html">JXG.Math.Numerics</a> </li>
                                <li><a href="../classes/JXG.Math.Poly.html">JXG.Math.Poly</a> </li>
                                <li><a href="../classes/JXG.Math.Poly.Monomial.html">JXG.Math.Poly.Monomial</a> </li>
                                <li><a href="../classes/JXG.Math.Poly.Polynomial.html">JXG.Math.Poly.Polynomial</a> </li>
                                <li><a href="../classes/JXG.Math.Poly.Ring.html">JXG.Math.Poly.Ring</a> </li>
                                <li><a href="../classes/JXG.Math.Quadtree.html">JXG.Math.Quadtree</a> </li>
                                <li><a href="../classes/JXG.Math.Statistics.html">JXG.Math.Statistics</a> </li>
                                <li><a href="../classes/JXG.Math.Symbolic.html">JXG.Math.Symbolic</a> </li>
                                <li><a href="../classes/JXG.NoRenderer.html">JXG.NoRenderer</a> </li>
                                <li><a href="../classes/JXG.Options.html">JXG.Options</a> </li>
                                <li><a href="../classes/JXG.Point.html">JXG.Point</a> </li>
                                <li><a href="../classes/JXG.Polygon.html">JXG.Polygon</a> </li>
                                <li><a href="../classes/JXG.SVGRenderer.html">JXG.SVGRenderer</a> </li>
                                <li><a href="../classes/JXG.Text.html">JXG.Text</a> </li>
                                <li><a href="../classes/JXG.Ticks.html">JXG.Ticks</a> </li>
                                <li><a href="../classes/JXG.Transformation.html">JXG.Transformation</a> </li>
                                <li><a href="../classes/JXG.Turtle.html">JXG.Turtle</a> </li>
                                <li><a href="../classes/JXG.Util.Base64.html">JXG.Util.Base64</a> </li>
                                <li><a href="../classes/JXG.Util.Unzip.html">JXG.Util.Unzip</a> </li>
                                <li><a href="../classes/JXG.VMLRenderer.html">JXG.VMLRenderer</a> </li>
                                <li><a href="../classes/Line.html">Line</a> </li>
                                <li><a href="../classes/Locus.html">Locus</a> </li>
                                <li><a href="../classes/MajorArc.html">MajorArc</a> </li>
                                <li><a href="../classes/Midpoint.html">Midpoint</a> </li>
                                <li><a href="../classes/MinorArc.html">MinorArc</a> </li>
                                <li><a href="../classes/MinorSector.html">MinorSector</a> </li>
                                <li><a href="../classes/Mirrorpoint.html">Mirrorpoint</a> </li>
                                <li><a href="../classes/NonReflexAngle.html">NonReflexAngle</a> </li>
                                <li><a href="../classes/Normal.html">Normal</a> </li>
                                <li><a href="../classes/Orthogonalprojection.html">Orthogonalprojection</a> </li>
                                <li><a href="../classes/OtherIntersection.html">OtherIntersection</a> </li>
                                <li><a href="../classes/Parabola.html">Parabola</a> </li>
                                <li><a href="../classes/Parallel.html">Parallel</a> </li>
                                <li><a href="../classes/Parallelpoint.html">Parallelpoint</a> </li>
                                <li><a href="../classes/Perpendicular.html">Perpendicular</a> </li>
                                <li><a href="../classes/PerpendicularPoint.html">PerpendicularPoint</a> </li>
                                <li><a href="../classes/PerpendicularSegment.html">PerpendicularSegment</a> </li>
                                <li><a href="../classes/Point.html">Point</a> </li>
                                <li><a href="../classes/PolarLine.html">PolarLine</a> </li>
                                <li><a href="../classes/PolePoint.html">PolePoint</a> </li>
                                <li><a href="../classes/Polygon.html">Polygon</a> </li>
                                <li><a href="../classes/RadicalAxis.html">RadicalAxis</a> </li>
                                <li><a href="../classes/Reflection.html">Reflection</a> </li>
                                <li><a href="../classes/ReflexAngle.html">ReflexAngle</a> </li>
                                <li><a href="../classes/registerReader.html">registerReader</a> </li>
                                <li><a href="../classes/RegularPolygon.html">RegularPolygon</a> </li>
                                <li><a href="../classes/Riemannsum.html">Riemannsum</a> </li>
                                <li><a href="../classes/Sector.html">Sector</a> </li>
                                <li><a href="../classes/Segment.html">Segment</a> </li>
                                <li><a href="../classes/Semicircle.html">Semicircle</a> </li>
                                <li><a href="../classes/Slider.html">Slider</a> </li>
                                <li><a href="../classes/Slopetriangle.html">Slopetriangle</a> </li>
                                <li><a href="../classes/Spline.html">Spline</a> </li>
                                <li><a href="../classes/Stepfunction.html">Stepfunction</a> </li>
                                <li><a href="../classes/Tangent.html">Tangent</a> </li>
                                <li><a href="../classes/Tapemeasure.html">Tapemeasure</a> </li>
                                <li><a href="../classes/Text.html">Text</a> </li>
                                <li><a href="../classes/Ticks.html">Ticks</a> </li>
                                <li><a href="../classes/Tracecurve.html">Tracecurve</a> </li>
                                <li><a href="../classes/Transformation.html">Transformation</a> </li>
                                <li><a href="../classes/Turtle.html">Turtle</a> </li>
                            </ul>
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="../modules/JXG.html">JXG</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: src/base/transformation.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/*
    Copyright 2008-2015
        Matthias Ehmann,
        Michael Gerhaeuser,
        Carsten Miller,
        Bianca Valentin,
        Alfred Wassermann,
        Peter Wilfahrt

    This file is part of JSXGraph.

    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.

    You can redistribute it and/or modify it under the terms of the

      * GNU Lesser General Public License as published by
        the Free Software Foundation, either version 3 of the License, or
        (at your option) any later version
      OR
      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT

    JSXGraph is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License and
    the MIT License along with JSXGraph. If not, see &lt;http://www.gnu.org/licenses/&gt;
    and &lt;http://opensource.org/licenses/MIT/&gt;.
 */


/*global JXG: true, define: true*/
/*jslint nomen: true, plusplus: true*/

/*depends:
 jxg
 base/constants
 math/math
 utils/type
 */

/**
 * @fileoverview This file contains code for transformations of geometrical objects.
 */

define([
    &#x27;jxg&#x27;, &#x27;base/constants&#x27;, &#x27;math/math&#x27;, &#x27;utils/type&#x27;
], function (JXG, Const, Mat, Type) {

    &quot;use strict&quot;;

    /**
     * A transformation consists of a 3x3 matrix, i.e. it is a projective transformation.
     * Creates a new transformation object. Do not use this constructor to create a transformation. Use {@link JXG.Board#create} with
     * type {@link Transformation} instead.
     * 
     * @class JXG.Transformation
     * @constructor
     * @param {JXG.Board} board The board the new circle is drawn on.
     * @param {String} type Can be
     * 
     * * &#x27;translate&#x27;
     * * &#x27;scale&#x27;
     * * &#x27;reflect&#x27;
     * * &#x27;rotate&#x27;
     * * &#x27;shear&#x27;
     * + &#x27;generic&#x27;
     * @param {Object} params The parameters depend on the transformation type
     *
     * &lt;p&gt;
     * Translation matrix:
     * &lt;pre&gt;
     * ( 1  0  0)   ( z )
     * ( a  1  0) * ( x )
     * ( b  0  1)   ( y )
     * &lt;/pre&gt;
     *
     * &lt;p&gt;
     * Scale matrix:
     * &lt;pre&gt;
     * ( 1  0  0)   ( z )
     * ( 0  a  0) * ( x )
     * ( 0  0  b)   ( y )
     * &lt;/pre&gt;
     *
     * &lt;p&gt;
     * A rotation matrix with angle a (in Radians)
     * &lt;pre&gt;
     * ( 1    0        0      )   ( z )
     * ( 0    cos(a)   -sin(a)) * ( x )
     * ( 0    sin(a)   cos(a) )   ( y )
     * &lt;/pre&gt;
     *
     * &lt;p&gt;
     * Shear matrix:
     * &lt;pre&gt;
     * ( 1  0  0)   ( z )
     * ( 0  1  a) * ( x )
     * ( 0  b  1)   ( y )
     * &lt;/pre&gt;
     *
     * &lt;p&gt;Generic transformation:
     * &lt;pre&gt;
     * ( a  b  c )   ( z )
     * ( d  e  f ) * ( x )
     * ( g  h  i )   ( y )
     * &lt;/pre&gt;
     *
     */
    JXG.Transformation = function (board, type, params) {
        this.elementClass = Const.OBJECT_CLASS_OTHER;
        this.matrix = [
            [1, 0, 0],
            [0, 1, 0],
            [0, 0, 1]
        ];
        this.board = board;
        this.isNumericMatrix = false;
        this.setMatrix(board, type, params);

        this.methodMap = {
            apply: &#x27;apply&#x27;,
            applyOnce: &#x27;applyOnce&#x27;,
            bindTo: &#x27;bindTo&#x27;,
            bind: &#x27;bind&#x27;,
            melt: &#x27;melt&#x27;
        };
    };

    JXG.Transformation.prototype = {};

    JXG.extend(JXG.Transformation.prototype, /** @lends JXG.Transformation.prototype */ {
        /**
         * @method update
         * @private
         * @return {JXG.Transform} returns pointer to itself
         * @chainable
         */
        update: function () {
            return this;
        },

        /**
         * Set the transformation matrix for different types of standard transforms.
         * 
         * @method setMatrix
         * @param {JXG.Board} board
         * @param {String} type   Transformation type, possible values are
         *                        &#x27;translate&#x27;, &#x27;scale&#x27;, &#x27;reflect&#x27;, &#x27;rotate&#x27;,
         *                        &#x27;shear&#x27;, &#x27;generic&#x27;.
         * @param {Array} params Parameters for the various transformation types.
         *
         * &lt;p&gt;These are
         * @param {Array} x,y Shift vector (number or function) in case of &#x27;translate&#x27;.
         * @param {Array} scale_x,scale_y Scale vector (number or function) in case of &#x27;scale&#x27;.
         * @param {Array} line|point_pair|&quot;four coordinates&quot; In case of &#x27;reflect&#x27; the parameters could
         *                be a line, a pair of points or four number (or functions) p_x, p_y, q_x, q_y,
         *                determining a line through points (p_x, p_y) and (q_x, q_y).
         * @param {Array} angle,x,y In case of &#x27;rotate&#x27; the parameters are an angle or angle function,
         *                returning the angle in Radians and - optionally - a coordinate pair or a point defining the
         *                returning the angle in Radians and - optionally - a coordinate pair defining the
         *                reotation center. If the rotation center is not given, the transformation rotates around (0,0).
         * @param {Array} shear_x,shear_y Shear vector (number or function) in case of &#x27;shear&#x27;.
         * @param {Array} a,b,c,d,e,f,g,h,i Nine matrix entries (numbers or functions) for a generic
         *                projective transformation  in case of &#x27;generic&#x27;.
         *
         * &lt;p&gt;A transformation with a generic matrix looks like:
         * &lt;pre&gt;
         * ( a  b  c )   ( z )
         * ( d  e  f ) * ( x )
         * ( g  h  i )   ( y )
         * &lt;/pre&gt;
         *
         * @return {JXG.Transform} returns pointer to itself
         * @chainable
         */
        setMatrix: function (board, type, params) {
            var i;

            this.isNumericMatrix = true;

            for (i = 0; i &lt; params.length; i++) {
                if (typeof params[i] !== &#x27;number&#x27;) {
                    this.isNumericMatrix = false;
                    break;
                }
            }

            if (type === &#x27;translate&#x27;) {
                if (params.length !== 2) {
                    throw new Error(&quot;JSXGraph: translate transformation needs 2 parameters.&quot;);
                }
                this.evalParam = Type.createEvalFunction(board, params, 2);
                this.update = function () {
                    this.matrix[1][0] = this.evalParam(0);
                    this.matrix[2][0] = this.evalParam(1);
                };
            } else if (type === &#x27;scale&#x27;) {
                if (params.length !== 2) {
                    throw new Error(&quot;JSXGraph: scale transformation needs 2 parameters.&quot;);
                }
                this.evalParam = Type.createEvalFunction(board, params, 2);
                this.update = function () {
                    this.matrix[1][1] = this.evalParam(0); // x
                    this.matrix[2][2] = this.evalParam(1); // y
                };
            // Input: line or two points
            } else if (type === &#x27;reflect&#x27;) {
                // line or two points
                if (params.length &lt; 4) {
                    params[0] = board.select(params[0]);
                }

                // two points
                if (params.length === 2) {
                    params[1] = board.select(params[1]);
                }

                // 4 coordinates [px,py,qx,qy]
                if (params.length === 4) {
                    this.evalParam = Type.createEvalFunction(board, params, 4);
                }

                this.update = function () {
                    var x, y, z, xoff, yoff, d,
                        v, p;
                    // Determine homogeneous coordinates of reflections axis
                    // line
                    if (params.length === 1) {
                        v = params[0].stdform;
                    // two points
                    } else if (params.length === 2) {
                        v = Mat.crossProduct(params[1].coords.usrCoords, params[0].coords.usrCoords);
                    // two points coordinates [px,py,qx,qy]
                    } else if (params.length === 4) {
                        v = Mat.crossProduct(
                            [1, this.evalParam(2), this.evalParam(3)],
                            [1, this.evalParam(0), this.evalParam(1)]
                        );
                    }

                    // Project origin to the line.  This gives a finite point p
                    x = v[1];
                    y = v[2];
                    z = v[0];
                    p = [-z * x, -z * y, x * x + y * y];
                    d = p[2];

                    // Normalize p
                    xoff = p[0] / p[2];
                    yoff = p[1] / p[2];

                    // x, y is the direction of the line
                    x = -v[2];
                    y =  v[1];

                    this.matrix[1][1] = (x * x - y * y) / d;
                    this.matrix[1][2] = 2 * x * y / d;
                    this.matrix[2][1] = this.matrix[1][2];
                    this.matrix[2][2] = -this.matrix[1][1];
                    this.matrix[1][0] = xoff * (1 - this.matrix[1][1]) - yoff * this.matrix[1][2];
                    this.matrix[2][0] = yoff * (1 - this.matrix[2][2]) - xoff * this.matrix[2][1];
                };
            } else if (type === &#x27;rotate&#x27;) {
                // angle, x, y
                if (params.length === 3) {
                    this.evalParam = Type.createEvalFunction(board, params, 3);
                // angle, p or angle
                } else if (params.length &gt; 0 &amp;&amp; params.length &lt;= 2) {
                    this.evalParam = Type.createEvalFunction(board, params, 1);

                    if (params.length === 2) {
                        params[1] = board.select(params[1]);
                    }
                }

                this.update = function () {
                    var x, y,
                        beta = this.evalParam(0),
                        co = Math.cos(beta),
                        si = Math.sin(beta);

                    this.matrix[1][1] =  co;
                    this.matrix[1][2] = -si;
                    this.matrix[2][1] =  si;
                    this.matrix[2][2] =  co;

                    // rotate around [x,y] otherwise rotate around [0,0]
                    if (params.length &gt; 1) {
                        if (params.length === 3) {
                            x = this.evalParam(1);
                            y = this.evalParam(2);
                        } else {
                            x = params[1].X();
                            y = params[1].Y();
                        }
                        this.matrix[1][0] = x * (1 - co) + y * si;
                        this.matrix[2][0] = y * (1 - co) - x * si;
                    }
                };
            } else if (type === &#x27;shear&#x27;) {
                if (params.length !== 2) {
                    throw new Error(&quot;JSXGraph: shear transformation needs 2 parameters.&quot;);
                }

                this.evalParam = Type.createEvalFunction(board, params, 2);
                this.update = function () {
                    this.matrix[1][2] = this.evalParam(0);
                    this.matrix[2][1] = this.evalParam(1);
                };
            } else if (type === &#x27;generic&#x27;) {
                if (params.length !== 9) {
                    throw new Error(&quot;JSXGraph: generic transformation needs 9 parameters.&quot;);
                }

                this.evalParam = Type.createEvalFunction(board, params, 9);

                this.update = function () {
                    this.matrix[0][0] = this.evalParam(0);
                    this.matrix[0][1] = this.evalParam(1);
                    this.matrix[0][2] = this.evalParam(2);
                    this.matrix[1][0] = this.evalParam(3);
                    this.matrix[1][1] = this.evalParam(4);
                    this.matrix[1][2] = this.evalParam(5);
                    this.matrix[2][0] = this.evalParam(6);
                    this.matrix[2][1] = this.evalParam(7);
                    this.matrix[2][2] = this.evalParam(8);
                };
            }
            
            return this;
        },

        /**
         * Transform a GeometryElement:
         * First, the transformation matrix is updated, the do the matrix-vector-multiplication.
         * 
         * @method apply
         * @param {JXG.GeometryElement} p element which is transformed
         * @param {String} &#x27;self&#x27; Apply the transformation to the initialCoords instead of the coords if this is set.
         * @return {Array}
         */
        apply: function (p, self) {
            this.update();

            if (Type.exists(self)) {
                return Mat.matVecMult(this.matrix, p.initialCoords.usrCoords);
            }
            return Mat.matVecMult(this.matrix, p.coords.usrCoords);
        },

        /**
         * Applies a transformation once to a GeometryElement.
         * If it is a free point, then it can be dragged around later
         * and will overwrite the transformed coordinates.
         * 
         * @method applyOnce
         * @param {JXG.Point,Array} p
         * @return {JXG.Transform} returns pointer to itself
         * @chainable
         */
        applyOnce: function (p) {
            var c, len, i;

            if (!Type.isArray(p)) {
                p = [p];
            }

            len = p.length;

            for (i = 0; i &lt; len; i++) {
                this.update();
                c = Mat.matVecMult(this.matrix, p[i].coords.usrCoords);
                p[i].coords.setCoordinates(Const.COORDS_BY_USER, c);
            }
            
            return this;
        },

        /**
         * Binds a transformation to a GeometryElement. In every update of the
         * GeometryElement, the transformation is executed.
         * 
         * @method bindTo
         * @param  {Array,JXG.Object} p JXG.Object or array of JXG.Object to
         *                            which the transformation is bound to.
         * @return {JXG.Transform} returns pointer to itself
         * @chainable
         */
        bindTo: function (p) {
            var i, len;
            if (Type.isArray(p)) {
                len = p.length;

                for (i = 0; i &lt; len; i++) {
                    p[i].transformations.push(this);
                }
            } else {
                p.transformations.push(this);
            }
            
            return this;
        },

        /**
         * Unused. USe setAttribute.
         * 
         * @method setProperty
         * @deprecated
         * @param {Object} term
         */
        setProperty: function (term) {
            JXG.deprecated(&#x27;Transformation.setProperty()&#x27;, &#x27;Transformation.setAttribute()&#x27;);
        },

        /**
         * Empty method. Unused.
         * 
         * @method setAttribute
         * @param {Object} term Key-value pairs of the attributes.
         * @return {JXG.Transform} returns pointer to itself
         * @chainable
         */
        setAttribute: function (term) { 
            return this;
        },

        /**
         * Combine two transformations to one transformations. This only works if
         * the both transformation  matrices consist of numbers, solely (and do not
         * contain functions).
         *
         * Multiplies the transformation with a transformation t from the left.
         * i.e. (this) = (t) join (this)
         * 
         * @method melt
         * @param  {JXG.Transform} t Transformation which is the left multiplicand
         * @return {JXG.Transform} returns pointer to itself
         * @chainable
         */
        melt: function (t) {
            var res = [], i, len, len0, k, s, j;

            len = t.matrix.length;
            len0 = this.matrix[0].length;

            for (i = 0; i &lt; len; i++) {
                res[i] = [];
            }

            this.update();
            t.update();

            for (i = 0; i &lt; len; i++) {
                for (j = 0; j &lt; len0; j++) {
                    s = 0;
                    for (k = 0; k &lt; len; k++) {
                        s += t.matrix[i][k] * this.matrix[k][j];
                    }
                    res[i][j] = s;
                }
            }

            this.update = function () {
                var len = this.matrix.length,
                    len0 = this.matrix[0].length;

                for (i = 0; i &lt; len; i++) {
                    for (j = 0; j &lt; len0; j++) {
                        this.matrix[i][j] = res[i][j];
                    }
                }
            };
            return this;
        }
    });

    /**
     * This element is used to provide projective transformations.
     * A transformation consists of a 3x3 matrix, i.e. it is a projective transformation.
     * 
     * @pseudo
     * @class Transformation
     * @extends JXG.Transformation
     * @constructor
     * @type JXG.Transformation
     * @throws {Exception} If the element cannot be constructed with the given parent objects an exception is thrown.
     * @param {number,function} The parameters depend on the transformation type, supplied as attribute &#x27;type&#x27;.
     * Possible transformation types are
     * &lt;ul&gt;&lt;li&gt; &#x27;translate&#x27;
     * &lt;li&gt; &#x27;scale&#x27;
     * &lt;li&gt; &#x27;reflect&#x27;
     * &lt;li&gt; &#x27;rotate&#x27;
     * &lt;li&gt; &#x27;shear&#x27;
     * &lt;li&gt; &#x27;generic&#x27;
     * &lt;/ul&gt;
     * The transformation matrix then looks like:
     * &lt;p&gt;
     * Translation matrix:
     * &lt;pre&gt;
     * ( 1  0  0)   ( z )
     * ( a  1  0) * ( x )
     * ( b  0  1)   ( y )
     * &lt;/pre&gt;
     *
     * &lt;p&gt;
     * Scale matrix:
     * &lt;pre&gt;
     * ( 1  0  0)   ( z )
     * ( 0  a  0) * ( x )
     * ( 0  0  b)   ( y )
     * &lt;/pre&gt;
     *
     * &lt;p&gt;
     * A rotation matrix with angle a (in Radians)
     * &lt;pre&gt;
     * ( 1    0        0      )   ( z )
     * ( 0    cos(a)   -sin(a)) * ( x )
     * ( 0    sin(a)   cos(a) )   ( y )
     * &lt;/pre&gt;
     *
     * &lt;p&gt;
     * Shear matrix:
     * &lt;pre&gt;
     * ( 1  0  0)   ( z )
     * ( 0  1  a) * ( x )
     * ( 0  b  1)   ( y )
     * &lt;/pre&gt;
     *
     * &lt;p&gt;Generic transformation:
     * &lt;pre&gt;
     * ( a  b  c )   ( z )
     * ( d  e  f ) * ( x )
     * ( g  h  i )   ( y )
     * &lt;/pre&gt;
     *
     * @example
     * 
     *      // The point B is determined by taking twice the vector A from the origin
     *
     *      var p0 = board.create(&#x27;point&#x27;, [0, 3], {name: &#x27;A&#x27;}),
     *          t = board.create(&#x27;transform&#x27;, [function(){ return p0.X(); }, &quot;Y(A)&quot;], {type: &#x27;translate&#x27;}),
     *          p1 = board.create(&#x27;point&#x27;, [p0, t], {color: &#x27;blue&#x27;});
     *
     * &lt;div id=&quot;14167b0c-2ad3-11e5-8dd9-901b0e1b8723&quot; style=&quot;width: 300px; height: 300px;&quot;&gt;&lt;/div&gt;
     * &lt;script type=&quot;text/javascript&quot;&gt;
     * (function() {
     *    var board = JXG.JSXGraph.initBoard(&#x27;14167b0c-2ad3-11e5-8dd9-901b0e1b8723&#x27;,
     *         {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});
     *    var p0 = board.create(&#x27;point&#x27;, [0, 3], {name: &#x27;A&#x27;}),
     *        t = board.create(&#x27;transform&#x27;, [function(){ return p0.X(); }, &quot;Y(A)&quot;], {type:&#x27;translate&#x27;}),
     *        p1 = board.create(&#x27;point&#x27;, [p0, t], {color: &#x27;blue&#x27;});
     *     })();
     * &lt;/script&gt;
     *
     * @example
     * 
     *      // The point B is the result of scaling the point A with factor 2 in horizontal direction
     *      // and with factor 0.5 in vertical direction.
     *
     *      var p1 = board.create(&#x27;point&#x27;, [1, 1]),
     *          t = board.create(&#x27;transform&#x27;, [2, 0.5], {type: &#x27;scale&#x27;}),
     *          p2 = board.create(&#x27;point&#x27;, [p1, t], {color: &#x27;blue&#x27;});
     *
     * &lt;div id=&quot;a6827a72-2ad3-11e5-8dd9-901b0e1b8723&quot; style=&quot;width: 300px; height: 300px;&quot;&gt;&lt;/div&gt;
     * &lt;script type=&quot;text/javascript&quot;&gt;
     * (function() {
     *     var board = JXG.JSXGraph.initBoard(&#x27;a6827a72-2ad3-11e5-8dd9-901b0e1b8723&#x27;,
     *         {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});
     * var p1 = board.create(&#x27;point&#x27;, [1, 1]),
     *     t = board.create(&#x27;transform&#x27;, [2, 0.5], {type: &#x27;scale&#x27;}),
     *     p2 = board.create(&#x27;point&#x27;, [p1, t], {color: &#x27;blue&#x27;});
     * })();
     * &lt;/script&gt;
     *
     * @example
     *  
     *      // The point B is rotated around C which gives point D. The angle is determined
     *      // by the vertical height of point A.
     *
     *      var p0 = board.create(&#x27;point&#x27;, [0, 3], {name: &#x27;A&#x27;}),
     *          p1 = board.create(&#x27;point&#x27;, [1, 1]),
     *          p2 = board.create(&#x27;point&#x27;, [2, 1], {name:&#x27;C&#x27;, fixed: true}),
     *
     *          // angle, rotation center:
     *          t = board.create(&#x27;transform&#x27;, [&#x27;Y(A)&#x27;, p2], {type: &#x27;rotate&#x27;}),
     *          p3 = board.create(&#x27;point&#x27;, [p1, t], {color: &#x27;blue&#x27;});
     *
     * &lt;div id=&quot;747cf11e-2ad4-11e5-8dd9-901b0e1b8723&quot; style=&quot;width: 300px; height: 300px;&quot;&gt;&lt;/div&gt;
     * &lt;script type=&quot;text/javascript&quot;&gt;
     * (function() {
     *  var board = JXG.JSXGraph.initBoard(&#x27;747cf11e-2ad4-11e5-8dd9-901b0e1b8723&#x27;,
     *         {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});
     *  var p0 = board.create(&#x27;point&#x27;, [0, 3], {name: &#x27;A&#x27;}),
     *   p1 = board.create(&#x27;point&#x27;, [1, 1]),
     *   p2 = board.create(&#x27;point&#x27;, [2, 1], {name:&#x27;C&#x27;, fixed: true}),
     *   // angle, rotation center:
     *   t = board.create(&#x27;transform&#x27;, [&#x27;Y(A)&#x27;, p2], {type: &#x27;rotate&#x27;}),
     *   p3 = board.create(&#x27;point&#x27;, [p1, t], {color: &#x27;blue&#x27;});
     * })();
     * &lt;/script&gt;
     *
     * @example
     * 
     *      // A concatenation of several transformations.
     *      var p1 = board.create(&#x27;point&#x27;, [1, 1]),
     *          t1 = board.create(&#x27;transform&#x27;, [-2, -1], {type: &#x27;translate&#x27;}),
     *          t2 = board.create(&#x27;transform&#x27;, [Math.PI/4], {type: &#x27;rotate&#x27;}),
     *          t3 = board.create(&#x27;transform&#x27;, [2, 1], {type: &#x27;translate&#x27;}),
     *          p2 = board.create(&#x27;point&#x27;, [p1, [t1, t2, t3]], {color: &#x27;blue&#x27;});
     *
     * &lt;div id=&quot;f516d3de-2ad5-11e5-8dd9-901b0e1b8723&quot; style=&quot;width: 300px; height: 300px;&quot;&gt;&lt;/div&gt;
     * &lt;script type=&quot;text/javascript&quot;&gt;
     * (function() {
     * var board = JXG.JSXGraph.initBoard(&#x27;f516d3de-2ad5-11e5-8dd9-901b0e1b8723&#x27;,
     *   {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});
     * var p1 = board.create(&#x27;point&#x27;, [1, 1]),
     *    t1 = board.create(&#x27;transform&#x27;, [-2, -1], {type:&#x27;translate&#x27;}),
     *    t2 = board.create(&#x27;transform&#x27;, [Math.PI/4], {type:&#x27;rotate&#x27;}),
     *    t3 = board.create(&#x27;transform&#x27;, [2, 1], {type:&#x27;translate&#x27;}),
     *    p2 = board.create(&#x27;point&#x27;, [p1, [t1, t2, t3]], {color: &#x27;blue&#x27;});
     * })();
     * &lt;/script&gt;
     *
     * @example
     * 
     *      // Reflection of point A
     *      var p1 = board.create(&#x27;point&#x27;, [1, 1]),
     *          p2 = board.create(&#x27;point&#x27;, [1, 3]),
     *          p3 = board.create(&#x27;point&#x27;, [-2, 0]),
     *          l = board.create(&#x27;line&#x27;, [p2, p3]),
     *          t = board.create(&#x27;transform&#x27;, [l], {type: &#x27;reflect&#x27;}),  // Possible are l, l.id, l.name
     *          p4 = board.create(&#x27;point&#x27;, [p1, t], {color: &#x27;blue&#x27;});
     *
     * &lt;div id=&quot;6f374a04-2ad6-11e5-8dd9-901b0e1b8723&quot; style=&quot;width: 300px; height: 300px;&quot;&gt;&lt;/div&gt;
     * &lt;script type=&quot;text/javascript&quot;&gt;
     * (function() {
     *    var board = JXG.JSXGraph.initBoard(&#x27;6f374a04-2ad6-11e5-8dd9-901b0e1b8723&#x27;,
     *        {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});
     *  var p1 = board.create(&#x27;point&#x27;, [1, 1]),
     *      p2 = board.create(&#x27;point&#x27;, [1, 3]),
     *      p3 = board.create(&#x27;point&#x27;, [-2, 0]),
     *      l = board.create(&#x27;line&#x27;, [p2, p3]),
     *      t = board.create(&#x27;transform&#x27;, [l], {type:&#x27;reflect&#x27;}),  // Possible are l, l.id, l.name
     *      p4 = board.create(&#x27;point&#x27;, [p1, t], {color: &#x27;blue&#x27;});
     *  })();
     * &lt;/script&gt;
     *
     * @example
     * 
     *      // One time application of a transform to points A, B
     *      var p1 = board.create(&#x27;point&#x27;, [1, 1]),
     *          p2 = board.create(&#x27;point&#x27;, [1, 1]),
     *          t = board.create(&#x27;transform&#x27;, [3, 2], {type: &#x27;shear&#x27;});
     *      t.applyOnce([p1, p2]);
     *
     * &lt;div id=&quot;b6cee1c4-2ad6-11e5-8dd9-901b0e1b8723&quot; style=&quot;width: 300px; height: 300px;&quot;&gt;&lt;/div&gt;
     * &lt;script type=&quot;text/javascript&quot;&gt;
     * (function() {
     *  var board = JXG.JSXGraph.initBoard(&#x27;b6cee1c4-2ad6-11e5-8dd9-901b0e1b8723&#x27;,
     *      {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});
     *  var p1 = board.create(&#x27;point&#x27;, [1, 1]),
     *  p2 = board.create(&#x27;point&#x27;, [-1, -2]),
     *  t = board.create(&#x27;transform&#x27;, [3, 2], {type: &#x27;shear&#x27;});
     *  t.applyOnce([p1, p2]);
     * })();
     * &lt;/script&gt;
     *
     * @example
     * 
     *      // Construct a square of side length 2 with the
     *      // help of transformations
     *      var sq = [],
     *          right = board.create(&#x27;transform&#x27;, [2, 0], {type: &#x27;translate&#x27;}),
     *          up = board.create(&#x27;transform&#x27;, [0, 2], {type: &#x27;translate&#x27;}),
     *          pol, rot, p0;
     *
     *      // The first point is free
     *      sq[0] = board.create(&#x27;point&#x27;, [0, 0], {name: &#x27;Drag me&#x27;}),
     *
     *      // Construct the other free points by transformations
     *      sq[1] = board.create(&#x27;point&#x27;, [sq[0], right]),
     *      sq[2] = board.create(&#x27;point&#x27;, [sq[0], [right, up]]),
     *      sq[3] = board.create(&#x27;point&#x27;, [sq[0], up]),
     *
     *      // Polygon through these four points
     *      pol = board.create(&#x27;polygon&#x27;, sq, {
     *             fillColor:&#x27;blue&#x27;,
     *             gradient:&#x27;radial&#x27;,
     *             gradientsecondcolor:&#x27;white&#x27;,
     *             gradientSecondOpacity:&#x27;0&#x27;
     *      }),
     *
     *      p0 = board.create(&#x27;point&#x27;, [0, 3], {name: &#x27;angle&#x27;}),
     *      // Rotate the square around point sq[0] by dragging A
     *      rot = board.create(&#x27;transform&#x27;, [&#x27;Y(angle)&#x27;, sq[0]], {type: &#x27;rotate&#x27;});
     *
     *      // Apply the rotation to all but the first point of the square
     *      rot.bindTo(sq.slice(1));
     *
     * &lt;div id=&quot;c7f9097e-2ad7-11e5-8dd9-901b0e1b8723&quot; style=&quot;width: 300px; height: 300px;&quot;&gt;&lt;/div&gt;
     * &lt;script type=&quot;text/javascript&quot;&gt;
     * (function() {
     *  var board = JXG.JSXGraph.initBoard(&#x27;c7f9097e-2ad7-11e5-8dd9-901b0e1b8723&#x27;,
     *      {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});
     *  // Construct a square of side length 2 with the
     *  // help of transformations
     *  var sq = [],
     *    right = board.create(&#x27;transform&#x27;, [2, 0], {type: &#x27;translate&#x27;}),
     *    up = board.create(&#x27;transform&#x27;, [0, 2], {type: &#x27;translate&#x27;}),
     *    pol, rot, p0;
     *   // The first point is free
     *   sq[0] = board.create(&#x27;point&#x27;, [0, 0], {name: &#x27;Drag me&#x27;}),
     *   // Construct the other free points by transformations
     *   sq[1] = board.create(&#x27;point&#x27;, [sq[0], right]),
     *   sq[2] = board.create(&#x27;point&#x27;, [sq[0], [right, up]]),
     *   sq[3] = board.create(&#x27;point&#x27;, [sq[0], up]),
     *   // Polygon through these four points
     *   pol = board.create(&#x27;polygon&#x27;, sq, {
     *        fillColor:&#x27;blue&#x27;,
     *        gradient:&#x27;radial&#x27;,
     *        gradientsecondcolor:&#x27;white&#x27;,
     *        gradientSecondOpacity:&#x27;0&#x27;
     *  }),
     *  p0 = board.create(&#x27;point&#x27;, [0, 3], {name: &#x27;angle&#x27;}),
     * // Rotate the square around point sq[0] by dragging A
     * rot = board.create(&#x27;transform&#x27;, [&#x27;Y(angle)&#x27;, sq[0]], {type: &#x27;rotate&#x27;});
     * // Apply the rotation to all but the first point of the square
     * rot.bindTo(sq.slice(1));
     * })();
     * &lt;/script&gt;
     *
     */
    JXG.createTransform = function (board, parents, attributes) {
        return new JXG.Transformation(board, attributes.type, parents);
    };

    JXG.registerElement(&#x27;transform&#x27;, JXG.createTransform);

    return {
        Transformation: JXG.Transformation,
        createTransform: JXG.createTransform
    };
});

    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>

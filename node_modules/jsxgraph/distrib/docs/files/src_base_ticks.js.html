<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src/base/ticks.js - JSXGraph</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="../assets/js/jsxgraphcore.js"></script>
    <link rel="stylesheet" href="../assets/css/jsxgraph.css">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../assets/css/logo_blue.png" title="JSXGraph" width="117" height="52"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.99.4</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/Angle.html">Angle</a> </li>
                                <li><a href="../classes/Arc.html">Arc</a> </li>
                                <li><a href="../classes/Arrow.html">Arrow</a> </li>
                                <li><a href="../classes/Arrowparallel.html">Arrowparallel</a> </li>
                                <li><a href="../classes/Axis.html">Axis</a> </li>
                                <li><a href="../classes/Bisector.html">Bisector</a> </li>
                                <li><a href="../classes/Bisectorlines.html">Bisectorlines</a> </li>
                                <li><a href="../classes/Button.html">Button</a> </li>
                                <li><a href="../classes/Checkbox.html">Checkbox</a> </li>
                                <li><a href="../classes/Circle.html">Circle</a> </li>
                                <li><a href="../classes/Circumcenter.html">Circumcenter</a> </li>
                                <li><a href="../classes/Circumcircle.html">Circumcircle</a> </li>
                                <li><a href="../classes/CircumcircleArc.html">CircumcircleArc</a> </li>
                                <li><a href="../classes/CircumcircleSector.html">CircumcircleSector</a> </li>
                                <li><a href="../classes/Conic.html">Conic</a> </li>
                                <li><a href="../classes/Curve.html">Curve</a> </li>
                                <li><a href="../classes/Ellipse.html">Ellipse</a> </li>
                                <li><a href="../classes/EventEmitter.html">EventEmitter</a> </li>
                                <li><a href="../classes/Functiongraph.html">Functiongraph</a> </li>
                                <li><a href="../classes/Glider.html">Glider</a> </li>
                                <li><a href="../classes/Grid.html">Grid</a> </li>
                                <li><a href="../classes/Group.html">Group</a> </li>
                                <li><a href="../classes/Hatch.html">Hatch</a> </li>
                                <li><a href="../classes/Hyperbola.html">Hyperbola</a> </li>
                                <li><a href="../classes/Image.html">Image</a> </li>
                                <li><a href="../classes/Incenter.html">Incenter</a> </li>
                                <li><a href="../classes/Incircle.html">Incircle</a> </li>
                                <li><a href="../classes/Inequality.html">Inequality</a> </li>
                                <li><a href="../classes/Input.html">Input</a> </li>
                                <li><a href="../classes/Integral.html">Integral</a> </li>
                                <li><a href="../classes/Intersection.html">Intersection</a> </li>
                                <li><a href="../classes/JXG.html">JXG</a> </li>
                                <li><a href="../classes/JXG.AbstractRenderer.html">JXG.AbstractRenderer</a> </li>
                                <li><a href="../classes/JXG.Board.html">JXG.Board</a> </li>
                                <li><a href="../classes/JXG.C.html">JXG.C</a> </li>
                                <li><a href="../classes/JXG.CanvasRenderer.html">JXG.CanvasRenderer</a> </li>
                                <li><a href="../classes/JXG.Chart.html">JXG.Chart</a> </li>
                                <li><a href="../classes/JXG.Circle.html">JXG.Circle</a> </li>
                                <li><a href="../classes/JXG.Complex.html">JXG.Complex</a> </li>
                                <li><a href="../classes/JXG.Composition.html">JXG.Composition</a> </li>
                                <li><a href="../classes/JXG.Coords.html">JXG.Coords</a> </li>
                                <li><a href="../classes/JXG.CoordsElement.html">JXG.CoordsElement</a> </li>
                                <li><a href="../classes/JXG.Curve.html">JXG.Curve</a> </li>
                                <li><a href="../classes/JXG.GeometryElement.html">JXG.GeometryElement</a> </li>
                                <li><a href="../classes/JXG.Group.html">JXG.Group</a> </li>
                                <li><a href="../classes/JXG.Image.html">JXG.Image</a> </li>
                                <li><a href="../classes/JXG.JSXGraph.html">JXG.JSXGraph</a> </li>
                                <li><a href="../classes/JXG.Line.html">JXG.Line</a> </li>
                                <li><a href="../classes/JXG.Math.html">JXG.Math</a> </li>
                                <li><a href="../classes/JXG.Math.Geometry.html">JXG.Math.Geometry</a> </li>
                                <li><a href="../classes/JXG.Math.Numerics.html">JXG.Math.Numerics</a> </li>
                                <li><a href="../classes/JXG.Math.Poly.html">JXG.Math.Poly</a> </li>
                                <li><a href="../classes/JXG.Math.Poly.Monomial.html">JXG.Math.Poly.Monomial</a> </li>
                                <li><a href="../classes/JXG.Math.Poly.Polynomial.html">JXG.Math.Poly.Polynomial</a> </li>
                                <li><a href="../classes/JXG.Math.Poly.Ring.html">JXG.Math.Poly.Ring</a> </li>
                                <li><a href="../classes/JXG.Math.Quadtree.html">JXG.Math.Quadtree</a> </li>
                                <li><a href="../classes/JXG.Math.Statistics.html">JXG.Math.Statistics</a> </li>
                                <li><a href="../classes/JXG.Math.Symbolic.html">JXG.Math.Symbolic</a> </li>
                                <li><a href="../classes/JXG.NoRenderer.html">JXG.NoRenderer</a> </li>
                                <li><a href="../classes/JXG.Options.html">JXG.Options</a> </li>
                                <li><a href="../classes/JXG.Point.html">JXG.Point</a> </li>
                                <li><a href="../classes/JXG.Polygon.html">JXG.Polygon</a> </li>
                                <li><a href="../classes/JXG.SVGRenderer.html">JXG.SVGRenderer</a> </li>
                                <li><a href="../classes/JXG.Text.html">JXG.Text</a> </li>
                                <li><a href="../classes/JXG.Ticks.html">JXG.Ticks</a> </li>
                                <li><a href="../classes/JXG.Transformation.html">JXG.Transformation</a> </li>
                                <li><a href="../classes/JXG.Turtle.html">JXG.Turtle</a> </li>
                                <li><a href="../classes/JXG.Util.Base64.html">JXG.Util.Base64</a> </li>
                                <li><a href="../classes/JXG.Util.Unzip.html">JXG.Util.Unzip</a> </li>
                                <li><a href="../classes/JXG.VMLRenderer.html">JXG.VMLRenderer</a> </li>
                                <li><a href="../classes/Line.html">Line</a> </li>
                                <li><a href="../classes/Locus.html">Locus</a> </li>
                                <li><a href="../classes/MajorArc.html">MajorArc</a> </li>
                                <li><a href="../classes/Midpoint.html">Midpoint</a> </li>
                                <li><a href="../classes/MinorArc.html">MinorArc</a> </li>
                                <li><a href="../classes/MinorSector.html">MinorSector</a> </li>
                                <li><a href="../classes/Mirrorpoint.html">Mirrorpoint</a> </li>
                                <li><a href="../classes/NonReflexAngle.html">NonReflexAngle</a> </li>
                                <li><a href="../classes/Normal.html">Normal</a> </li>
                                <li><a href="../classes/Orthogonalprojection.html">Orthogonalprojection</a> </li>
                                <li><a href="../classes/OtherIntersection.html">OtherIntersection</a> </li>
                                <li><a href="../classes/Parabola.html">Parabola</a> </li>
                                <li><a href="../classes/Parallel.html">Parallel</a> </li>
                                <li><a href="../classes/Parallelpoint.html">Parallelpoint</a> </li>
                                <li><a href="../classes/Perpendicular.html">Perpendicular</a> </li>
                                <li><a href="../classes/PerpendicularPoint.html">PerpendicularPoint</a> </li>
                                <li><a href="../classes/PerpendicularSegment.html">PerpendicularSegment</a> </li>
                                <li><a href="../classes/Point.html">Point</a> </li>
                                <li><a href="../classes/PolarLine.html">PolarLine</a> </li>
                                <li><a href="../classes/PolePoint.html">PolePoint</a> </li>
                                <li><a href="../classes/Polygon.html">Polygon</a> </li>
                                <li><a href="../classes/RadicalAxis.html">RadicalAxis</a> </li>
                                <li><a href="../classes/Reflection.html">Reflection</a> </li>
                                <li><a href="../classes/ReflexAngle.html">ReflexAngle</a> </li>
                                <li><a href="../classes/registerReader.html">registerReader</a> </li>
                                <li><a href="../classes/RegularPolygon.html">RegularPolygon</a> </li>
                                <li><a href="../classes/Riemannsum.html">Riemannsum</a> </li>
                                <li><a href="../classes/Sector.html">Sector</a> </li>
                                <li><a href="../classes/Segment.html">Segment</a> </li>
                                <li><a href="../classes/Semicircle.html">Semicircle</a> </li>
                                <li><a href="../classes/Slider.html">Slider</a> </li>
                                <li><a href="../classes/Slopetriangle.html">Slopetriangle</a> </li>
                                <li><a href="../classes/Spline.html">Spline</a> </li>
                                <li><a href="../classes/Stepfunction.html">Stepfunction</a> </li>
                                <li><a href="../classes/Tangent.html">Tangent</a> </li>
                                <li><a href="../classes/Tapemeasure.html">Tapemeasure</a> </li>
                                <li><a href="../classes/Text.html">Text</a> </li>
                                <li><a href="../classes/Ticks.html">Ticks</a> </li>
                                <li><a href="../classes/Tracecurve.html">Tracecurve</a> </li>
                                <li><a href="../classes/Transformation.html">Transformation</a> </li>
                                <li><a href="../classes/Turtle.html">Turtle</a> </li>
                            </ul>
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="../modules/JXG.html">JXG</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: src/base/ticks.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/*
    Copyright 2008-2015
        Matthias Ehmann,
        Michael Gerhaeuser,
        Carsten Miller,
        Bianca Valentin,
        Alfred Wassermann,
        Peter Wilfahrt

    This file is part of JSXGraph.

    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.

    You can redistribute it and/or modify it under the terms of the

      * GNU Lesser General Public License as published by
        the Free Software Foundation, either version 3 of the License, or
        (at your option) any later version
      OR
      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT

    JSXGraph is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License and
    the MIT License along with JSXGraph. If not, see &lt;http://www.gnu.org/licenses/&gt;
    and &lt;http://opensource.org/licenses/MIT/&gt;.
 */


/*global JXG: true, define: true*/
/*jslint nomen: true, plusplus: true*/

/* depends:
 jxg
 math/math
 math/geometry
 base/constants
 base/element
 base/coords
 utils/type
  elements:
   text
 */

/**
 * @fileoverview In this file the geometry object Ticks is defined. Ticks provides
 * methods for creation and management of ticks on an axis.
 * @author graphjs
 * @version 0.1
 */

define([
    &#x27;jxg&#x27;, &#x27;math/math&#x27;, &#x27;math/geometry&#x27;, &#x27;base/constants&#x27;, &#x27;base/element&#x27;, &#x27;base/coords&#x27;, &#x27;utils/type&#x27;, &#x27;base/text&#x27;
], function (JXG, Mat, Geometry, Const, GeometryElement, Coords, Type, Text) {

    &quot;use strict&quot;;

    /**
     * Ticks provides methods for creation and management
     * of ticks on a line element.
     *
     * @class JXG.Ticks
     * @param {JXG.Line} line Reference to the axis the ticks are drawn on.
     * @param {Number|Array} ticks Number defining the distance between two major ticks or an array defining static ticks.
     * @param {Object} attributes Properties
     * @see JXG.Line#addTicks
     * @constructor
     * @extends JXG.GeometryElement
     */
    JXG.Ticks = function (line, ticks, attributes) {
        this.constructor(line.board, attributes, Const.OBJECT_TYPE_TICKS, Const.OBJECT_CLASS_OTHER);

        /**
         * The line the ticks belong to.
         *
         * @property line
         * @type JXG.Line
         */
        this.line = line;

        /**
         * The board the ticks line is drawn on.
         * @property board
         * @type JXG.Board
         */
        this.board = this.line.board;

        /**
         * A function calculating ticks delta depending on the ticks number.
         *
         * @property ticksFunction
         * @type Function
         */
        this.ticksFunction = null;

        /**
         * Array of fixed ticks.
         *
         * @property fixedTicks
         * @type Array
         */
        this.fixedTicks = null;

        /**
         * Equidistant ticks. Distance is defined by ticksFunction
         *
         * @property equidistant
         * @type Boolean
         */
        this.equidistant = false;

        if (Type.isFunction(ticks)) {
            this.ticksFunction = ticks;
            throw new Error(&quot;Function arguments are no longer supported.&quot;);
        }

        if (Type.isArray(ticks)) {
            this.fixedTicks = ticks;
        } else {
            if (Math.abs(ticks) &lt; Mat.eps || ticks &lt; 0) {
                ticks = attributes.defaultdistance;
            }

            /*
             * Ticks function:
             * determines the distance (in user units) of two major ticks
             */
            this.ticksFunction = this.makeTicksFunction(ticks);

            this.equidistant = true;
        }

        /**
         * Least distance between two ticks, measured in pixels.
         *
         * @property minTicksDistance
         * @type int
         */
        this.minTicksDistance = attributes.minticksdistance;

        /**
         * Stores the ticks coordinates
         *
         * @property ticks
         * @type {Array}
         */
        this.ticks = [];

        /**
         * Distance between two major ticks in user coordinates
         *
         * @property ticksDelta
         * @type {Number}
         */
        this.ticksDelta = 1;

        /**
         * Array where the labels are saved. There is an array element for every tick,
         * even for minor ticks which don&#x27;t have labels. In this case the array element
         * contains just &lt;tt&gt;null&lt;/tt&gt;.
         *
         * @property labels
         * @type Array
         */
        this.labels = [];

        /**
         * A list of labels that are currently unused and ready for reassignment.
         *
         * @property labelsRepo
         * @type {Array}
         */
        this.labelsRepo = [];

        /**
         * To ensure the uniqueness of label ids this counter is used.
         *
         * @property labelCounter
         * @type {number}
         */
        this.labelCounter = 0;

        this.id = this.line.addTicks(this);
        this.board.setId(this, &#x27;Ti&#x27;);
    };

    JXG.Ticks.prototype = new GeometryElement();

    JXG.extend(JXG.Ticks.prototype, /** @lends JXG.Ticks.prototype */ {

        /**
         * Ticks function:
         * determines the distance (in user units) of two major ticks.
         * See above in constructor and in @see JXG.GeometryElement#setAttribute
         *
         * @method makeTicksFunction
         * @private
         * @param {Number} ticks Distance between two major ticks
         * @return {Function} returns method ticksFunction
         */
        makeTicksFunction: function (ticks) {
            return function () {
                var delta, b, dist;

                if (this.visProp.insertticks) {
                    b = this.getLowerAndUpperBounds(this.getZeroCoordinates(), &#x27;ticksdistance&#x27;);
                    dist = b.upper - b.lower;
                    delta = Math.pow(10, Math.floor(Math.log(0.6 * dist) / Math.LN10));
                    if (dist &lt;= 6 * delta) {
                        delta *= 0.5;
                    }
                    return delta;
                }

                // upto 0.99.1:
                return ticks;
            };
        },

        /**
         * Checks whether (x,y) is near the line.
         *
         * @method hasPoint
         * @param {Number} x Coordinate in x direction, screen coordinates.
         * @param {Number} y Coordinate in y direction, screen coordinates.
         * @return {Boolean} True if (x,y) is near the line, False otherwise.
         */
        hasPoint: function (x, y) {
            var i, t,
                len = (this.ticks &amp;&amp; this.ticks.length) || 0,
                r = this.board.options.precision.hasPoint;

            if (!this.line.visProp.scalable) {
                return false;
            }

            // Ignore non-axes and axes that are not horizontal or vertical
            if (this.line.stdform[1] !== 0 &amp;&amp; this.line.stdform[2] !== 0 &amp;&amp; this.line.type !== Const.OBJECT_TYPE_AXIS) {
                return false;
            }

            for (i = 0; i &lt; len; i++) {
                t = this.ticks[i];

                // Skip minor ticks
                if (t[2]) {
                    // Ignore ticks at zero
                    if (!((this.line.stdform[1] === 0 &amp;&amp; Math.abs(t[0][0] - this.line.point1.coords.scrCoords[1]) &lt; Mat.eps) ||
                            (this.line.stdform[2] === 0 &amp;&amp; Math.abs(t[1][0] - this.line.point1.coords.scrCoords[2]) &lt; Mat.eps))) {
                        // tick length is not zero, ie. at least one pixel
                        if (Math.abs(t[0][0] - t[0][1]) &gt;= 1 || Math.abs(t[1][0] - t[1][1]) &gt;= 1) {
                            if (this.line.stdform[1] === 0) {
                                // Allow dragging near axes only.
                                if (Math.abs(y - (t[1][0] + t[1][1]) * 0.5) &lt; 2 * r &amp;&amp; t[0][0] - r &lt; x &amp;&amp; x &lt; t[0][1] + r) {
                                    return true;
                                }
                            } else if (this.line.stdform[2] === 0) {
                                if (Math.abs(x - (t[0][0] + t[0][1]) * 0.5) &lt; 2 * r &amp;&amp; t[1][0] - r &lt; y &amp;&amp; y &lt; t[1][1] + r) {
                                    return true;
                                }
                            }
                        }
                    }
                }
            }

            return false;
        },

        /**
         * Sets x and y coordinate of the tick.
         *
         * @method setPositionDirectly
         * @param {number} method The type of coordinates used here. Possible values are {@link JXG.COORDS_BY_USER} and {@link JXG.COORDS_BY_SCREEN}.
         * @param {Array} coords coordinates in screen/user units
         * @param {Array} oldcoords previous coordinates in screen/user units
         * @return {JXG.Ticks} this element
         * @chainable
         */
        setPositionDirectly: function (method, coords, oldcoords) {
            var dx, dy,
                c = new Coords(method, coords, this.board),
                oldc = new Coords(method, oldcoords, this.board),
                bb = this.board.getBoundingBox();

            if (!this.line.visProp.scalable) {
                return this;
            }

            // horizontal line
            if (Math.abs(this.line.stdform[1]) &lt; Mat.eps &amp;&amp; Math.abs(c.usrCoords[1] * oldc.usrCoords[1]) &gt; Mat.eps) {
                dx = oldc.usrCoords[1] / c.usrCoords[1];
                bb[0] *= dx;
                bb[2] *= dx;
                this.board.setBoundingBox(bb, false);
            // vertical line
            } else if (Math.abs(this.line.stdform[2]) &lt; Mat.eps &amp;&amp; Math.abs(c.usrCoords[2] * oldc.usrCoords[2]) &gt; Mat.eps) {
                dy = oldc.usrCoords[2] / c.usrCoords[2];
                bb[3] *= dy;
                bb[1] *= dy;
                this.board.setBoundingBox(bb, false);
            }

            return this;
        },

         /**
         * (Re-)calculates the ticks coordinates.
         *
         * @method calculateTicksCoordinates
         * @private
         * @return {JXG.Ticks} this element
         * @chainable
         */
        calculateTicksCoordinates: function () {
            var coordsZero, bounds, i,
                oldRepoLength = this.labelsRepo.length;

            // Calculate Ticks width and height in Screen and User Coordinates
            this.setTicksSizeVariables();
            // If the parent line is not finite, we can stop here.
            if (Math.abs(this.dx) &lt; Mat.eps &amp;&amp; Math.abs(this.dy) &lt; Mat.eps) {
                return this;
            }

            // Get Zero
            coordsZero = this.getZeroCoordinates();

            // Calculate lower bound and upper bound limits based on distance between p1 and centre and p2 and centre
            bounds = this.getLowerAndUpperBounds(coordsZero);

            // Clean up
            this.removeTickLabels();
            this.ticks = [];
            this.labels = [];

            // Create Ticks Coordinates and Labels
            if (this.equidistant) {
                this.generateEquidistantTicks(coordsZero, bounds);
            } else {
                this.generateFixedTicks(coordsZero, bounds);
            }

            // Hide unused labels in labelsRepo
            for (i = oldRepoLength; i &lt; this.labelsRepo.length; i++) {
                this.labelsRepo[i].setAttribute({visible: false});
            }

            return this;
        },

        /**
         * Sets the variables used to set the height and slope of each tick.
         *
         * @method setTicksSizeVariables
         * @private
         * @return {JXG.Ticks} this element
         * @chainable
         */
        setTicksSizeVariables: function () {
            var d,
                distMaj = this.visProp.majorheight * 0.5,
                distMin = this.visProp.minorheight * 0.5;

            // ticks width and height in screen units
            this.dxMaj = this.line.stdform[1];
            this.dyMaj = this.line.stdform[2];
            this.dxMin = this.dxMaj;
            this.dyMin = this.dyMaj;

            // ticks width and height in user units
            this.dx = this.dxMaj;
            this.dy = this.dyMaj;

            // After this, the length of the vector (dxMaj, dyMaj) in screen coordinates is equal to distMaj pixel.
            d = Math.sqrt(
                this.dxMaj * this.dxMaj * this.board.unitX * this.board.unitX +
                    this.dyMaj * this.dyMaj * this.board.unitY * this.board.unitY
            );
            this.dxMaj *= distMaj / d * this.board.unitX;
            this.dyMaj *= distMaj / d * this.board.unitY;
            this.dxMin *= distMin / d * this.board.unitX;
            this.dyMin *= distMin / d * this.board.unitY;

            // Grid-like ticks?
            this.minStyle = &#x27;finite&#x27;;
            if (this.visProp.minorheight &lt; 0) {
                this.minStyle = &#x27;infinite&#x27;;
            }

            this.majStyle = &#x27;finite&#x27;;
            if (this.visProp.majorheight &lt; 0) {
                this.majStyle = &#x27;infinite&#x27;;
            }

            return this;
        },

        /**
         * Returns the coordinates of the point zero of the line.
         *
         * If the line is an {@link Axis}, the coordinates of the projection of the board&#x27;s zero point is returned
         *
         * Otherwise, the coordinates of the point that acts as zero are established depending on the value of {@link JXG.Ticks#anchor}
         *
         * @method getZeroCoordinates
         * @return {JXG.Coords} Coords object for the Zero point on the line
         * @private
         */
        getZeroCoordinates: function () {
            if (this.line.type === Const.OBJECT_TYPE_AXIS) {
                return Geometry.projectPointToLine({
                    coords: {
                        usrCoords: [1, 0, 0]
                    }
                }, this.line, this.board);
            }

            if (this.visProp.anchor === &#x27;right&#x27;) {
                return this.line.point2.coords;
            }

            if (this.visProp.anchor === &#x27;middle&#x27;) {
                return new Coords(Const.COORDS_BY_USER, [
                    (this.line.point1.coords.usrCoords[1] + this.line.point2.coords.usrCoords[1]) / 2,
                    (this.line.point1.coords.usrCoords[2] + this.line.point2.coords.usrCoords[2]) / 2
                ], this.board);
            }

            return this.line.point1.coords;
        },

        /**
         * Calculate the lower and upper bounds for tick rendering
         * If {@link JXG.Ticks#includeBoundaries} is false, the boundaries will exclude point1 and point2
         *
         * @method getLowerAndUpperBounds
         * @param  {JXG.Coords} coordsZero
         * @return {String} type  (Optional) If type==&#x27;ticksdistance&#x27; the bounds are the intersection of the line with the bounding box of the board.
         *              Otherwise it is the projection of the corners of the bounding box to the line. The first case i s needed to automatically
         *              generate ticks. The second case is for drawing of the ticks.
         * @return {Object}     contains the lower and upper bounds
         *
         * @private
         */
        getLowerAndUpperBounds: function (coordsZero, type) {
            var lowerBound, upperBound,
                // The line&#x27;s defining points that will be adjusted to be within the board limits
                point1 = new Coords(Const.COORDS_BY_USER, this.line.point1.coords.usrCoords, this.board),
                point2 = new Coords(Const.COORDS_BY_USER, this.line.point2.coords.usrCoords, this.board),
                // Are the original defining points within the board?
                isPoint1inBoard = (Math.abs(point1.usrCoords[0]) &gt;= Mat.eps &amp;&amp;
                    point1.scrCoords[1] &gt;= 0.0 &amp;&amp; point1.scrCoords[1] &lt;= this.board.canvasWidth &amp;&amp;
                    point1.scrCoords[2] &gt;= 0.0 &amp;&amp; point1.scrCoords[2] &lt;= this.board.canvasHeight),
                isPoint2inBoard = (Math.abs(point2.usrCoords[0]) &gt;= Mat.eps &amp;&amp;
                    point2.scrCoords[1] &gt;= 0.0 &amp;&amp; point2.scrCoords[1] &lt;= this.board.canvasWidth &amp;&amp;
                    point2.scrCoords[2] &gt;= 0.0 &amp;&amp; point2.scrCoords[2] &lt;= this.board.canvasHeight),
                // We use the distance from zero to P1 and P2 to establish lower and higher points
                dZeroPoint1, dZeroPoint2;

            // Adjust line limit points to be within the board
            if (JXG.exists(type) || type === &#x27;tickdistance&#x27;) {
                // The good old calcStraight is needed for determining the distance between major ticks.
                // Here, only the visual area is of importance
                Geometry.calcStraight(this.line, point1, point2);
            } else {
                // This function projects the corners of the board to the line.
                // This is important for diagonal lines with infinite tick lines.
                Geometry.calcLineDelimitingPoints(this.line, point1, point2);
            }

            // Calculate distance from Zero to P1 and to P2
            dZeroPoint1 = this.getDistanceFromZero(coordsZero, point1);
            dZeroPoint2 = this.getDistanceFromZero(coordsZero, point2);

            // We have to establish if the direction is P1-&gt;P2 or P2-&gt;P1 to set the lower and upper
            // boundaries appropriately. As the distances contain also a sign to indicate direction,
            // we can compare dZeroPoint1 and dZeroPoint2 to establish the line direction
            if (dZeroPoint1 &lt; dZeroPoint2) { // Line goes P1-&gt;P2
                lowerBound = dZeroPoint1;
                if (!this.line.visProp.straightfirst &amp;&amp; isPoint1inBoard &amp;&amp; !this.visProp.includeboundaries) {
                    lowerBound += Mat.eps;
                }
                upperBound = dZeroPoint2;
                if (!this.line.visProp.straightlast &amp;&amp; isPoint2inBoard &amp;&amp; !this.visProp.includeboundaries) {
                    upperBound -= Mat.eps;
                }
            } else if (dZeroPoint2 &lt; dZeroPoint1) { // Line goes P2-&gt;P1
                lowerBound = dZeroPoint2;
                if (!this.line.visProp.straightlast &amp;&amp; isPoint2inBoard &amp;&amp; !this.visProp.includeboundaries) {
                    lowerBound += Mat.eps;
                }
                upperBound = dZeroPoint1;
                if (!this.line.visProp.straightfirst &amp;&amp; isPoint1inBoard &amp;&amp; !this.visProp.includeboundaries) {
                    upperBound -= Mat.eps;
                }
            } else { // P1 = P2 = Zero, we can&#x27;t do a thing
                lowerBound = 0;
                upperBound = 0;
            }

            return {
                lower: lowerBound,
                upper: upperBound
            };
        },

        /**
         * Calculates the distance in user coordinates from zero to a given point including its sign
         *
         * @method getDistanceFromZero
         * @param  {JXG.Coords} zero  coordinates of the point considered zero
         * @param  {JXG.Coords} point coordinates of the point to find out the distance
         * @return {Number}           distance between zero and point, including its sign
         * @private
         */
        getDistanceFromZero: function (zero, point) {
            var eps = Mat.eps * Mat.eps,
                distance = zero.distance(Const.COORDS_BY_USER, point);

            // Establish sign
            if (this.line.type === Const.OBJECT_TYPE_AXIS) {
                if (zero.usrCoords[1] - point.usrCoords[1] &gt; eps ||
                        (Math.abs(zero.usrCoords[1] - point.usrCoords[1]) &lt; eps &amp;&amp;
                        zero.usrCoords[2] - point.usrCoords[2] &gt; eps)) {
                    distance *= -1;
                }
            } else if (this.visProp.anchor === &#x27;right&#x27;) {
                if (Geometry.isSameDirection(zero, this.line.point1.coords, point)) {
                    distance *= -1;
                }
            } else {
                if (!Geometry.isSameDirection(zero, this.line.point2.coords, point)) {
                    distance *= -1;
                }
            }
            return distance;
        },

        /**
         * Creates ticks coordinates and labels automatically.
         * The frequency of ticks is affected by the values of {@link JXG.Ticks#insertTicks} and {@link JXG.Ticks#ticksDistance}
         *
         * @method generateEquidistantTicks
         * @param  {JXG.Coords} coordsZero coordinates of the point considered zero
         * @param  {Object}     bounds     contains the lower and upper boundaries for ticks placement
         * @private
         * @return {JXG.Ticks} this element
         * @chainable
         */
        generateEquidistantTicks: function (coordsZero, bounds) {
            var tickPosition,
                // Calculate X and Y distance between two major ticks
                deltas = this.getXandYdeltas(),
                // Distance between two major ticks in user coordinates
                ticksDelta = (this.equidistant ? this.ticksFunction(1) : this.ticksDelta);

            // adjust ticks distance
            ticksDelta *= this.visProp.scale;
            if (this.visProp.insertticks &amp;&amp; this.minTicksDistance &gt; Mat.eps) {
                ticksDelta = this.adjustTickDistance(ticksDelta, coordsZero, deltas);
                ticksDelta /= (this.visProp.minorticks + 1);
            } else if (!this.visProp.insertticks) {
                ticksDelta /= (this.visProp.minorticks + 1);
            }
            this.ticksDelta = ticksDelta;

            if (ticksDelta &lt; Mat.eps) {
                return this;
            }

            // Position ticks from zero to the positive side while not reaching the upper boundary
            tickPosition = 0;
            if (!this.visProp.drawzero) {
                tickPosition = ticksDelta;
            }

            while (tickPosition &lt;= bounds.upper) {
                // Only draw ticks when we are within bounds, ignore case where  tickPosition &lt; lower &lt; upper
                if (tickPosition &gt;= bounds.lower) {
                    this.processTickPosition(coordsZero, tickPosition, ticksDelta, deltas);
                }
                tickPosition += ticksDelta;
            }

            // Position ticks from zero (not inclusive) to the negative side while not reaching the lower boundary
            tickPosition = -ticksDelta;
            while (tickPosition &gt;= bounds.lower) {
                // Only draw ticks when we are within bounds, ignore case where lower &lt; upper &lt; tickPosition
                if (tickPosition &lt;= bounds.upper) {
                    this.processTickPosition(coordsZero, tickPosition, ticksDelta, deltas);
                }
                tickPosition -= ticksDelta;
            }

            return this;
        },

        /**
         * Auxiliary method used by {@link JXG.Ticks#generateEquidistantTicks} to adjust the
         * distance between two ticks depending on {@link JXG.Ticks#minTicksDistance} value
         *
         * @method adjustTickDistance
         * @param  {Number}     ticksDelta  distance between two major ticks in user coordinates
         * @param  {JXG.Coords} coordsZero  coordinates of the point considered zero
         * @param  {Object}     deltas      x and y distance in pixel between two user units
         * @param  {Object}     bounds      upper and lower bound of the tick positions in user units.
         * @return {Number} returns the new value of ticksDelta
         * @private
         */
        adjustTickDistance: function (ticksDelta, coordsZero, deltas) {
            var nx, ny, bounds,
                distScr,
                sgn = 1;

            bounds = this.getLowerAndUpperBounds(coordsZero, &#x27;ticksdistance&#x27;);
            nx = coordsZero.usrCoords[1] + deltas.x * ticksDelta;
            ny = coordsZero.usrCoords[2] + deltas.y * ticksDelta;
            distScr = coordsZero.distance(Const.COORDS_BY_SCREEN, new Coords(Const.COORDS_BY_USER, [nx, ny], this.board));
            while (distScr / (this.visProp.minorticks + 1) &lt; this.minTicksDistance) {
                if (sgn === 1) {
                    ticksDelta *= 2;
                } else {
                    ticksDelta *= 5;
                }
                sgn *= -1;

                nx = coordsZero.usrCoords[1] + deltas.x * ticksDelta;
                ny = coordsZero.usrCoords[2] + deltas.y * ticksDelta;
                distScr = coordsZero.distance(Const.COORDS_BY_SCREEN, new Coords(Const.COORDS_BY_USER, [nx, ny], this.board));
            }
            return ticksDelta;
        },

        /**
         * Auxiliary method used by {@link JXG.Ticks#generateEquidistantTicks} to create a tick
         * in the line at the given tickPosition.
         *
         * @method processTickPosition
         * @param  {JXG.Coords} coordsZero    coordinates of the point considered zero
         * @param  {Number}     tickPosition  current tick position relative to zero
         * @param  {Number}     ticksDelta    distance between two major ticks in user coordinates
         * @param  {Object}     deltas      x and y distance between two major ticks
         * @private
         * @return {JXG.Ticks} this element
         * @chainable
         */
        processTickPosition: function (coordsZero, tickPosition, ticksDelta, deltas) {
            var x, y, tickCoords, ti, labelText;
            // Calculates tick coordinates
            x = coordsZero.usrCoords[1] + tickPosition * deltas.x;
            y = coordsZero.usrCoords[2] + tickPosition * deltas.y;
            tickCoords = new Coords(Const.COORDS_BY_USER, [x, y], this.board);

            // Test if tick is a major tick.
            // This is the case if tickPosition/ticksDelta is
            // a multiple of the number of minorticks+1
            tickCoords.major = Math.round(tickPosition / ticksDelta) % (this.visProp.minorticks + 1) === 0;

            // Compute the start position and the end position of a tick.
            // If both positions are out of the canvas, ti is empty.
            ti = this.tickEndings(tickCoords, tickCoords.major);
            if (ti.length === 3) {
                this.ticks.push(ti);

                if (tickCoords.major &amp;&amp; this.visProp.drawlabels) {
                    labelText = this.generateLabelText(tickCoords, coordsZero);
                    this.labels.push(this.generateLabel(labelText, tickCoords, this.ticks.length));
                } else {
                    this.labels.push(null);
                }
            }

            return this;
        },

        /**
         * Creates ticks coordinates and labels based on {@link JXG.Ticks#fixedTicks} and {@link JXG.Ticks#labels}.
         *
         * @method generateFixedTicks
         * @param  {JXG.Coords} coordsZero Coordinates of the point considered zero
         * @param  {Object}     bounds     contains the lower and upper boundaries for ticks placement
         * @private
         * @return {JXG.Ticks} this element
         * @chainable
         */
        generateFixedTicks: function (coordsZero, bounds) {
            var tickCoords, labelText, i, ti,
                x, y,
                hasLabelOverrides = Type.isArray(this.visProp.labels),
                // Calculate X and Y distance between two major points in the line
                deltas = this.getXandYdeltas();

            for (i = 0; i &lt; this.fixedTicks.length; i++) {
                x = coordsZero.usrCoords[1] + this.fixedTicks[i] * deltas.x;
                y = coordsZero.usrCoords[2] + this.fixedTicks[i] * deltas.y;
                tickCoords = new Coords(Const.COORDS_BY_USER, [x, y], this.board);

                // Compute the start position and the end position of a tick.
                // If tick is out of the canvas, ti is empty.
                ti = this.tickEndings(tickCoords, true);
                if (ti.length === 3 &amp;&amp; this.fixedTicks[i] &gt;= bounds.lower &amp;&amp; this.fixedTicks[i] &lt;= bounds.upper) {
                    this.ticks.push(ti);

                    if (this.visProp.drawlabels &amp;&amp; (hasLabelOverrides || Type.exists(this.visProp.labels[i]))) {
                        labelText = hasLabelOverrides ? this.visProp.labels[i] : this.fixedTicks[i];
                        this.labels.push(
                            this.generateLabel(this.generateLabelText(tickCoords, coordsZero, labelText), tickCoords, i)
                        );
                    } else {
                        this.labels.push(null);
                    }
                }
            }

            return this;
        },

        /**
         * Calculates the x and y distance in pixel between two units in user space.
         *
         * @method getXandYdeltas
         * @return {Object} Object of the from
         *
         *         {
         *             x: Number,
         *             y: Number
         *         }
         *
         * @private
         */
        getXandYdeltas: function () {
            var
                // Auxiliary points to store the start and end of the line according to its direction
                point1UsrCoords, point2UsrCoords,
                distP1P2 = this.line.point1.Dist(this.line.point2);

            if (this.line.type === Const.OBJECT_TYPE_AXIS) {
                // When line is an Axis, direction depends on Board Coordinates system

                // assume line.point1 and line.point2 are in correct order
                point1UsrCoords = this.line.point1.coords.usrCoords;
                point2UsrCoords = this.line.point2.coords.usrCoords;

                // Check if direction is incorrect, then swap
                if (point1UsrCoords[1] &gt; point2UsrCoords[1] ||
                        (Math.abs(point1UsrCoords[1] - point2UsrCoords[1]) &lt; Mat.eps &amp;&amp;
                        point1UsrCoords[2] &gt; point2UsrCoords[2])) {
                    point1UsrCoords = this.line.point2.coords.usrCoords;
                    point2UsrCoords = this.line.point1.coords.usrCoords;
                }
            } else {
                // line direction is always from P1 to P2 for non Axis types
                point1UsrCoords = this.line.point1.coords.usrCoords;
                point2UsrCoords = this.line.point2.coords.usrCoords;
            }
            return {
                x: (point2UsrCoords[1] - point1UsrCoords[1]) / distP1P2,
                y: (point2UsrCoords[2] - point1UsrCoords[2]) / distP1P2
            };
        },

        /**
         *
         * @method tickEndings
         * @param {JXG.Coords} coords Coordinates of the tick on the line.
         * @param {Boolean} major True if tick is major tick.
         * @return {Array} Array of length 3 containing start and end coordinates in screen coordinates
         *                 of the tick (arrays of length 2). 3rd entry is true if major tick otherwise false.
         *                 If the tick is outside of the canvas, the return array is empty.
         * @private
         */
        tickEndings: function (coords, major) {
            var c, lineStdForm, intersection,
                dxs, dys,
                style,
                cw = this.board.canvasWidth,
                ch = this.board.canvasHeight,
                x = [-1000 * cw, -1000 * ch],
                y = [-1000 * cw, -1000 * ch],
                isInsideCanvas = false;

            c = coords.scrCoords;
            if (major) {
                dxs = this.dxMaj;
                dys = this.dyMaj;
                style = this.majStyle;
            } else {
                dxs = this.dxMin;
                dys = this.dyMin;
                style = this.minStyle;
            }
            lineStdForm = [-dys * c[1] - dxs * c[2], dys, dxs];

            // For all ticks regardless if of finite or infinite
            // tick length the intersection with the canvas border is
            // computed.

            if (style === &#x27;infinite&#x27;) {
                intersection = Geometry.meetLineBoard(lineStdForm, this.board);
                x[0] = intersection[0].scrCoords[1];
                x[1] = intersection[1].scrCoords[1];
                y[0] = intersection[0].scrCoords[2];
                y[1] = intersection[1].scrCoords[2];
            } else {
                x[0] = c[1] + dxs * this.visProp.tickendings[0];
                y[0] = c[2] - dys * this.visProp.tickendings[0];
                x[1] = c[1] - dxs * this.visProp.tickendings[1];
                y[1] = c[2] + dys * this.visProp.tickendings[1];
            }

            // check if (parts of) the tick is inside the canvas.
            isInsideCanvas = (x[0] &gt;= 0 &amp;&amp; x[0] &lt;= cw &amp;&amp; y[0] &gt;= 0 &amp;&amp; y[0] &lt;= ch) ||
                (x[1] &gt;= 0 &amp;&amp; x[1] &lt;= cw &amp;&amp; y[1] &gt;= 0 &amp;&amp; y[1] &lt;= ch);

            if (isInsideCanvas) {
                return [x, y, major];
            }

            return [];
        },

        /**
         * Creates the label text for a given tick. A value for the text can be provided as a number or string
         *
         * @method generateLabelText
         * @param  {JXG.Coords}    tick  The Coords-object of the tick to create a label for
         * @param  {JXG.Coords}    zero  The Coords-object of line&#x27;s zero
         * @param  {Number|String} value A predefined value for this tick
         * @return {String}
         * @private
         */
        generateLabelText: function (tick, zero, value) {
            var labelText,
                distance = this.getDistanceFromZero(zero, tick);

            if (Math.abs(distance) &lt; Mat.eps) { // Point is zero
                labelText = &#x27;0&#x27;;
            } else {
                // No value provided, equidistant, so assign distance as value
                if (!Type.exists(value)) { // could be null or undefined
                    value = distance / this.visProp.scale;
                }

                labelText = value.toString();
                if (this.visProp.useunicodeminus) {
                    labelText = labelText.replace(/-/g, &#x27;\u2212&#x27;);
                }

                // if value is Number
                if (Type.isNumber(value)) {
                    if (labelText.length &gt; this.visProp.maxlabellength || labelText.indexOf(&#x27;e&#x27;) !== -1) {
                        labelText = value.toPrecision(this.visProp.precision).toString();
                    }
                    if (labelText.indexOf(&#x27;.&#x27;) &gt; -1 &amp;&amp; labelText.indexOf(&#x27;e&#x27;) === -1) {
                        // trim trailing zeros
                        labelText = labelText.replace(/0+$/, &#x27;&#x27;);
                        // trim trailing .
                        labelText = labelText.replace(/\.$/, &#x27;&#x27;);
                    }
                }

                if (this.visProp.scalesymbol.length &gt; 0) {
                    if (labelText === &#x27;1&#x27;) {
                        labelText = this.visProp.scalesymbol;
                    } else if (labelText === &#x27;-1&#x27;) {
                        labelText = &#x27;-&#x27; + this.visProp.scalesymbol;
                    } else if (labelText !== &#x27;0&#x27;) {
                        labelText = labelText + this.visProp.scalesymbol;
                    }
                }
            }

            return labelText;
        },

        /**
         * Create a tick label
         *
         * @method generateLabel
         * @param  {String}     labelText
         * @param  {JXG.Coords} tick
         * @param  {Number}     tickNumber
         * @return {JXG.Text}
         * @private
         */
        generateLabel: function (labelText, tick, tickNumber) {
            var label,
                attr = {
                    isLabel: true,
                    layer: this.board.options.layer.line,
                    highlightStrokeColor: this.board.options.text.strokeColor,
                    highlightStrokeWidth: this.board.options.text.strokeWidth,
                    highlightStrokeOpacity: this.board.options.text.strokeOpacity,
                    visible: this.visProp.visible,
                    priv: this.visProp.priv
                };

            attr = Type.deepCopy(attr, this.visProp.label);

            if (this.labelsRepo.length &gt; 0) {
                label = this.labelsRepo.pop();
                label.setText(labelText);
                label.setAttribute(attr);
            } else {
                this.labelCounter += 1;
                attr.id = this.id + tickNumber + &#x27;Label&#x27; + this.labelCounter;
                label = Text.createText(this.board, [tick.usrCoords[1], tick.usrCoords[2], labelText], attr);
            }

            label.isDraggable = false;
            label.dump = false;

            label.distanceX = this.visProp.label.offset[0];
            label.distanceY = this.visProp.label.offset[1];
            label.setCoords(
                tick.usrCoords[1] + label.distanceX / (this.board.unitX),
                tick.usrCoords[2] + label.distanceY / (this.board.unitY)
            );

            return label;
        },

        /**
         * Removes the HTML divs of the tick labels
         * before repositioning
         *
         * @method removeTickLabels
         * @private
         * @return {JXG.Ticks} this element
         * @chainable
         */
        removeTickLabels: function () {
            var j;

            // remove existing tick labels
            if (Type.exists(this.labels)) {
                if ((this.board.needsFullUpdate || this.needsRegularUpdate || this.needsUpdate) &amp;&amp;
                        !(this.board.renderer.type === &#x27;canvas&#x27; &amp;&amp; this.board.options.text.display === &#x27;internal&#x27;)) {
                    for (j = 0; j &lt; this.labels.length; j++) {
                        if (Type.exists(this.labels[j])) {
                            this.labelsRepo.push(this.labels[j]);
                        }
                    }
                }
            }

            return this;
        },

        /**
         * Recalculate the tick positions and the labels.
         *
         * @method update
         * @return {JXG.Ticks} this element
         * @chainable
         */
        update: function () {
            if (this.needsUpdate) {
                // A canvas with no width or height will create an endless loop, so ignore it
                if (this.board.canvasWidth !== 0 &amp;&amp; this.board.canvasHeight !== 0) {
                    this.calculateTicksCoordinates();
                }
            }

            return this;
        },

        // Documented in GeometryElement
        updateRenderer: function () {
            if (this.needsUpdate) {
                this.board.renderer.updateTicks(this);
                this.needsUpdate = false;
            }

            return this;
        },

        // Documented in GeometryElement
        hideElement: function () {
            var i;

            this.visProp.visible = false;
            this.board.renderer.hide(this);

            for (i = 0; i &lt; this.labels.length; i++) {
                if (Type.exists(this.labels[i])) {
                    this.labels[i].hideElement();
                }
            }

            return this;
        },

        // Documented in GeometryElement
        showElement: function () {
            var i;

            this.visProp.visible = true;
            this.board.renderer.show(this);

            for (i = 0; i &lt; this.labels.length; i++) {
                if (Type.exists(this.labels[i])) {
                    this.labels[i].showElement();
                }
            }

            return this;
        }
    });

    /**
     * Ticks are used as distance markers on a line.
     * The class &#x60;Ticks&#x60; provides methods for creation and management
     * of ticks on a line element.
     *
     * @class Ticks
     * @pseudo
     * @extends JXG.Ticks
     * @constructor
     * @type JXG.Ticks
     * @throws {Exception} If the element cannot be constructed with the given parent objects an exception is thrown.
     * @param {JXG.Line,Number,Function} line,_distance,_generateLabelFunc The parents consist of the line the ticks are going to be attached to and the
     * distance between two major ticks.
     * The third parameter (optional) is a function which determines the tick label. It has as parameter a coords object containing the coordinates of the new tick.
     * @example
     *
     *         // Create an axis providing two coord pairs.
     *       var p1 = board.create(&#x27;point&#x27;, [0, 3]);
     *        var p2 = board.create(&#x27;point&#x27;, [1, 3]);
     *      var l1 = board.create(&#x27;line&#x27;, [p1, p2]);
     *      var t = board.create(&#x27;ticks&#x27;, [l1], {ticksDistance: 2});
     *
     * &lt;div id=&quot;ee7f2d68-75fc-4ec0-9931-c76918427e63&quot; style=&quot;width: 300px; height: 300px;&quot;&gt;&lt;/div&gt;
     * &lt;script type=&quot;text/javascript&quot;&gt;
     * (function () {
     *   var board = JXG.JSXGraph.initBoard(&#x27;ee7f2d68-75fc-4ec0-9931-c76918427e63&#x27;, {boundingbox: [-1, 7, 7, -1], showcopyright: false, shownavigation: false});
     *   var p1 = board.create(&#x27;point&#x27;, [0, 3]);
     *   var p2 = board.create(&#x27;point&#x27;, [1, 3]);
     *   var l1 = board.create(&#x27;line&#x27;, [p1, p2]);
     *   var t = board.create(&#x27;ticks&#x27;, [l1, 2], {ticksDistance: 2});
     * })();
     * &lt;/script&gt;
     */
    JXG.createTicks = function (board, parents, attributes) {
        var el, dist,
            attr = Type.copyAttributes(attributes, board.options, &#x27;ticks&#x27;);

        if (parents.length &lt; 2) {
            dist = attr.ticksdistance;
        } else {
            dist = parents[1];
        }

        if (parents[0].elementClass === Const.OBJECT_CLASS_LINE) {
            el = new JXG.Ticks(parents[0], dist, attr);
        } else {
            throw new Error(&quot;JSXGraph: Can&#x27;t create Ticks with parent types &#x27;&quot; + (typeof parents[0]) + &quot;&#x27;.&quot;);
        }

        // deprecated
        if (typeof attr.generatelabelvalue === &#x27;function&#x27;) {
            el.generateLabelText = attr.generatelabelvalue;
        }
        if (typeof attr.generatelabeltext === &#x27;function&#x27;) {
            el.generateLabelText = attr.generatelabeltext;
        }

        el.isDraggable = true;

        return el;
    };

    /**
     * Hashes can be used to mark congruent lines.
     *
     * @pseudo
     * @class Hatch
     * @extends JXG.Ticks
     * @constructor
     * @type JXG.Ticks
     * @throws {Exception} If the element cannot be constructed with the given parent objects an exception is thrown.
     * @param {JXG.Line,Number} line,numberofhashes The parents consist of the line the hatch marks are going to be attached to and the
     * number of dashes.
     * @example
     *      // Create an axis providing two coord pairs.
     *       var p1 = board.create(&#x27;point&#x27;, [0, 3]);
     *        var p2 = board.create(&#x27;point&#x27;, [1, 3]);
     *         var l1 = board.create(&#x27;line&#x27;, [p1, p2]);
     *      var t = board.create(&#x27;hatch&#x27;, [l1, 3]);
     * &lt;div id=&quot;4a20af06-4395-451c-b7d1-002757cf01be&quot; style=&quot;width: 300px; height: 300px;&quot;&gt;&lt;/div&gt;
     * &lt;script type=&quot;text/javascript&quot;&gt;
     * (function () {
     *   var board = JXG.JSXGraph.initBoard(&#x27;4a20af06-4395-451c-b7d1-002757cf01be&#x27;, {boundingbox: [-1, 7, 7, -1], showcopyright: false, shownavigation: false});
     *   var p1 = board.create(&#x27;point&#x27;, [0, 3]);
     *   var p2 = board.create(&#x27;point&#x27;, [1, 3]);
     *   var l1 = board.create(&#x27;line&#x27;, [p1, p2]);
     *   var t = board.create(&#x27;hatch&#x27;, [l1, 3]);
     * })();
     * &lt;/script&gt;
     */
    JXG.createHatchmark = function (board, parents, attributes) {
        var num, i, base, width, totalwidth, el,
            pos = [],
            attr = Type.copyAttributes(attributes, board.options, &#x27;hatch&#x27;);

        if (parents[0].elementClass !== Const.OBJECT_CLASS_LINE || typeof parents[1] !== &#x27;number&#x27;) {
            throw new Error(&quot;JSXGraph: Can&#x27;t create Hatch mark with parent types &#x27;&quot; + (typeof parents[0]) + &quot;&#x27; and &#x27;&quot; + (typeof parents[1]) + &quot;&#x27;.&quot;);
        }

        num = parents[1];
        width = attr.ticksdistance;
        totalwidth = (num - 1) * width;
        base = -totalwidth / 2;

        for (i = 0; i &lt; num; i++) {
            pos[i] = base + i * width;
        }

        el = board.create(&#x27;ticks&#x27;, [parents[0], pos], attr);
        el.elType = &#x27;hatch&#x27;;

        return el;
    };

    JXG.registerElement(&#x27;ticks&#x27;, JXG.createTicks);
    JXG.registerElement(&#x27;hash&#x27;, JXG.createHatchmark);
    JXG.registerElement(&#x27;hatch&#x27;, JXG.createHatchmark);

    return {
        Ticks: JXG.Ticks,
        createTicks: JXG.createTicks,
        createHashmark: JXG.createHatchmark,
        createHatchmark: JXG.createHatchmark
    };
});

    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>

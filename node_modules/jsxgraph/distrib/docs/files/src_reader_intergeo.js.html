<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src/reader/intergeo.js - JSXGraph</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="../assets/js/jsxgraphcore.js"></script>
    <link rel="stylesheet" href="../assets/css/jsxgraph.css">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../assets/css/logo_blue.png" title="JSXGraph" width="117" height="52"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.99.4</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/Angle.html">Angle</a> </li>
                                <li><a href="../classes/Arc.html">Arc</a> </li>
                                <li><a href="../classes/Arrow.html">Arrow</a> </li>
                                <li><a href="../classes/Arrowparallel.html">Arrowparallel</a> </li>
                                <li><a href="../classes/Axis.html">Axis</a> </li>
                                <li><a href="../classes/Bisector.html">Bisector</a> </li>
                                <li><a href="../classes/Bisectorlines.html">Bisectorlines</a> </li>
                                <li><a href="../classes/Button.html">Button</a> </li>
                                <li><a href="../classes/Checkbox.html">Checkbox</a> </li>
                                <li><a href="../classes/Circle.html">Circle</a> </li>
                                <li><a href="../classes/Circumcenter.html">Circumcenter</a> </li>
                                <li><a href="../classes/Circumcircle.html">Circumcircle</a> </li>
                                <li><a href="../classes/CircumcircleArc.html">CircumcircleArc</a> </li>
                                <li><a href="../classes/CircumcircleSector.html">CircumcircleSector</a> </li>
                                <li><a href="../classes/Conic.html">Conic</a> </li>
                                <li><a href="../classes/Curve.html">Curve</a> </li>
                                <li><a href="../classes/Ellipse.html">Ellipse</a> </li>
                                <li><a href="../classes/EventEmitter.html">EventEmitter</a> </li>
                                <li><a href="../classes/Functiongraph.html">Functiongraph</a> </li>
                                <li><a href="../classes/Glider.html">Glider</a> </li>
                                <li><a href="../classes/Grid.html">Grid</a> </li>
                                <li><a href="../classes/Group.html">Group</a> </li>
                                <li><a href="../classes/Hatch.html">Hatch</a> </li>
                                <li><a href="../classes/Hyperbola.html">Hyperbola</a> </li>
                                <li><a href="../classes/Image.html">Image</a> </li>
                                <li><a href="../classes/Incenter.html">Incenter</a> </li>
                                <li><a href="../classes/Incircle.html">Incircle</a> </li>
                                <li><a href="../classes/Inequality.html">Inequality</a> </li>
                                <li><a href="../classes/Input.html">Input</a> </li>
                                <li><a href="../classes/Integral.html">Integral</a> </li>
                                <li><a href="../classes/Intersection.html">Intersection</a> </li>
                                <li><a href="../classes/JXG.html">JXG</a> </li>
                                <li><a href="../classes/JXG.AbstractRenderer.html">JXG.AbstractRenderer</a> </li>
                                <li><a href="../classes/JXG.Board.html">JXG.Board</a> </li>
                                <li><a href="../classes/JXG.C.html">JXG.C</a> </li>
                                <li><a href="../classes/JXG.CanvasRenderer.html">JXG.CanvasRenderer</a> </li>
                                <li><a href="../classes/JXG.Chart.html">JXG.Chart</a> </li>
                                <li><a href="../classes/JXG.Circle.html">JXG.Circle</a> </li>
                                <li><a href="../classes/JXG.Complex.html">JXG.Complex</a> </li>
                                <li><a href="../classes/JXG.Composition.html">JXG.Composition</a> </li>
                                <li><a href="../classes/JXG.Coords.html">JXG.Coords</a> </li>
                                <li><a href="../classes/JXG.CoordsElement.html">JXG.CoordsElement</a> </li>
                                <li><a href="../classes/JXG.Curve.html">JXG.Curve</a> </li>
                                <li><a href="../classes/JXG.GeometryElement.html">JXG.GeometryElement</a> </li>
                                <li><a href="../classes/JXG.Group.html">JXG.Group</a> </li>
                                <li><a href="../classes/JXG.Image.html">JXG.Image</a> </li>
                                <li><a href="../classes/JXG.JSXGraph.html">JXG.JSXGraph</a> </li>
                                <li><a href="../classes/JXG.Line.html">JXG.Line</a> </li>
                                <li><a href="../classes/JXG.Math.html">JXG.Math</a> </li>
                                <li><a href="../classes/JXG.Math.Geometry.html">JXG.Math.Geometry</a> </li>
                                <li><a href="../classes/JXG.Math.Numerics.html">JXG.Math.Numerics</a> </li>
                                <li><a href="../classes/JXG.Math.Poly.html">JXG.Math.Poly</a> </li>
                                <li><a href="../classes/JXG.Math.Poly.Monomial.html">JXG.Math.Poly.Monomial</a> </li>
                                <li><a href="../classes/JXG.Math.Poly.Polynomial.html">JXG.Math.Poly.Polynomial</a> </li>
                                <li><a href="../classes/JXG.Math.Poly.Ring.html">JXG.Math.Poly.Ring</a> </li>
                                <li><a href="../classes/JXG.Math.Quadtree.html">JXG.Math.Quadtree</a> </li>
                                <li><a href="../classes/JXG.Math.Statistics.html">JXG.Math.Statistics</a> </li>
                                <li><a href="../classes/JXG.Math.Symbolic.html">JXG.Math.Symbolic</a> </li>
                                <li><a href="../classes/JXG.NoRenderer.html">JXG.NoRenderer</a> </li>
                                <li><a href="../classes/JXG.Options.html">JXG.Options</a> </li>
                                <li><a href="../classes/JXG.Point.html">JXG.Point</a> </li>
                                <li><a href="../classes/JXG.Polygon.html">JXG.Polygon</a> </li>
                                <li><a href="../classes/JXG.SVGRenderer.html">JXG.SVGRenderer</a> </li>
                                <li><a href="../classes/JXG.Text.html">JXG.Text</a> </li>
                                <li><a href="../classes/JXG.Ticks.html">JXG.Ticks</a> </li>
                                <li><a href="../classes/JXG.Transformation.html">JXG.Transformation</a> </li>
                                <li><a href="../classes/JXG.Turtle.html">JXG.Turtle</a> </li>
                                <li><a href="../classes/JXG.Util.Base64.html">JXG.Util.Base64</a> </li>
                                <li><a href="../classes/JXG.Util.Unzip.html">JXG.Util.Unzip</a> </li>
                                <li><a href="../classes/JXG.VMLRenderer.html">JXG.VMLRenderer</a> </li>
                                <li><a href="../classes/Line.html">Line</a> </li>
                                <li><a href="../classes/Locus.html">Locus</a> </li>
                                <li><a href="../classes/MajorArc.html">MajorArc</a> </li>
                                <li><a href="../classes/Midpoint.html">Midpoint</a> </li>
                                <li><a href="../classes/MinorArc.html">MinorArc</a> </li>
                                <li><a href="../classes/MinorSector.html">MinorSector</a> </li>
                                <li><a href="../classes/Mirrorpoint.html">Mirrorpoint</a> </li>
                                <li><a href="../classes/NonReflexAngle.html">NonReflexAngle</a> </li>
                                <li><a href="../classes/Normal.html">Normal</a> </li>
                                <li><a href="../classes/Orthogonalprojection.html">Orthogonalprojection</a> </li>
                                <li><a href="../classes/OtherIntersection.html">OtherIntersection</a> </li>
                                <li><a href="../classes/Parabola.html">Parabola</a> </li>
                                <li><a href="../classes/Parallel.html">Parallel</a> </li>
                                <li><a href="../classes/Parallelpoint.html">Parallelpoint</a> </li>
                                <li><a href="../classes/Perpendicular.html">Perpendicular</a> </li>
                                <li><a href="../classes/PerpendicularPoint.html">PerpendicularPoint</a> </li>
                                <li><a href="../classes/PerpendicularSegment.html">PerpendicularSegment</a> </li>
                                <li><a href="../classes/Point.html">Point</a> </li>
                                <li><a href="../classes/PolarLine.html">PolarLine</a> </li>
                                <li><a href="../classes/PolePoint.html">PolePoint</a> </li>
                                <li><a href="../classes/Polygon.html">Polygon</a> </li>
                                <li><a href="../classes/RadicalAxis.html">RadicalAxis</a> </li>
                                <li><a href="../classes/Reflection.html">Reflection</a> </li>
                                <li><a href="../classes/ReflexAngle.html">ReflexAngle</a> </li>
                                <li><a href="../classes/registerReader.html">registerReader</a> </li>
                                <li><a href="../classes/RegularPolygon.html">RegularPolygon</a> </li>
                                <li><a href="../classes/Riemannsum.html">Riemannsum</a> </li>
                                <li><a href="../classes/Sector.html">Sector</a> </li>
                                <li><a href="../classes/Segment.html">Segment</a> </li>
                                <li><a href="../classes/Semicircle.html">Semicircle</a> </li>
                                <li><a href="../classes/Slider.html">Slider</a> </li>
                                <li><a href="../classes/Slopetriangle.html">Slopetriangle</a> </li>
                                <li><a href="../classes/Spline.html">Spline</a> </li>
                                <li><a href="../classes/Stepfunction.html">Stepfunction</a> </li>
                                <li><a href="../classes/Tangent.html">Tangent</a> </li>
                                <li><a href="../classes/Tapemeasure.html">Tapemeasure</a> </li>
                                <li><a href="../classes/Text.html">Text</a> </li>
                                <li><a href="../classes/Ticks.html">Ticks</a> </li>
                                <li><a href="../classes/Tracecurve.html">Tracecurve</a> </li>
                                <li><a href="../classes/Transformation.html">Transformation</a> </li>
                                <li><a href="../classes/Turtle.html">Turtle</a> </li>
                            </ul>
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="../modules/JXG.html">JXG</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: src/reader/intergeo.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/*
    Copyright 2008-2013
        Matthias Ehmann,
        Michael Gerhaeuser,
        Carsten Miller,
        Bianca Valentin,
        Alfred Wassermann,
        Peter Wilfahrt

    This file is part of JSXGraph.

    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.
    
    You can redistribute it and/or modify it under the terms of the
    
      * GNU Lesser General Public License as published by
        the Free Software Foundation, either version 3 of the License, or
        (at your option) any later version
      OR
      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT
    
    JSXGraph is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.
    
    You should have received a copy of the GNU Lesser General Public License and
    the MIT License along with JSXGraph. If not, see &lt;http://www.gnu.org/licenses/&gt;
    and &lt;http://opensource.org/licenses/MIT/&gt;.
 */

/*global JXG: true*/
/*jslint nomen: true, plusplus: true*/

/* depends:
 jxg
 math/math
 utils/encoding
 utils/zip
 utils/type
 utils/base64
 utils/xml
  elements:
   point
   line
   conic
   parallel
   perpendicular
   intersection
   otherintersection
   glider
   bisector
   midpoint
   circumcircle
   tangent
   circle
   bisectorlines
   polygon
   arrow
 */

(function () {

    &quot;use strict&quot;;

    JXG.IntergeoReader = function (board, str) {
        var xmlStr;

        this.board = board;
        xmlStr = this.prepareString(str);
        this.tree = JXG.XML.parse(xmlStr);
    };

    JXG.extend(JXG.IntergeoReader.prototype, /** @lends JXG.IntergeoReader.prototype */ {
        /**
         * this.objects holds all objects from the XML file.
         * Every object gets an attribute &quot;exists&quot;
         */
        objects: {},

        read: function () {
            this.board.origin = {};
            this.board.origin.usrCoords = [1, 0, 0];
            this.board.origin.scrCoords = [1, 400, 300];
            this.board.unitX = 30;
            this.board.unitY = 30;

            this.readElements(this.tree.getElementsByTagName(&quot;elements&quot;));
            this.readConstraints(this.tree.getElementsByTagName(&quot;constraints&quot;));
            this.cleanUp();
            this.board.fullUpdate();
            this.readDisplay(this.tree.getElementsByTagName(&quot;display&quot;));
            this.board.fullUpdate();
        },

        readElement: function (tree, s) {
            var node;

            node = tree[0].childNodes[s];

            if (node.nodeType &gt; 1) {
                // not an element node
                return;
            }

            if (node.nodeName === &#x27;point&#x27;) {
                this.storePoint(node);
            } else if (node.nodeName === &#x27;line&#x27; || node.nodeName === &#x27;line_segment&#x27; ||
                    node.nodeName === &#x27;ray&#x27; || node.nodeName === &#x27;vector&#x27;) {
                this.storeLine(node);
            } else if (node.nodeName === &#x27;circle&#x27;) {
                this.storeConic(node);
            } else if (node.nodeName === &#x27;conic&#x27;) {
                this.storeConic(node);
                //} else if (node.nodeName === &#x27;polygon&#x27;) {
                // ignore, see this.addPolygonByVertices
            } else {
                JXG.debug(&#x27;Not implemented: &#x27; + node.nodeName + &#x27; &#x27; + node.getAttribute(&#x27;id&#x27;));
            }
        },

        /**
         * Element part
         */
        readElements: function (tree) {
            var s;

            for (s = 0; s &lt; tree[0].childNodes.length; s++) {
                this.readElement(tree, s);
            }
        },

        /**
         * Points are created instantly via create
         */
        storePoint: function (node) {
            var i = 0,
                j = 0,
                l = 0,
                p = node.childNodes[i],
                c = [],
                parents = [];

            // skip non element nodes
            while (p.nodeType &gt; 1) {
                i += 1;
                p = node.childNodes[i];
            }

            if (p.nodeName === &#x27;homogeneous_coordinates&#x27;) {
                for (j = 0; j &lt; p.childNodes.length; j++) {
                    if (p.childNodes[j].nodeType === 1) {
                        if (p.childNodes[j].nodeName === &#x27;double&#x27;) {
                            // content of &lt;double&gt;...&lt;/double&gt;
                            c.push(p.childNodes[j].firstChild.data);
                        } else if (p.childNodes[j].nodeName === &#x27;complex&#x27;) {
                            for (l = 0; l &lt; p.childNodes[j].childNodes.length; l++) {
                                if (p.childNodes[j].childNodes[l].nodeName === &#x27;double&#x27;) {
                                    c.push(p.childNodes[j].childNodes[l].firstChild.data);
                                }
                            }
                        } else {
                            // &lt;complex&gt;
                            JXG.debug(&#x27;Not implemented: &#x27; + p.childNodes[j].nodeName);
                            return;
                        }
                    }
                }
                for (j = 0; j &lt; c.length; j++) {
                    c[j] = parseFloat(c[j]);
                }

                // Real
                if (c.length === 3) {
                    parents = [c[2], c[0], c[1]];
                // complex, but real
                } else if (c.length === 6 &amp;&amp; Math.abs(c[1]) &lt; 1e-10 &amp;&amp; Math.abs(c[3]) &lt; 1e-10 &amp;&amp; Math.abs(c[5]) &lt; 1e-10) {
                    parents = [c[4], c[0], c[2]];
                } else {
                    // &lt;complex&gt;
                    JXG.debug(&#x27;type not supported, yet&#x27;);
                    return;
                }
            // the latter one is a workaround for faulty i2g construction exported by DynaGeo
            } else if (p.nodeName === &#x27;euclidean_coordinates&#x27; || p.nodeName === &#x27;euclidian_coordinates&#x27;) {
                for (j = 0; j &lt; p.childNodes.length; j++) {
                    if (p.childNodes[j].nodeType === 1) {
                        // content of &lt;double&gt;...&lt;/double&gt;
                        c.push(p.childNodes[j].firstChild.data);
                    }
                }
                for (j = 0; j &lt; c.length; j++) {
                    c[j] = parseFloat(c[j]);
                }
                parents = [c[0], c[1]];
            } else if (p.nodeName === &#x27;polar_coordinates&#x27;) {
                for (j = 0; j &lt; p.childNodes.length; j++) {
                    if (p.childNodes[j].nodeType === 1) {
                        // content of &lt;double&gt;...&lt;/double&gt;
                        c.push(p.childNodes[j].firstChild.data);
                    }
                }
                for (j = 0; j &lt; c.length; j++) {
                    c[j] = parseFloat(c[j]);
                }
                parents = [c[0] * Math.cos(c[1]), c[0] * Math.sin(c[1])];
            } else {
                JXG.debug(&#x27;This coordinate type is not yet implemented: &#x27; + p.nodeName);
                return;
            }

            this.objects[node.getAttribute(&#x27;id&#x27;)] = {&#x27;id&#x27;: node.getAttribute(&#x27;id&#x27;), &#x27;coords&#x27;: null};
            this.objects[node.getAttribute(&#x27;id&#x27;)].coords = parents;
            this.objects[node.getAttribute(&#x27;id&#x27;)].id = node.getAttribute(&#x27;id&#x27;);
            this.objects[node.getAttribute(&#x27;id&#x27;)].exists = false;
            this.objects[node.getAttribute(&#x27;id&#x27;)].i2geoType = &#x27;point&#x27;;
        },

        /**
         * Line data is stored in an array
         * for further access during the reading of constraints.
         * There, id and name are needed.
         */
        storeLine: function (node) {
            var i, p, c, j;

            this.objects[node.getAttribute(&#x27;id&#x27;)] = {&#x27;id&#x27;: node.getAttribute(&#x27;id&#x27;), &#x27;coords&#x27;: null};
            i = 0;
            p = node.childNodes[i];

            // skip non element nodes
            while (p.nodeType &gt; 1) {
                i += 1;
                p = node.childNodes[i];
            }

            if (p.nodeName === &#x27;homogeneous_coordinates&#x27;) {
                c = [];
                for (j = 0; j &lt; p.childNodes.length; j++) {
                    if (p.childNodes[j].nodeType === 1) {
                        if (p.childNodes[j].nodeName === &#x27;double&#x27;) {
                            // content of &lt;double&gt;...&lt;/double&gt;
                            c.push(parseFloat(p.childNodes[j].firstChild.data));
                        }
                        // else {
                        //    $(&#x27;debug&#x27;).innerHTML += &#x27;Not: &#x27;+ p.childNodes[j].nodeName + &#x27;&lt;br&gt;&#x27;;  // &lt;complex&gt;
                        //}
                    }
                }
                this.objects[node.getAttribute(&#x27;id&#x27;)].coords = c;
                this.objects[node.getAttribute(&#x27;id&#x27;)].id = node.getAttribute(&#x27;id&#x27;);
                this.objects[node.getAttribute(&#x27;id&#x27;)].exists = false;
                this.objects[node.getAttribute(&#x27;id&#x27;)].i2geoType = &#x27;line&#x27;;
            }
        },

        /**
         * Circle / conic data is stored in an array
         * for further access during the reading of constraints.
         * There, id and name are needed.
         * Concretely, the circle   (x-1)^2 + (y-3)^2 = 4   has matrix
         * (  1  0 -1 )
         * (  0  1 -3 )
         * ( -1 -3  6 )
         *
         * In general
         * Ax^2+Bxy+Cy^2+Dx+Ey+F = 0
         * is stored as
         * (  A   B/2  D/2 )
         * (  B/2  C   E/2 )
         * (  D/2 E/2  F )
         *
         *  Mx = D/A
         *  My = E/C
         *  r = A*Mx^2+B*My^2-F
         */
        storeConic: function (node) {
            var i, j, p, c;

            this.objects[node.getAttribute(&#x27;id&#x27;)] = {&#x27;id&#x27;: node.getAttribute(&#x27;id&#x27;), &#x27;coords&#x27;: null};
            i = 0;
            p = node.childNodes[i];

            // skip non element nodes
            while (p.nodeType &gt; 1) {
                i += 1;
                p = node.childNodes[i];
            }

            if (p.nodeName === &#x27;matrix&#x27;) {
                c = [];

                for (j = 0; j &lt; p.childNodes.length; j++) {
                    if (p.childNodes[j].nodeType === 1) {
                        if (p.childNodes[j].nodeName === &#x27;double&#x27;) {
                            // content of &lt;double&gt;...&lt;/double&gt;
                            c.push(parseFloat(p.childNodes[j].firstChild.data));
                        }
                        //else {
                        //    $(&#x27;debug&#x27;).innerHTML += &#x27;Not: &#x27;+ p.childNodes[j].nodeName + &#x27;&lt;br&gt;&#x27;;  // &lt;complex&gt;
                        //}
                    }
                }
                this.objects[node.getAttribute(&#x27;id&#x27;)].coords = c;
                this.objects[node.getAttribute(&#x27;id&#x27;)].id = node.getAttribute(&#x27;id&#x27;);
                this.objects[node.getAttribute(&#x27;id&#x27;)].exists = false;
                this.objects[node.getAttribute(&#x27;id&#x27;)].i2geoType = &#x27;conic&#x27;;
            }
        },

        /**
         * Constraint part
         */
        readConstraint: function (tree, s) {
            var param, node;

            node = tree[0].childNodes[s];

            // not an element node
            if (node.nodeType &gt; 1) {
                return;
            }

            if (node.nodeName === &#x27;line_through_two_points&#x27;) {
                this.addLineThroughTwoPoints(node, false);
            } else if (node.nodeName === &#x27;ray_from_point_through_point&#x27;) {
                this.addLineThroughTwoPoints(node, true);
            } else if (node.nodeName === &#x27;line_through_point&#x27;) {
                this.addLineThroughPoint(node);
            } else if (node.nodeName === &#x27;line_parallel_to_line_through_point&#x27;) {
                this.addLineParallelToLineThroughPoint(node, false);
            } else if (node.nodeName === &#x27;ray_from_point_and_vector&#x27;) {
                this.addLineParallelToLineThroughPoint(node, true);
            } else if (node.nodeName === &#x27;line_perpendicular_to_line_through_point&#x27;) {
                this.addLinePerpendicularToLineThroughPoint(node);
            } else if (node.nodeName === &#x27;line_segment_by_points&#x27;) {
                this.addLineSegmentByTwoPoints(node);
            } else if (node.nodeName === &#x27;vector_from_point_to_point&#x27;) {
                this.addVectorFromPointToPoint(node);
            } else if (node.nodeName === &#x27;endpoints_of_line_segment&#x27;) {
                this.addEndpointsOfLineSegment(node);
            } else if (node.nodeName === &#x27;free_line&#x27;) {
                this.addFreeLine(node);
            } else if (node.nodeName === &#x27;point_on_line&#x27;) {
                this.addPointOnLine(node);
            } else if (node.nodeName === &#x27;point_on_line_segment&#x27;) {
                this.addPointOnLine(node);
            } else if (node.nodeName === &#x27;point_on_circle&#x27;) {
                this.addPointOnCircle(node);
            } else if (node.nodeName === &#x27;angular_bisector_of_three_points&#x27;) {
                this.addAngularBisectorOfThreePoints(node, false);
            } else if (node.nodeName === &#x27;angular_bisectors_of_two_lines&#x27;) {
                this.addAngularBisectorsOfTwoLines(node);
            } else if (node.nodeName === &#x27;line_angular_bisector_of_three_points&#x27;) {
                this.addAngularBisectorOfThreePoints(node, true);
            } else if (node.nodeName === &#x27;line_angular_bisectors_of_two_lines&#x27;) {
                this.addAngularBisectorsOfTwoLines(node);
            } else if (node.nodeName === &#x27;midpoint_of_two_points&#x27;) {
                this.addMidpointOfTwoPoints(node);
            } else if (node.nodeName === &#x27;midpoint&#x27;) {
                this.addMidpointOfTwoPoints(node);
            } else if (node.nodeName === &#x27;midpoint_of_line_segment&#x27; || node.nodeName === &#x27;midpoint_line_segment&#x27;) {
                this.addMidpointOfLineSegment(node);
            } else if (node.nodeName === &#x27;point_intersection_of_two_lines&#x27;) {
                this.addPointIntersectionOfTwoLines(node);
            } else if (node.nodeName === &#x27;locus_defined_by_point&#x27;) {
                this.addLocusDefinedByPoint(node);
            } else if (node.nodeName === &#x27;locus_defined_by_point_on_line&#x27;) {
                this.addLocusDefinedByPointOnLine(node);
            } else if (node.nodeName === &#x27;locus_defined_by_point_on_line_segment&#x27;) {
                this.addLocusDefinedByPointOnLine(node);
            } else if (node.nodeName === &#x27;locus_defined_by_line_through_point&#x27;) {
                this.addLocusDefinedByLineThroughPoint(node);
            } else if (node.nodeName === &#x27;locus_defined_by_point_on_circle&#x27;) {
                this.addLocusDefinedByPointOnCircle(node);
            } else if (node.nodeName === &#x27;circle_by_three_points&#x27;) {
                this.addCircleByThreePoints(node);
            } else if (node.nodeName === &#x27;circle_by_center_and_point&#x27;) {
                this.addCircleByCenterAndPoint(node);
            } else if (node.nodeName === &#x27;center_of_circle&#x27;) {
                this.addCenterOfCircle(node);
            } else if (node.nodeName === &#x27;intersection_points_of_two_circles&#x27;) {
                this.addIntersectionPointsOfTwoCircles(node);
            } else if (node.nodeName === &#x27;intersection_points_of_circle_and_line&#x27;) {
                this.addIntersectionPointsOfCircleAndLine(node);
            } else if (node.nodeName === &#x27;other_intersection_point_of_two_circles&#x27;) {
                this.addOtherIntersectionPointOfTwoCircles(node);
            } else if (node.nodeName === &#x27;other_intersection_point_of_circle_and_line&#x27;) {
                this.addOtherIntersectionPointOfCircleAndLine(node);
            } else if (node.nodeName === &#x27;circle_tangent_lines_by_point&#x27;) {
                this.addCircleTangentLinesByPoint(node);
            } else if (node.nodeName === &#x27;polygon_by_vertices&#x27;) {
                this.addPolygonByVertices(node);
            //} else if (node.nodeName === &#x27;free_point&#x27;) {
            // do nothing
            } else {
                param = this.readParams(node);
                JXG.debug(&#x27;readConstraints: not implemented: &#x27; + node.nodeName + &#x27;: &#x27; + param[0]);
            }
        },

        readConstraints: function (tree) {
            var s;

            // Set the default colors of dependent elements
            this.board.options.point.strokeColor = &#x27;blue&#x27;;
            this.board.options.point.fillColor = &#x27;blue&#x27;;

            for (s = 0; s &lt; tree[0].childNodes.length; s++) {
                this.readConstraint(tree, s);
            }
        },

        setAttributes: function (o) {
            o.setAttribute({strokecolor: this.board.options.point.strokeColor, fillColor: this.board.options.point.fillColor});
        },

        readParams: function (node) {
            var j,
                param = [];

            for (j = 0; j &lt; node.childNodes.length; j++) {
                if (node.childNodes[j].nodeType === 1) {
                    param.push(node.childNodes[j].firstChild.data);
                }
            }

            return param;
        },

        addPoint: function (p) {
            if (!p.exists) {
                p.exists = true;
                p = this.board.create(&#x27;point&#x27;, p.coords, {name: p.id});
                p.setAttribute({strokecolor: &#x27;red&#x27;, fillColor: &#x27;red&#x27;});
            }

            return p;
        },

        /**
         * Direct construction of a line
         * in read elements
         */
        addLine: function (id) {
            var j,
                c = this.objects[id].coords,
                el;

            for (j = 0; j &lt; c.length; j++) {
                c[j] = parseFloat(c[j]);
            }
            el = this.board.create(&#x27;line&#x27;, [c[2], c[0], c[1]], {name: id, strokeColor: &#x27;black&#x27;, withLabel: true});
            this.objects[id] = el;
        },

        addConic: function (p) {
            var c;

            if (!p.exists) {
                c = p.coords;
                // (a_00,a_11,a_22,a_01,a_12,a_22)
                p = this.board.create(&#x27;conic&#x27;, [c[0], c[4], c[8], c[1], c[5], c[2]], {name: p.id});
                p.exists = true;
            }

            return p;
        },

        cleanUp: function () {
            var p;

            for (p in this.objects) {
                if (this.objects.hasOwnProperty(p)) {
                    if (this.objects[p].exists === false) {
                        if (this.objects[p].i2geoType === &#x27;point&#x27;) {
                            this.addPoint(this.objects[p]);
                        } else if (this.objects[p].i2geoType === &#x27;line&#x27;) {
                            this.addLine(this.objects[p]);
                        } else if (this.objects[p].i2geoType === &#x27;conic&#x27;) {
                            this.addConic(this.objects[p]);
                        } else {
                            JXG.debug(&#x27;forgotten: &#x27; + this.objects[p].id + &#x27; of type &#x27; + this.objects[p].i2geoType);
                        }
                    }
                }
            }
        },

        addLineThroughTwoPoints: function (node, isRay) {
            var el1, el2, el,
                param = this.readParams(node);

            el1 = this.addPoint(this.objects[param[1]]);
            el2 = this.addPoint(this.objects[param[2]]);
            el = this.board.create(&#x27;line&#x27;, [el1.id, el2.id], {
                name: param[0],
                withLabel: true,
                straightFirst: !isRay,
                straightLast: true
            });
            this.objects[param[0]] = el;
            this.objects[param[0]].exists = true;
        },

        addLineThroughPoint: function (node) {
            var param = this.readParams(node),
                j,
                c = this.objects[param[0]].coords,
                p = this.addPoint(this.objects[param[1]]),
                el;

            for (j = 0; j &lt; c.length; j++) {
                c[j] = parseFloat(c[j]);
            }

            el = this.board.create(&#x27;line&#x27;, [
                function () {
                    return c[2] - c[0] * p.X() - c[1] * p.Y() - c[2] * p.Z();
                },
                c[0],
                c[1]
            ], {name: param[0], strokeColor: &#x27;black&#x27;, withLabel: true});

            this.objects[param[0]] = el;
            this.objects[param[0]].exists = true;
        },

        addLineParallelToLineThroughPoint: function (node, isRay) {
            var el1, el2, el,
                param = this.readParams(node);

            el1 = this.addPoint(this.objects[param[1]]);
            el2 = this.addPoint(this.objects[param[2]]);
            el = this.board.create(&#x27;parallel&#x27;, [el1.id, el2.id], {
                name: param[0],
                withLabel: true,
                straightFirst: !isRay,
                straightLast: true
            });

            this.objects[param[0]] = el;
            this.objects[param[0]].exists = true;
        },

        addLinePerpendicularToLineThroughPoint: function (node) {
            var el1, el2, el,
                param = this.readParams(node);

            el1 = this.addPoint(this.objects[param[1]]);
            el2 = this.addPoint(this.objects[param[2]]);
            el = this.board.create(&#x27;perpendicular&#x27;, [el1.id, el2.id], {
                name: param[0],
                id: param[0],
                straightFirst: true,
                straightLast: true,
                point: {
                    name: param[0] + &#x27;foot&#x27;,
                    id: param[0] + &#x27;foot&#x27;
                },
                withLabel: true
            });
            this.objects[param[0]] = el;
            this.objects[param[0]].exists = true;
        },

        addLineSegmentByTwoPoints: function (node) {
            var el1, el2, el,
                param = this.readParams(node);

            el1 = this.addPoint(this.objects[param[1]]);
            el2 = this.addPoint(this.objects[param[2]]);
            el = this.board.create(&#x27;line&#x27;, [el1.id, el2.id], {
                name: param[0],
                straightFirst: false,
                straightLast: false,
                strokeColor: &#x27;black&#x27;,
                withLabel: true
            });
            this.objects[param[0]] = el;
            this.objects[param[0]].exists = true;
        },

        addPointIntersectionOfTwoLines: function (node) {
            var param = this.readParams(node),
                l1 = this.objects[param[1]],
                l2 = this.objects[param[2]];

            this.objects[param[0]] = this.board.create(&#x27;intersection&#x27;, [l1, l2, 0], {
                name: param[0],
                id: param[0],
                withLabel: true
            });
            this.setAttributes(this.objects[param[0]]);
            this.objects[param[0]].exists = true;
        },

        addFreeLine: function (node) {
            var param = this.readParams(node),
                a = this.objects[param[0]].coords[0],
                b = this.objects[param[0]].coords[1],
                c = this.objects[param[0]].coords[2];

            this.objects[param[0]] = this.board.create(&#x27;line&#x27;, [c, a, b], {
                name: param[0],
                id: param[0],
                withLabel: true
            });
            this.objects[param[0]].exists = true;
        },

        addPointOnLine: function (node) {
            var param = this.readParams(node),
                l = this.board.select(param[1]);

            this.board.create(&#x27;glider&#x27;, [0, 0, l], {name: param[0], id: param[0], withLabel: true});
            this.objects[param[0]].exists = true;
        },

        addPointOnCircle: function (node) {
            var param = this.readParams(node),
                c = this.board.select(param[1]);

            c.update();
            this.board.create(&#x27;glider&#x27;, [this.objects[param[0]].coords[1], this.objects[param[0]].coords[2], c], {
                name: param[0],
                id: param[0],
                withLabel: true
            });

            this.objects[param[0]].exists = true;
        },

        addEndpointsOfLineSegment: function (node) {
            var param = this.readParams(node),
                line = this.objects[param[2]],
                p = this.addPoint(this.objects[param[0]]),
                q = this.addPoint(this.objects[param[1]]);

            p.addConstraint([
                function () {
                    return line.point1.Z();
                },
                function () {
                    return line.point1.X();
                },
                function () {
                    return line.point1.Y();
                }
            ]);

            q.addConstraint([
                function () {
                    return line.point2.Z();
                },
                function () {
                    return line.point2.X();
                },
                function () {
                    return line.point2.Y();
                }
            ]);

            this.setAttributes(p);
            this.setAttributes(q);
        },

        addAngularBisectorOfThreePoints: function (node, isLine) {
            var el1, el2, el3, el,
                param = this.readParams(node);

            el1 = this.addPoint(this.objects[param[1]]);
            el2 = this.addPoint(this.objects[param[2]]);
            el3 = this.addPoint(this.objects[param[3]]);

            el = this.board.create(&#x27;bisector&#x27;, [el1.id, el2.id, el3.id], {
                name: param[0],
                id: param[0],
                withLabel: true,
                straightFirst: isLine,
                straightLast: true,
                strokeColor: &#x27;#000000&#x27;
            });

            this.objects[param[0]] = el;
            this.objects[param[0]].exists = true;
        },

        addMidpointOfTwoPoints: function (node) {
            var el1, el2, el,
                param = this.readParams(node);

            el1 = this.addPoint(this.objects[param[1]]);
            el2 = this.addPoint(this.objects[param[2]]);

            el = this.board.create(&#x27;midpoint&#x27;, [el1.id, el2.id], { name: param[0]});

            this.setAttributes(el);
            this.objects[param[0]].exists = true;
        },

        addMidpointOfLineSegment: function (node) {
            var param = this.readParams(node),
                l = this.board.select(param[1]),
                el = this.board.create(&#x27;midpoint&#x27;, [l.point1, l.point2], {name: param[0]});

            this.setAttributes(el);
            this.objects[param[0]].exists = true;
        },

        addCircleByThreePoints: function (node) {
            var i,
                param = this.readParams(node),
                p = [];

            for (i = 0; i &lt; 3; i++) {
                p[i] = this.addPoint(this.objects[param[i + 1]]);
            }

            this.board.create(&#x27;circumcircle&#x27;, p, {
                name: param[0],
                id: param[0],
                point: {
                    name: param[0] + &#x27;c&#x27;,
                    id: param[0] + &#x27;c&#x27;
                },
                withLabel: true
            });
            this.objects[param[0]].exists = true;
        },

        addCenterOfCircle: function (node) {
            var param = this.readParams(node),
                c = this.board.select(param[1]),

                el = this.board.create(&#x27;point&#x27;, [
                    function () {
                        return c.center.X();
                    },
                    function () {
                        return c.center.Y();
                    }
                ], {name: param[0], id: param[0], withLabel: true});

            this.setAttributes(el);
            this.objects[param[0]].exists = true;
        },

        addCircleTangentLinesByPoint: function (node) {
            var polar, i1, i2, t1, t2,
                param = this.readParams(node),
                c = this.board.select(param[2]),
                p = this.addPoint(this.objects[param[3]]);

            polar = this.board.create(&#x27;line&#x27;, [
                function () {
                    return JXG.Math.matVecMult(c.quadraticform, p.coords.usrCoords)[0];
                },
                function () {
                    return JXG.Math.matVecMult(c.quadraticform, p.coords.usrCoords)[1];
                },
                function () {
                    return JXG.Math.matVecMult(c.quadraticform, p.coords.usrCoords)[2];
                }
            ], {visible: false});

            i1 = this.board.create(&#x27;intersection&#x27;, [c, polar, 0], {visible: false});
            i2 = this.board.create(&#x27;intersection&#x27;, [c, polar, 1], {visible: false});
            t1 = this.board.create(&#x27;tangent&#x27;, [i1, c]);
            t2 = this.board.create(&#x27;tangent&#x27;, [i2, c]);

            this.objects[param[0]] = t1;
            this.objects[param[1]] = t2;
            this.objects[param[0]].exists = true;
            this.objects[param[1]].exists = true;
        },

        addIntersectionPointsOfTwoCircles: function (node) {
            var p1, p2,
                param = this.readParams(node),
                c1 = this.board.select(param[2]),
                c2 = this.board.select(param[3]);

            p1 = this.board.create(&#x27;intersection&#x27;, [c1, c2, 0], {name: param[0], id: param[0], withLabel: true});
            p2 = this.board.create(&#x27;intersection&#x27;, [c1, c2, 1], {name: param[1], id: param[1], withLabel: true});
            this.setAttributes(p1);
            this.setAttributes(p2);
            this.objects[param[0]].exists = true;
            this.objects[param[1]].exists = true;
        },

        addIntersectionPointsOfCircleAndLine: function (node) {
            var p1, p2,
                param = this.readParams(node),
                c1 = this.board.select(param[2]),
                c2 = this.board.select(param[3]);

            p1 = this.board.create(&#x27;intersection&#x27;, [c1, c2, 0], {name: param[0], id: param[0], withLabel: true});
            p2 = this.board.create(&#x27;intersection&#x27;, [c1, c2, 1], {name: param[1], id: param[1], withLabel: true});
            this.setAttributes(p1);
            this.setAttributes(p2);
            this.objects[param[0]].exists = true;
            this.objects[param[1]].exists = true;
        },

        addCircleByCenterAndPoint: function (node) {
            var param = this.readParams(node),
                el1 = this.addPoint(this.objects[param[1]]),
                el2 = this.addPoint(this.objects[param[2]]);

            this.board.create(&#x27;circle&#x27;, [el1.id, el2.id], {
                name: param[0],
                id: param[0],
                withLabel: true
            });

            this.objects[param[0]].exists = true;
        },

        addOtherIntersectionPointOfTwoCircles: function (node) {
            var param = this.readParams(node),
                c1 = this.board.select(param[2]),
                c2 = this.board.select(param[3]),
                p1 = this.board.select(param[1]), // Should exist by now
                p2;

            p2 = this.board.create(&#x27;otherintersection&#x27;, [c1, c2, p1], {name: param[0], id: param[0], withLabel: true});
            this.setAttributes(p2);
            this.objects[param[0]].exists = true;
        },

        addOtherIntersectionPointOfCircleAndLine: function (node) {
            this.addOtherIntersectionPointOfTwoCircles(node);
        },

        /**
         * The angular bisectors of two line [c1,a1,b1] and [c2,a2,b2] are determined by the equation:
         * (a1*x+b1*y+c1*z)/sqrt(a1^2+b1^2) = +/- (a2*x+b2*y+c2*z)/sqrt(a2^2+b2^2)
         */
        addAngularBisectorsOfTwoLines: function (node) {
            var param = this.readParams(node),
                l1 = this.objects[param[2]],
                l2 = this.objects[param[3]];

            this.board.create(&#x27;bisectorlines&#x27;, [l1, l2], {
                line1: {
                    name: param[0],
                    id: param[0],
                    straightFirst: true,
                    straightLast: true
                },
                line2: {
                    name: param[1],
                    id: param[1],
                    straightFirst: true,
                    straightLast: true
                },
                withLabel: true
            });

            this.objects[param[0]].exists = true;
            this.objects[param[1]].exists = true;
        },

        addPolygonByVertices: function (node) {
            var j, n, param2 = [], p = [],
                param = this.readParams(node);

            for (j = 0; j &lt; node.childNodes.length; j++) {
                if (node.childNodes[j].nodeType === 1) {
                    if (node.childNodes[j].nodeName === &#x27;list_of_vertices&#x27;) {
                        n = node.childNodes[j];
                        param2 = this.readParams(n);
                        break;
                    }
                }
            }
            for (j = 0; j &lt; param2.length; j++) {
                p.push(this.addPoint(this.objects[param2[j]]));
            }

            this.board.create(&#x27;polygon&#x27;, p, {name: param[0], id: param[0], withLabel: true});
            this.objects[param[0]].exists = true;
        },

        addVectorFromPointToPoint: function (node) {
            var el, el1, el2,
                param = this.readParams(node);

            el1 = this.addPoint(this.objects[param[1]]);
            el2 = this.addPoint(this.objects[param[2]]);
            el = this.board.create(&#x27;arrow&#x27;, [el1.id, el2.id], {name: param[0]});
            this.setAttributes(el);
            this.objects[param[0]].exists = true;
        },

// ----------------------------------------------------------------------------------------------------

        addLocusDefinedByPoint: function (node) {
            var param = this.readParams(node),
                el = this.board.select(param[1]);

            el.setAttribute({trace: true});
            this.objects[param[1]] = el;
            this.setAttributes(el);
        },

        addLocusDefinedByPointOnLine: function (node) {
            var param = this.readParams(node),
                el = this.board.select(param[1]);

            el.setAttribute({trace: true});
            this.objects[param[1]] = el;
            this.setAttributes(el);
        },

        addLocusDefinedByLineThroughPoint: function (node) {
            var param = this.readParams(node),
                el = this.board.select(param[1]);

            el.setAttribute({trace: true});
            this.objects[param[1]] = el;
            this.setAttributes(el);
        },

        addLocusDefinedByPointOnCircle: function (node) {
            var param = this.readParams(node),
                el = this.board.select(param[1]);

            el.setAttribute({trace: true});
            this.objects[param[1]] = el;
            this.setAttributes(el);
        },

        /**
         * Extract the xml-code as String from the zipped Intergeo archive.
         * @param {String} fileStr
         * @return {String} xml code
         */
        prepareString: function (fileStr) {
            var i,
                bA = [],
                isZip = false;

            if ((fileStr.slice(0, 2) === &quot;PK&quot; ||
                    JXG.Util.UTF8.asciiCharCodeAt(fileStr.slice(0, 1), 0) === 31)) {
                isZip = true;
            }

            // It&#x27;s not a zip file but it doesn&#x27;t start with &#x27;&lt;&#x27; either -&gt; base64!
            if (!isZip &amp;&amp; fileStr.indexOf(&#x27;&lt;&#x27;) !== 0) {
                fileStr = JXG.Util.Base64.decode(fileStr);
            }

            if (fileStr.indexOf(&#x27;&lt;&#x27;) !== 0) {
                //binary = false;
                for (i = 0; i &lt; fileStr.length; i++) {
                    bA[i] = JXG.Util.UTF8.asciiCharCodeAt(fileStr, i);
                }

                fileStr = (new JXG.Util.Unzip(bA)).unzipFile(&quot;construction/intergeo.xml&quot;);
                // Extract &quot;construction/intergeo.xml&quot; from
                // the zip-archive in bA.
            }

            return fileStr;
        },

        /**
         * Displpay part
         */

        readDisplayProperty: function (tree, s) {
            var j, node, el, prop = {}, key, val;

            node = tree[0].childNodes[s];

            // not an element node
            if (node.nodeType &gt; 1) {
                return;
            }

            if (node.nodeName === &#x27;background-color&#x27;) {
                this.board.containerObj.style.backgroundColor = node.firstChild.data;
            } else if (node.nodeName === &#x27;style&#x27;) {
                // get the element
                el = this.board.select(node.getAttribute(&#x27;ref&#x27;));

                for (j = 0; j &lt; node.childNodes.length; j++) {
                    if (node.childNodes[j].nodeType === 1) {
                        key = node.childNodes[j].nodeName;
                        val = node.childNodes[j].firstChild.data;
                        if (key === &#x27;stroke&#x27;) {
                            key = &#x27;strokeColor&#x27;;
                        } else if (key === &#x27;stroke-width&#x27; || key === &#x27;border-width&#x27;) {
                            key = &#x27;strokeWidth&#x27;;
                        } else if (key === &#x27;fill&#x27;) {
                            key = &#x27;fillColor&#x27;;
                        } else if (key === &#x27;fill-opacity&#x27;) {
                            key = &#x27;fillOpacity&#x27;;
                        } else if (key === &#x27;border-opacity&#x27;) {
                            key = &#x27;strokeOpacity&#x27;;
                        } else if (key === &#x27;point-size&#x27;) {
                            key = &#x27;size&#x27;;
                        } else if (key === &#x27;label&#x27;) {
                            key = &#x27;name&#x27;;
                        } else if (key === &#x27;point-style&#x27;) {
                            key = &#x27;face&#x27;;
                            if (val === &#x27;circle&#x27;) {
                                val = &#x27;o&#x27;;
                            } else if (val === &#x27;cross&#x27;) {
                                val = &#x27;+&#x27;;
                            } else if (val === &#x27;x-mark&#x27;) {
                                val = &#x27;x&#x27;;
                            } else if (val === &#x27;square&#x27;) {
                                val = &#x27;[]&#x27;;
                            } else if (val === &#x27;triangle&#x27;) {
                                val = &#x27;triangleup&#x27;;
                            } else if (val === &#x27;point&#x27;) {  // Setting size to 1 is missing
                                val = &#x27;o&#x27;;
                            } else {
                                JXG.debug(&#x27;Display: not implemented&#x27; + node.nodeName);
                                // Missing:
                                // circumference, image
                            }
                        }
                        prop[key] = val;
                    }
                }
                el.setAttribute(prop);
            } else {
                JXG.debug(&#x27;Display: not implemented&#x27; + node.nodeName);
            }
        },

        readDisplay: function (tree) {
            var s;

            if (!JXG.exists(tree) || !JXG.isArray(tree)) {
                return;
            }

            for (s = 0; s &lt; tree[0].childNodes.length; s++) {
                this.readDisplayProperty(tree, s);
            }
        }

    });

    JXG.registerReader(JXG.IntergeoReader, [&#x27;i2g&#x27;, &#x27;xml&#x27;, &#x27;intergeo&#x27;]);
}());
    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>

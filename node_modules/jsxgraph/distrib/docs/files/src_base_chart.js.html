<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src/base/chart.js - JSXGraph</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="../assets/js/jsxgraphcore.js"></script>
    <link rel="stylesheet" href="../assets/css/jsxgraph.css">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../assets/css/logo_blue.png" title="JSXGraph" width="117" height="52"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.99.4</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/Angle.html">Angle</a> </li>
                                <li><a href="../classes/Arc.html">Arc</a> </li>
                                <li><a href="../classes/Arrow.html">Arrow</a> </li>
                                <li><a href="../classes/Arrowparallel.html">Arrowparallel</a> </li>
                                <li><a href="../classes/Axis.html">Axis</a> </li>
                                <li><a href="../classes/Bisector.html">Bisector</a> </li>
                                <li><a href="../classes/Bisectorlines.html">Bisectorlines</a> </li>
                                <li><a href="../classes/Button.html">Button</a> </li>
                                <li><a href="../classes/Checkbox.html">Checkbox</a> </li>
                                <li><a href="../classes/Circle.html">Circle</a> </li>
                                <li><a href="../classes/Circumcenter.html">Circumcenter</a> </li>
                                <li><a href="../classes/Circumcircle.html">Circumcircle</a> </li>
                                <li><a href="../classes/CircumcircleArc.html">CircumcircleArc</a> </li>
                                <li><a href="../classes/CircumcircleSector.html">CircumcircleSector</a> </li>
                                <li><a href="../classes/Conic.html">Conic</a> </li>
                                <li><a href="../classes/Curve.html">Curve</a> </li>
                                <li><a href="../classes/Ellipse.html">Ellipse</a> </li>
                                <li><a href="../classes/EventEmitter.html">EventEmitter</a> </li>
                                <li><a href="../classes/Functiongraph.html">Functiongraph</a> </li>
                                <li><a href="../classes/Glider.html">Glider</a> </li>
                                <li><a href="../classes/Grid.html">Grid</a> </li>
                                <li><a href="../classes/Group.html">Group</a> </li>
                                <li><a href="../classes/Hatch.html">Hatch</a> </li>
                                <li><a href="../classes/Hyperbola.html">Hyperbola</a> </li>
                                <li><a href="../classes/Image.html">Image</a> </li>
                                <li><a href="../classes/Incenter.html">Incenter</a> </li>
                                <li><a href="../classes/Incircle.html">Incircle</a> </li>
                                <li><a href="../classes/Inequality.html">Inequality</a> </li>
                                <li><a href="../classes/Input.html">Input</a> </li>
                                <li><a href="../classes/Integral.html">Integral</a> </li>
                                <li><a href="../classes/Intersection.html">Intersection</a> </li>
                                <li><a href="../classes/JXG.html">JXG</a> </li>
                                <li><a href="../classes/JXG.AbstractRenderer.html">JXG.AbstractRenderer</a> </li>
                                <li><a href="../classes/JXG.Board.html">JXG.Board</a> </li>
                                <li><a href="../classes/JXG.C.html">JXG.C</a> </li>
                                <li><a href="../classes/JXG.CanvasRenderer.html">JXG.CanvasRenderer</a> </li>
                                <li><a href="../classes/JXG.Chart.html">JXG.Chart</a> </li>
                                <li><a href="../classes/JXG.Circle.html">JXG.Circle</a> </li>
                                <li><a href="../classes/JXG.Complex.html">JXG.Complex</a> </li>
                                <li><a href="../classes/JXG.Composition.html">JXG.Composition</a> </li>
                                <li><a href="../classes/JXG.Coords.html">JXG.Coords</a> </li>
                                <li><a href="../classes/JXG.CoordsElement.html">JXG.CoordsElement</a> </li>
                                <li><a href="../classes/JXG.Curve.html">JXG.Curve</a> </li>
                                <li><a href="../classes/JXG.GeometryElement.html">JXG.GeometryElement</a> </li>
                                <li><a href="../classes/JXG.Group.html">JXG.Group</a> </li>
                                <li><a href="../classes/JXG.Image.html">JXG.Image</a> </li>
                                <li><a href="../classes/JXG.JSXGraph.html">JXG.JSXGraph</a> </li>
                                <li><a href="../classes/JXG.Line.html">JXG.Line</a> </li>
                                <li><a href="../classes/JXG.Math.html">JXG.Math</a> </li>
                                <li><a href="../classes/JXG.Math.Geometry.html">JXG.Math.Geometry</a> </li>
                                <li><a href="../classes/JXG.Math.Numerics.html">JXG.Math.Numerics</a> </li>
                                <li><a href="../classes/JXG.Math.Poly.html">JXG.Math.Poly</a> </li>
                                <li><a href="../classes/JXG.Math.Poly.Monomial.html">JXG.Math.Poly.Monomial</a> </li>
                                <li><a href="../classes/JXG.Math.Poly.Polynomial.html">JXG.Math.Poly.Polynomial</a> </li>
                                <li><a href="../classes/JXG.Math.Poly.Ring.html">JXG.Math.Poly.Ring</a> </li>
                                <li><a href="../classes/JXG.Math.Quadtree.html">JXG.Math.Quadtree</a> </li>
                                <li><a href="../classes/JXG.Math.Statistics.html">JXG.Math.Statistics</a> </li>
                                <li><a href="../classes/JXG.Math.Symbolic.html">JXG.Math.Symbolic</a> </li>
                                <li><a href="../classes/JXG.NoRenderer.html">JXG.NoRenderer</a> </li>
                                <li><a href="../classes/JXG.Options.html">JXG.Options</a> </li>
                                <li><a href="../classes/JXG.Point.html">JXG.Point</a> </li>
                                <li><a href="../classes/JXG.Polygon.html">JXG.Polygon</a> </li>
                                <li><a href="../classes/JXG.SVGRenderer.html">JXG.SVGRenderer</a> </li>
                                <li><a href="../classes/JXG.Text.html">JXG.Text</a> </li>
                                <li><a href="../classes/JXG.Ticks.html">JXG.Ticks</a> </li>
                                <li><a href="../classes/JXG.Transformation.html">JXG.Transformation</a> </li>
                                <li><a href="../classes/JXG.Turtle.html">JXG.Turtle</a> </li>
                                <li><a href="../classes/JXG.Util.Base64.html">JXG.Util.Base64</a> </li>
                                <li><a href="../classes/JXG.Util.Unzip.html">JXG.Util.Unzip</a> </li>
                                <li><a href="../classes/JXG.VMLRenderer.html">JXG.VMLRenderer</a> </li>
                                <li><a href="../classes/Line.html">Line</a> </li>
                                <li><a href="../classes/Locus.html">Locus</a> </li>
                                <li><a href="../classes/MajorArc.html">MajorArc</a> </li>
                                <li><a href="../classes/Midpoint.html">Midpoint</a> </li>
                                <li><a href="../classes/MinorArc.html">MinorArc</a> </li>
                                <li><a href="../classes/MinorSector.html">MinorSector</a> </li>
                                <li><a href="../classes/Mirrorpoint.html">Mirrorpoint</a> </li>
                                <li><a href="../classes/NonReflexAngle.html">NonReflexAngle</a> </li>
                                <li><a href="../classes/Normal.html">Normal</a> </li>
                                <li><a href="../classes/Orthogonalprojection.html">Orthogonalprojection</a> </li>
                                <li><a href="../classes/OtherIntersection.html">OtherIntersection</a> </li>
                                <li><a href="../classes/Parabola.html">Parabola</a> </li>
                                <li><a href="../classes/Parallel.html">Parallel</a> </li>
                                <li><a href="../classes/Parallelpoint.html">Parallelpoint</a> </li>
                                <li><a href="../classes/Perpendicular.html">Perpendicular</a> </li>
                                <li><a href="../classes/PerpendicularPoint.html">PerpendicularPoint</a> </li>
                                <li><a href="../classes/PerpendicularSegment.html">PerpendicularSegment</a> </li>
                                <li><a href="../classes/Point.html">Point</a> </li>
                                <li><a href="../classes/PolarLine.html">PolarLine</a> </li>
                                <li><a href="../classes/PolePoint.html">PolePoint</a> </li>
                                <li><a href="../classes/Polygon.html">Polygon</a> </li>
                                <li><a href="../classes/RadicalAxis.html">RadicalAxis</a> </li>
                                <li><a href="../classes/Reflection.html">Reflection</a> </li>
                                <li><a href="../classes/ReflexAngle.html">ReflexAngle</a> </li>
                                <li><a href="../classes/registerReader.html">registerReader</a> </li>
                                <li><a href="../classes/RegularPolygon.html">RegularPolygon</a> </li>
                                <li><a href="../classes/Riemannsum.html">Riemannsum</a> </li>
                                <li><a href="../classes/Sector.html">Sector</a> </li>
                                <li><a href="../classes/Segment.html">Segment</a> </li>
                                <li><a href="../classes/Semicircle.html">Semicircle</a> </li>
                                <li><a href="../classes/Slider.html">Slider</a> </li>
                                <li><a href="../classes/Slopetriangle.html">Slopetriangle</a> </li>
                                <li><a href="../classes/Spline.html">Spline</a> </li>
                                <li><a href="../classes/Stepfunction.html">Stepfunction</a> </li>
                                <li><a href="../classes/Tangent.html">Tangent</a> </li>
                                <li><a href="../classes/Tapemeasure.html">Tapemeasure</a> </li>
                                <li><a href="../classes/Text.html">Text</a> </li>
                                <li><a href="../classes/Ticks.html">Ticks</a> </li>
                                <li><a href="../classes/Tracecurve.html">Tracecurve</a> </li>
                                <li><a href="../classes/Transformation.html">Transformation</a> </li>
                                <li><a href="../classes/Turtle.html">Turtle</a> </li>
                            </ul>
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="../modules/JXG.html">JXG</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: src/base/chart.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/*
    Copyright 2008-2015
        Matthias Ehmann,
        Michael Gerhaeuser,
        Carsten Miller,
        Bianca Valentin,
        Alfred Wassermann,
        Peter Wilfahrt

    This file is part of JSXGraph.

    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.

    You can redistribute it and/or modify it under the terms of the

      * GNU Lesser General Public License as published by
        the Free Software Foundation, either version 3 of the License, or
        (at your option) any later version
      OR
      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT

    JSXGraph is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License and
    the MIT License along with JSXGraph. If not, see &lt;http://www.gnu.org/licenses/&gt;
    and &lt;http://opensource.org/licenses/MIT/&gt;.
 */


/*global JXG: true, define: true, document: true*/
/*jslint nomen: true, plusplus: true*/

/* depends:
 jxg
 math/numerics
 math/statistics
 base/constants
 base/coords
 base/element
 parser/datasource
 utils/color
 utils/type
 utils/env
  elements:
   curve
   spline
   functiongraph
   point
   text
   polygon
   sector
   transform
   line
   legend
   circle
 */

define([
    &#x27;jxg&#x27;, &#x27;math/numerics&#x27;, &#x27;math/statistics&#x27;, &#x27;base/constants&#x27;, &#x27;base/coords&#x27;, &#x27;base/element&#x27;, &#x27;parser/datasource&#x27;,
    &#x27;utils/color&#x27;, &#x27;utils/type&#x27;, &#x27;utils/env&#x27;, &#x27;base/curve&#x27;, &#x27;base/point&#x27;, &#x27;base/text&#x27;, &#x27;base/polygon&#x27;, &#x27;element/sector&#x27;,
    &#x27;base/transformation&#x27;, &#x27;base/line&#x27;, &#x27;base/circle&#x27;
], function (JXG, Numerics, Statistics, Const, Coords, GeometryElement, DataSource, Color, Type, Env, Curve, Point, Text,
        Polygon, Sector, Transform, Line, Circle) {

    &quot;use strict&quot;;

    /**
     * Chart plotting
     * @class JXG.Chart
     * @constructor
     */
    JXG.Chart = function (board, parents, attributes) {
        this.constructor(board, attributes);

        var x, y, i, c, style, len;

        if (!Type.isArray(parents) || parents.length === 0) {
            throw new Error(&#x27;JSXGraph: Can\&#x27;t create a chart without data&#x27;);
        }

        /**
         * Contains pointers to the various subelements of the chart.
         * @property
         * @Å§ype Array
         */
        this.elements = [];

        if (Type.isNumber(parents[0])) {
            // parents looks like [a,b,c,..]
            // x has to be filled

            y = parents;
            x = [];
            for (i = 0; i &lt; y.length; i++) {
                x[i] = i + 1;
            }
        } else if (parents.length === 1 &amp;&amp; Type.isArray(parents[0])) {
            // parents looks like [[a,b,c,..]]
            // x has to be filled

            y = parents[0];
            x = [];

            len = Type.evaluate(y).length;
            for (i = 0; i &lt; len; i++) {
                x[i] = i + 1;
            }
        } else if (parents.length === 2) {
            // parents looks like [[x0,x1,x2,...],[y1,y2,y3,...]]
            len = Math.min(parents[0].length, parents[1].length);
            x = parents[0].slice(0, len);
            y = parents[1].slice(0, len);
        }

        if (Type.isArray(y) &amp;&amp; y.length === 0) {
            throw new Error(&#x27;JSXGraph: Can\&#x27;t create charts without data.&#x27;);
        }

        // does this really need to be done here? this should be done in createChart and then
        // there should be an extra chart for each chartstyle
        style = attributes.chartstyle.replace(/ /g, &#x27;&#x27;).split(&#x27;,&#x27;);
        for (i = 0; i &lt; style.length; i++) {
            switch (style[i]) {
            case &#x27;bar&#x27;:
                c = this.drawBar(board, x, y, attributes);
                break;
            case &#x27;line&#x27;:
                c = this.drawLine(board, x, y, attributes);
                break;
            case &#x27;fit&#x27;:
                c = this.drawFit(board, x, y, attributes);
                break;
            case &#x27;spline&#x27;:
                c = this.drawSpline(board, x, y, attributes);
                break;
            case &#x27;pie&#x27;:
                c = this.drawPie(board, y, attributes);
                break;
            case &#x27;point&#x27;:
                c = this.drawPoints(board, x, y, attributes);
                break;
            case &#x27;radar&#x27;:
                c = this.drawRadar(board, parents, attributes);
                break;
            }
            this.elements.push(c);
        }
        this.id = this.board.setId(this, &#x27;Chart&#x27;);

        return this.elements;
    };
    JXG.Chart.prototype = new GeometryElement();

    JXG.extend(JXG.Chart.prototype, /** @lends JXG.Chart.prototype */ {
        drawLine: function (board, x, y, attributes) {
            // we don&#x27;t want the line chart to be filled
            attributes.fillcolor = &#x27;none&#x27;;
            attributes.highlightfillcolor = &#x27;none&#x27;;

            return board.create(&#x27;curve&#x27;, [x, y], attributes);
        },

        drawSpline: function (board, x, y, attributes) {
            // we don&#x27;t want the spline chart to be filled
            attributes.fillColor = &#x27;none&#x27;;
            attributes.highlightfillcolor = &#x27;none&#x27;;

            return board.create(&#x27;spline&#x27;, [x, y], attributes);
        },

        drawFit: function (board, x, y, attributes) {
            var deg = attributes.degree;

            deg = Math.max(parseInt(deg, 10), 1) || 1;

            // never fill
            attributes.fillcolor = &#x27;none&#x27;;
            attributes.highlightfillcolor = &#x27;none&#x27;;

            return board.create(&#x27;functiongraph&#x27;, [Numerics.regressionPolynomial(deg, x, y)], attributes);
        },

        drawBar: function (board, x, y, attributes) {
            var i, strwidth, fill, fs, text, w, xp0, xp1, xp2, yp, colors,
                pols = [],
                p = [],
                attr,

                makeXpFun = function (i, f) {
                    return function () {
                        return x[i]() - f * w;
                    };
                },

                hiddenPoint = {
                    fixed: true,
                    withLabel: false,
                    visible: false,
                    name: &#x27;&#x27;
                };

            if (!Type.exists(attributes.fillopacity)) {
                attributes.fillopacity = 0.6;
            }

            // Determine the width of the bars
            if (attributes &amp;&amp; attributes.width) {  // width given
                w = attributes.width;
            } else {
                if (x.length &lt;= 1) {
                    w = 1;
                } else {
                    // Find minimum distance between to bars.
                    w = x[1] - x[0];
                    for (i = 1; i &lt; x.length - 1; i++) {
                        w = (x[i + 1] - x[i] &lt; w) ? x[i + 1] - x[i] : w;
                    }
                }
                w *= 0.8;
            }

            fill = attributes.fillcolor;

            attr = Type.copyAttributes(attributes, board.options, &#x27;chart&#x27;, &#x27;label&#x27;);
            fs = parseFloat(attr.fontsize);

            for (i = 0; i &lt; x.length; i++) {
                if (Type.isFunction(x[i])) {
                    xp0 = makeXpFun(i, -0.5);

                    xp1 = makeXpFun(i, 0);

                    xp2 = makeXpFun(i, 0.5);
                } else {
                    xp0 = x[i] - w * 0.5;
                    xp1 = x[i];
                    xp2 = x[i] + w * 0.5;
                }
                yp = y[i];
                if (attributes.dir === &#x27;horizontal&#x27;) {  // horizontal bars
                    p[0] = board.create(&#x27;point&#x27;, [0, xp0], hiddenPoint);
                    p[1] = board.create(&#x27;point&#x27;, [yp, xp0], hiddenPoint);
                    p[2] = board.create(&#x27;point&#x27;, [yp, xp2], hiddenPoint);
                    p[3] = board.create(&#x27;point&#x27;, [0, xp2], hiddenPoint);

                    if (Type.exists(attributes.labels) &amp;&amp; Type.exists(attributes.labels[i])) {
                        strwidth = attributes.labels[i].toString().length;
                        strwidth = 2 * strwidth * fs / board.unitX;
                        if (yp &gt;= 0) {
                            // Static offset for label
                            yp += fs * 0.5 / board.unitX;
                        } else {
                            // Static offset for label
                            yp -= fs * strwidth / board.unitX;
                        }
                        xp1 -= fs * 0.2 / board.unitY;
                        text = board.create(&#x27;text&#x27;, [yp, xp1, attributes.labels[i].toString()], attr);
                    }
                } else { // vertical bars
                    p[0] = board.create(&#x27;point&#x27;, [xp0, 0], hiddenPoint);
                    p[1] = board.create(&#x27;point&#x27;, [xp0, yp], hiddenPoint);
                    p[2] = board.create(&#x27;point&#x27;, [xp2, yp], hiddenPoint);
                    p[3] = board.create(&#x27;point&#x27;, [xp2, 0], hiddenPoint);

                    if (Type.exists(attributes.labels) &amp;&amp; Type.exists(attributes.labels[i])) {
                        strwidth = attributes.labels[i].toString().length;
                        strwidth = 0.6 * strwidth * fs / board.unitX;

                        if (yp &gt;= 0) {
                            // Static offset for label
                            yp += fs * 0.5 / board.unitY;
                        } else {
                            // Static offset for label
                            yp -= fs / board.unitY;
                        }
                        text = board.create(&#x27;text&#x27;, [xp1 - strwidth * 0.5, yp, attributes.labels[i].toString()], attr);
                    }
                }

                attributes.withlines = false;

                if (Type.isArray(attributes.colors)) {
                    colors = attributes.colors;
                    attributes.fillcolor = colors[i % colors.length];
                }

                pols[i] = board.create(&#x27;polygon&#x27;, p, attributes);
                if (Type.exists(attributes.labels) &amp;&amp; Type.exists(attributes.labels[i])) {
                    pols[i].text = text;
                }
            }

            return pols;
        },

        drawPoints: function (board, x, y, attributes) {
            var i,
                points = [],
                infoboxArray = attributes.infoboxarray;

            attributes.fixed = true;
            attributes.name = &#x27;&#x27;;

            for (i = 0; i &lt; x.length; i++) {
                attributes.infoboxtext = infoboxArray ? infoboxArray[i % infoboxArray.length] : false;
                points[i] = board.create(&#x27;point&#x27;, [x[i], y[i]], attributes);
            }

            return points;
        },

        drawPie: function (board, y, attributes) {
            var i, center,
                p = [],
                sector = [],
                s = Statistics.sum(y),
                colorArray = attributes.colors,
                highlightColorArray = attributes.highlightcolors,
                labelArray = attributes.labels,
                r = attributes.radius || 4,
                radius = r,
                cent = attributes.center || [0, 0],
                xc = cent[0],
                yc = cent[1],

                makeRadPointFun = function (j, fun, xc) {
                    return function () {
                        var s, t = 0, i, rad;

                        for (i = 0; i &lt;= j; i++) {
                            t += parseFloat(Type.evaluate(y[i]));
                        }

                        s = t;
                        for (i = j + 1; i &lt; y.length; i++) {
                            s += parseFloat(Type.evaluate(y[i]));
                        }
                        rad = (s !== 0) ? (2 * Math.PI * t / s) : 0;

                        return radius() * Math[fun](rad) + xc;
                    };
                },

                highlightHandleLabel = function (f, s) {
                    var dx = -this.point1.coords.usrCoords[1] + this.point2.coords.usrCoords[1],
                        dy = -this.point1.coords.usrCoords[2] + this.point2.coords.usrCoords[2];

                    if (Type.exists(this.label)) {
                        this.label.rendNode.style.fontSize = (s * this.label.visProp.fontsize) + &#x27;px&#x27;;
                        this.label.prepareUpdate().update().updateRenderer();
                    }

                    this.point2.coords = new Coords(Const.COORDS_BY_USER, [
                        this.point1.coords.usrCoords[1] + dx * f,
                        this.point1.coords.usrCoords[2] + dy * f
                    ], this.board);
                    this.prepareUpdate().update().updateRenderer();
                },

                highlightFun = function () {
                    if (!this.highlighted) {
                        this.highlighted = true;
                        this.board.highlightedObjects[this.id] = this;
                        this.board.renderer.highlight(this);

                        highlightHandleLabel.call(this, 1.1, 2);
                    }
                },

                noHighlightFun = function () {
                    if (this.highlighted) {
                        this.highlighted = false;
                        this.board.renderer.noHighlight(this);

                        highlightHandleLabel.call(this, 0.90909090, 1);
                    }
                },

                hiddenPoint = {
                    fixed: true,
                    withLabel: false,
                    visible: false,
                    name: &#x27;&#x27;
                };

            if (!Type.isArray(labelArray)) {
                labelArray = [];
                for (i = 0; i &lt; y.length; i++) {
                    labelArray[i] = &#x27;&#x27;;
                }
            }

            if (!Type.isFunction(r)) {
                radius = function () {
                    return r;
                };
            }

            attributes.highlightonsector = attributes.highlightonsector || false;
            attributes.straightfirst = false;
            attributes.straightlast = false;

            center = board.create(&#x27;point&#x27;, [xc, yc], hiddenPoint);
            p[0] = board.create(&#x27;point&#x27;, [
                function () {
                    return radius() + xc;
                },
                function () {
                    return yc;
                }
            ], hiddenPoint);

            for (i = 0; i &lt; y.length; i++) {
                p[i + 1] = board.create(&#x27;point&#x27;, [makeRadPointFun(i, &#x27;cos&#x27;, xc), makeRadPointFun(i, &#x27;sin&#x27;, yc)], hiddenPoint);

                attributes.name = labelArray[i];
                attributes.withlabel = attributes.name !== &#x27;&#x27;;
                attributes.fillcolor = colorArray &amp;&amp; colorArray[i % colorArray.length];
                attributes.labelcolor = colorArray &amp;&amp; colorArray[i % colorArray.length];
                attributes.highlightfillcolor = highlightColorArray &amp;&amp; highlightColorArray[i % highlightColorArray.length];

                sector[i] = board.create(&#x27;sector&#x27;, [center, p[i], p[i + 1]], attributes);

                if (attributes.highlightonsector) {
                    // overwrite hasPoint so that the whole sector is used for highlighting
                    sector[i].hasPoint = sector[i].hasPointSector;
                }
                if (attributes.highlightbysize) {
                    sector[i].highlight = highlightFun;

                    sector[i].noHighlight = noHighlightFun;
                }

            }

            // Not enough! We need points, but this gives an error in setAttribute.
            return {sectors: sector, points: p, midpoint: center};
        },

        /*
         * labelArray=[ row1, row2, row3 ]
         * paramArray=[ paramx, paramy, paramz ]
         * parents=[[x1, y1, z1], [x2, y2, z2], [x3, y3, z3]]
         */
        drawRadar: function (board, parents, attributes) {
            var i, j, paramArray, numofparams, maxes, mins,
                la, pdata, ssa, esa, ssratio, esratio,
                sshifts, eshifts, starts, ends,
                labelArray, colorArray, highlightColorArray, radius, myAtts,
                cent, xc, yc, center, start_angle, rad, p, line, t,
                xcoord, ycoord, polygons, legend_position, circles, lxoff, lyoff,
                cla, clabelArray, ncircles, pcircles, angle, dr, sw, data,
                len = parents.length,

                get_anchor = function () {
                    var x1, x2, y1, y2,
                        relCoords = this.visProp.label.offset.slice(0);

                    x1 = this.point1.X();
                    x2 = this.point2.X();
                    y1 = this.point1.Y();
                    y2 = this.point2.Y();
                    if (x2 &lt; x1) {
                        relCoords[0] = -relCoords[0];
                    }

                    if (y2 &lt; y1) {
                        relCoords[1] = -relCoords[1];
                    }

                    this.setLabelRelativeCoords(relCoords);

                    return new Coords(Const.COORDS_BY_USER, [this.point2.X(), this.point2.Y()], this.board);
                },

                get_transform = function (angle, i) {
                    var t, tscale, trot;

                    t = board.create(&#x27;transform&#x27;, [-(starts[i] - sshifts[i]), 0], {type: &#x27;translate&#x27;});
                    tscale = board.create(&#x27;transform&#x27;, [radius / ((ends[i] + eshifts[i]) - (starts[i] - sshifts[i])), 1], {type: &#x27;scale&#x27;});
                    t.melt(tscale);
                    trot = board.create(&#x27;transform&#x27;, [angle], {type: &#x27;rotate&#x27;});
                    t.melt(trot);

                    return t;
                };

            if (len &lt;= 0) {
                JXG.debug(&quot;No data&quot;);
                return;
            }
            // labels for axes
            paramArray = attributes.paramarray;
            if (!Type.exists(paramArray)) {
                JXG.debug(&quot;Need paramArray attribute&quot;);
                return;
            }
            numofparams = paramArray.length;
            if (numofparams &lt;= 1) {
                JXG.debug(&quot;Need more than 1 param&quot;);
                return;
            }

            for (i = 0; i &lt; len; i++) {
                if (numofparams !== parents[i].length) {
                    JXG.debug(&quot;Use data length equal to number of params (&quot; + parents[i].length + &quot; != &quot; + numofparams + &quot;)&quot;);
                    return;
                }
            }

            maxes = [];
            mins = [];

            for (j = 0; j &lt; numofparams; j++) {
                maxes[j] = parents[0][j];
                mins[j] = maxes[j];
            }

            for (i = 1; i &lt; len; i++) {
                for (j = 0; j &lt; numofparams; j++) {
                    if (parents[i][j] &gt; maxes[j]) {
                        maxes[j] = parents[i][j];
                    }

                    if (parents[i][j] &lt; mins[j]) {
                        mins[j] = parents[i][j];
                    }
                }
            }

            la = [];
            pdata = [];

            for (i = 0; i &lt; len; i++) {
                la[i] = &#x27;&#x27;;
                pdata[i] = [];
            }

            ssa = [];
            esa = [];

            // 0 &lt;= Offset from chart center &lt;=1
            ssratio = attributes.startshiftratio || 0;
            // 0 &lt;= Offset from chart radius &lt;=1
            esratio = attributes.endshiftratio || 0;

            for (i = 0; i &lt; numofparams; i++) {
                ssa[i] = (maxes[i] - mins[i]) * ssratio;
                esa[i] = (maxes[i] - mins[i]) * esratio;
            }

            // Adjust offsets per each axis
            sshifts = attributes.startshiftarray || ssa;
            eshifts = attributes.endshiftarray || esa;
            // Values for inner circle, minimums by default
            starts = attributes.startarray || mins;

            if (Type.exists(attributes.start)) {
                for (i = 0; i &lt; numofparams; i++) {
                    starts[i] = attributes.start;
                }
            }

            // Values for outer circle, maximums by default
            ends = attributes.endarray || maxes;
            if (Type.exists(attributes.end)) {
                for (i = 0; i &lt; numofparams; i++) {
                    ends[i] = attributes.end;
                }
            }

            if (sshifts.length !== numofparams) {
                JXG.debug(&quot;Start shifts length is not equal to number of parameters&quot;);
                return;
            }

            if (eshifts.length !== numofparams) {
                JXG.debug(&quot;End shifts length is not equal to number of parameters&quot;);
                return;
            }

            if (starts.length !== numofparams) {
                JXG.debug(&quot;Starts length is not equal to number of parameters&quot;);
                return;
            }

            if (ends.length !== numofparams) {
                JXG.debug(&quot;Ends length is not equal to number of parameters&quot;);
                return;
            }

            // labels for legend
            labelArray = attributes.labelarray || la;
            colorArray = attributes.colors;
            highlightColorArray = attributes.highlightcolors;
            radius = attributes.radius || 10;
            sw = attributes.strokewidth || 1;

            if (!Type.exists(attributes.highlightonsector)) {
                attributes.highlightonsector = false;
            }

            myAtts = {
                name: attributes.name,
                id: attributes.id,
                strokewidth: sw,
                polystrokewidth: attributes.polystrokewidth || sw,
                strokecolor: attributes.strokecolor || &#x27;black&#x27;,
                straightfirst: false,
                straightlast: false,
                fillcolor: attributes.fillColor || &#x27;#FFFF88&#x27;,
                fillopacity: attributes.fillOpacity || 0.4,
                highlightfillcolor: attributes.highlightFillColor || &#x27;#FF7400&#x27;,
                highlightstrokecolor: attributes.highlightStrokeColor || &#x27;black&#x27;,
                gradient: attributes.gradient || &#x27;none&#x27;
            };

            cent = attributes.center || [0, 0];
            xc = cent[0];
            yc = cent[1];
            center = board.create(&#x27;point&#x27;, [xc, yc], {name: &#x27;&#x27;, fixed: true, withlabel: false, visible: false});
            start_angle = Math.PI / 2 - Math.PI / numofparams;
            start_angle = attributes.startangle || 0;
            rad = start_angle;
            p = [];
            line = [];

            for (i = 0; i &lt; numofparams; i++) {
                rad += 2 * Math.PI / numofparams;
                xcoord = radius * Math.cos(rad) + xc;
                ycoord = radius * Math.sin(rad) + yc;

                p[i] = board.create(&#x27;point&#x27;, [xcoord, ycoord], {name: &#x27;&#x27;, fixed: true, withlabel: false, visible: false});
                line[i] = board.create(&#x27;line&#x27;, [center, p[i]], {
                    name: paramArray[i],
                    strokeColor: myAtts.strokecolor,
                    strokeWidth: myAtts.strokewidth,
                    strokeOpacity: 1.0,
                    straightFirst: false,
                    straightLast: false,
                    withLabel: true,
                    highlightStrokeColor: myAtts.highlightstrokecolor
                });
                line[i].getLabelAnchor = get_anchor;
                t = get_transform(rad, i);

                for (j = 0; j &lt; parents.length; j++) {
                    data = parents[j][i];
                    pdata[j][i] = board.create(&#x27;point&#x27;, [data, 0], {name: &#x27;&#x27;, fixed: true, withlabel: false, visible: false});
                    pdata[j][i].addTransform(pdata[j][i], t);
                }
            }

            polygons = [];
            for (i = 0; i &lt; len; i++) {
                myAtts.labelcolor = colorArray &amp;&amp; colorArray[i % colorArray.length];
                myAtts.strokecolor = colorArray &amp;&amp; colorArray[i % colorArray.length];
                myAtts.fillcolor = colorArray &amp;&amp; colorArray[i % colorArray.length];
                polygons[i] = board.create(&#x27;polygon&#x27;, pdata[i], {
                    withLines: true,
                    withLabel: false,
                    fillColor: myAtts.fillcolor,
                    fillOpacity: myAtts.fillopacity,
                    highlightFillColor: myAtts.highlightfillcolor
                });

                for (j = 0; j &lt; numofparams; j++) {
                    polygons[i].borders[j].setAttribute(&#x27;strokecolor:&#x27; + colorArray[i % colorArray.length]);
                    polygons[i].borders[j].setAttribute(&#x27;strokewidth:&#x27; + myAtts.polystrokewidth);
                }
            }

            legend_position = attributes.legendposition || &#x27;none&#x27;;
            switch (legend_position) {
            case &#x27;right&#x27;:
                lxoff = attributes.legendleftoffset || 2;
                lyoff = attributes.legendtopoffset || 1;

                this.legend = board.create(&#x27;legend&#x27;, [xc + radius + lxoff, yc + radius - lyoff], {
                    labels: labelArray,
                    colors: colorArray
                });
                break;
            case &#x27;none&#x27;:
                break;
            default:
                JXG.debug(&#x27;Unknown legend position&#x27;);
            }

            circles = [];
            if (attributes.showcircles) {
                cla = [];
                for (i = 0; i &lt; 6; i++) {
                    cla[i] = 20 * i;
                }
                cla[0] = &quot;0&quot;;
                clabelArray = attributes.circlelabelarray || cla;
                ncircles = clabelArray.length;

                if (ncircles &lt; 2) {
                    JXG.debug(&quot;Too less circles&quot;);
                    return;
                }

                pcircles = [];
                angle = start_angle + Math.PI / numofparams;
                t = get_transform(angle, 0);

                myAtts.fillcolor = &#x27;none&#x27;;
                myAtts.highlightfillcolor = &#x27;none&#x27;;
                myAtts.strokecolor = attributes.strokecolor || &#x27;black&#x27;;
                myAtts.strokewidth = attributes.circlestrokewidth || 0.5;
                myAtts.layer = 0;

                // we have ncircles-1 intervals between ncircles circles
                dr = (ends[0] - starts[0]) / (ncircles - 1);

                for (i = 0; i &lt; ncircles; i++) {
                    pcircles[i] = board.create(&#x27;point&#x27;, [starts[0] + i * dr, 0], {
                        name: clabelArray[i],
                        size: 0,
                        fixed: true,
                        withLabel: true,
                        visible: true
                    });
                    pcircles[i].addTransform(pcircles[i], t);
                    circles[i] = board.create(&#x27;circle&#x27;, [center, pcircles[i]], myAtts);
                }

            }
            this.rendNode = polygons[0].rendNode;
            return {
                circles: circles,
                lines: line,
                points: pdata,
                midpoint: center,
                polygons: polygons
            };
        },

        /**
         * Then, the update function of the renderer
         * is called.  Since a chart is only an abstract element,
         * containing other elements, this function is empty.
         */
        updateRenderer: function () {
            return this;
        },

        /**
         * Update of the defining points
         */
        update: function () {
            if (this.needsUpdate) {
                this.updateDataArray();
            }

            return this;
        },

        /**
         * For dynamic charts update
         * can be used to compute new entries
         * for the arrays this.dataX and
         * this.dataY. It is used in @see update.
         * Default is an empty method, can be overwritten
         * by the user.
         */
        updateDataArray: function () {}
    });

    JXG.createChart = function (board, parents, attributes) {
        var data, row, i, j, col, charts = [], w, x, showRows, attr,
            originalWidth, name, strokeColor, fillColor, hStrokeColor, hFillColor, len,
            table = Env.isBrowser ? board.document.getElementById(parents[0]) : null;

        if ((parents.length === 1) &amp;&amp; (typeof parents[0] === &#x27;string&#x27;)) {
            if (Type.exists(table)) {
                // extract the data
                attr = Type.copyAttributes(attributes, board.options, &#x27;chart&#x27;);

                table = (new DataSource()).loadFromTable(parents[0], attr.withheaders, attr.withheaders);
                data = table.data;
                col = table.columnHeaders;
                row = table.rowHeaders;

                originalWidth = attr.width;
                name = attr.name;
                strokeColor = attr.strokecolor;
                fillColor = attr.fillcolor;
                hStrokeColor = attr.highlightstrokecolor;
                hFillColor = attr.highlightfillcolor;

                board.suspendUpdate();

                len = data.length;
                showRows = [];
                if (attr.rows &amp;&amp; Type.isArray(attr.rows)) {
                    for (i = 0; i &lt; len; i++) {
                        for (j = 0; j &lt; attr.rows.length; j++) {
                            if ((attr.rows[j] === i) || (attr.withheaders &amp;&amp; attr.rows[j] === row[i])) {
                                showRows.push(data[i]);
                                break;
                            }
                        }
                    }
                } else {
                    showRows = data;
                }

                len = showRows.length;

                for (i = 0; i &lt; len; i++) {

                    x = [];
                    if (attr.chartstyle &amp;&amp; attr.chartstyle.indexOf(&#x27;bar&#x27;) !== -1) {
                        if (originalWidth) {
                            w = originalWidth;
                        } else {
                            w = 0.8;
                        }

                        x.push(1 - w / 2 + (i + 0.5) * w / len);

                        for (j = 1; j &lt; showRows[i].length; j++) {
                            x.push(x[j - 1] + 1);
                        }

                        attr.width = w / len;
                    }

                    if (name &amp;&amp; name.length === len) {
                        attr.name = name[i];
                    } else if (attr.withheaders) {
                        attr.name = col[i];
                    }

                    if (strokeColor &amp;&amp; strokeColor.length === len) {
                        attr.strokecolor = strokeColor[i];
                    } else {
                        attr.strokecolor = Color.hsv2rgb(((i + 1) / len) * 360, 0.9, 0.6);
                    }

                    if (fillColor &amp;&amp; fillColor.length === len) {
                        attr.fillcolor = fillColor[i];
                    } else {
                        attr.fillcolor = Color.hsv2rgb(((i + 1) / len) * 360, 0.9, 1.0);
                    }

                    if (hStrokeColor &amp;&amp; hStrokeColor.length === len) {
                        attr.highlightstrokecolor = hStrokeColor[i];
                    } else {
                        attr.highlightstrokecolor = Color.hsv2rgb(((i + 1) / len) * 360, 0.9, 1.0);
                    }

                    if (hFillColor &amp;&amp; hFillColor.length === len) {
                        attr.highlightfillcolor = hFillColor[i];
                    } else {
                        attr.highlightfillcolor = Color.hsv2rgb(((i + 1) / len) * 360, 0.9, 0.6);
                    }

                    if (attr.chartstyle &amp;&amp; attr.chartstyle.indexOf(&#x27;bar&#x27;) !== -1) {
                        charts.push(new JXG.Chart(board, [x, showRows[i]], attr));
                    } else {
                        charts.push(new JXG.Chart(board, [showRows[i]], attr));
                    }
                }

                board.unsuspendUpdate();

            }
            return charts;
        }

        attr = Type.copyAttributes(attributes, board.options, &#x27;chart&#x27;);
        return new JXG.Chart(board, parents, attr);
    };

    JXG.registerElement(&#x27;chart&#x27;, JXG.createChart);

    /**
     * Legend for chart
     *
     **/
    JXG.Legend = function (board, coords, attributes) {
        var attr;

        /* Call the constructor of GeometryElement */
        this.constructor();

        attr = Type.copyAttributes(attributes, board.options, &#x27;legend&#x27;);

        this.board = board;
        this.coords = new Coords(Const.COORDS_BY_USER, coords, this.board);
        this.myAtts = {};
        this.label_array = attr.labelarray || attr.labels;
        this.color_array = attr.colorarray || attr.colors;
        this.lines = [];
        this.myAtts.strokewidth = attr.strokewidth || 5;
        this.myAtts.straightfirst = false;
        this.myAtts.straightlast = false;
        this.myAtts.withlabel = true;
        this.myAtts.fixed = true;
        this.style = attr.legendstyle || attr.style;

        if (this.style === &#x27;vertical&#x27;) {
            this.drawVerticalLegend(board, attr);
        } else {
            throw new Error(&#x27;JSXGraph: Unknown legend style: &#x27; + this.style);
        }
    };
    JXG.Legend.prototype = new GeometryElement();

    JXG.Legend.prototype.drawVerticalLegend = function (board, attributes) {
        var i,
            line_length = attributes.linelength || 1,
            offy = (attributes.rowheight || 20) / this.board.unitY,

            getLabelAnchor = function () {
                this.setLabelRelativeCoords(this.visProp.label.offset);
                return new Coords(Const.COORDS_BY_USER, [this.point2.X(), this.point2.Y()], this.board);
            };

        for (i = 0; i &lt; this.label_array.length; i++) {
            this.myAtts.strokecolor = this.color_array[i];
            this.myAtts.highlightstrokecolor = this.color_array[i];
            this.myAtts.name = this.label_array[i];
            this.myAtts.label = {
                offset: [10, 0],
                strokeColor: this.color_array[i],
                strokeWidth: this.myAtts.strokewidth
            };

            this.lines[i] = board.create(&#x27;line&#x27;, [
                [this.coords.usrCoords[1], this.coords.usrCoords[2] - i * offy],
                [this.coords.usrCoords[1] + line_length, this.coords.usrCoords[2] - i * offy]],
                this.myAtts);

            this.lines[i].getLabelAnchor = getLabelAnchor;

        }
    };

    JXG.createLegend = function (board, parents, attributes) {
        //parents are coords of left top point of the legend
        var start_from = [0, 0];

        if (Type.exists(parents)) {
            if (parents.length === 2) {
                start_from = parents;
            }
        }

        return new JXG.Legend(board, start_from, attributes);
    };
    JXG.registerElement(&#x27;legend&#x27;, JXG.createLegend);

    return {
        Chart: JXG.Chart,
        Legend: JXG.Legend,
        createChart: JXG.createChart,
        createLegend: JXG.createLegend
    };
});

    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src/base/text.js - JSXGraph</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="../assets/js/jsxgraphcore.js"></script>
    <link rel="stylesheet" href="../assets/css/jsxgraph.css">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../assets/css/logo_blue.png" title="JSXGraph" width="117" height="52"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.99.4</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/Angle.html">Angle</a> </li>
                                <li><a href="../classes/Arc.html">Arc</a> </li>
                                <li><a href="../classes/Arrow.html">Arrow</a> </li>
                                <li><a href="../classes/Arrowparallel.html">Arrowparallel</a> </li>
                                <li><a href="../classes/Axis.html">Axis</a> </li>
                                <li><a href="../classes/Bisector.html">Bisector</a> </li>
                                <li><a href="../classes/Bisectorlines.html">Bisectorlines</a> </li>
                                <li><a href="../classes/Button.html">Button</a> </li>
                                <li><a href="../classes/Checkbox.html">Checkbox</a> </li>
                                <li><a href="../classes/Circle.html">Circle</a> </li>
                                <li><a href="../classes/Circumcenter.html">Circumcenter</a> </li>
                                <li><a href="../classes/Circumcircle.html">Circumcircle</a> </li>
                                <li><a href="../classes/CircumcircleArc.html">CircumcircleArc</a> </li>
                                <li><a href="../classes/CircumcircleSector.html">CircumcircleSector</a> </li>
                                <li><a href="../classes/Conic.html">Conic</a> </li>
                                <li><a href="../classes/Curve.html">Curve</a> </li>
                                <li><a href="../classes/Ellipse.html">Ellipse</a> </li>
                                <li><a href="../classes/EventEmitter.html">EventEmitter</a> </li>
                                <li><a href="../classes/Functiongraph.html">Functiongraph</a> </li>
                                <li><a href="../classes/Glider.html">Glider</a> </li>
                                <li><a href="../classes/Grid.html">Grid</a> </li>
                                <li><a href="../classes/Group.html">Group</a> </li>
                                <li><a href="../classes/Hatch.html">Hatch</a> </li>
                                <li><a href="../classes/Hyperbola.html">Hyperbola</a> </li>
                                <li><a href="../classes/Image.html">Image</a> </li>
                                <li><a href="../classes/Incenter.html">Incenter</a> </li>
                                <li><a href="../classes/Incircle.html">Incircle</a> </li>
                                <li><a href="../classes/Inequality.html">Inequality</a> </li>
                                <li><a href="../classes/Input.html">Input</a> </li>
                                <li><a href="../classes/Integral.html">Integral</a> </li>
                                <li><a href="../classes/Intersection.html">Intersection</a> </li>
                                <li><a href="../classes/JXG.html">JXG</a> </li>
                                <li><a href="../classes/JXG.AbstractRenderer.html">JXG.AbstractRenderer</a> </li>
                                <li><a href="../classes/JXG.Board.html">JXG.Board</a> </li>
                                <li><a href="../classes/JXG.C.html">JXG.C</a> </li>
                                <li><a href="../classes/JXG.CanvasRenderer.html">JXG.CanvasRenderer</a> </li>
                                <li><a href="../classes/JXG.Chart.html">JXG.Chart</a> </li>
                                <li><a href="../classes/JXG.Circle.html">JXG.Circle</a> </li>
                                <li><a href="../classes/JXG.Complex.html">JXG.Complex</a> </li>
                                <li><a href="../classes/JXG.Composition.html">JXG.Composition</a> </li>
                                <li><a href="../classes/JXG.Coords.html">JXG.Coords</a> </li>
                                <li><a href="../classes/JXG.CoordsElement.html">JXG.CoordsElement</a> </li>
                                <li><a href="../classes/JXG.Curve.html">JXG.Curve</a> </li>
                                <li><a href="../classes/JXG.GeometryElement.html">JXG.GeometryElement</a> </li>
                                <li><a href="../classes/JXG.Group.html">JXG.Group</a> </li>
                                <li><a href="../classes/JXG.Image.html">JXG.Image</a> </li>
                                <li><a href="../classes/JXG.JSXGraph.html">JXG.JSXGraph</a> </li>
                                <li><a href="../classes/JXG.Line.html">JXG.Line</a> </li>
                                <li><a href="../classes/JXG.Math.html">JXG.Math</a> </li>
                                <li><a href="../classes/JXG.Math.Geometry.html">JXG.Math.Geometry</a> </li>
                                <li><a href="../classes/JXG.Math.Numerics.html">JXG.Math.Numerics</a> </li>
                                <li><a href="../classes/JXG.Math.Poly.html">JXG.Math.Poly</a> </li>
                                <li><a href="../classes/JXG.Math.Poly.Monomial.html">JXG.Math.Poly.Monomial</a> </li>
                                <li><a href="../classes/JXG.Math.Poly.Polynomial.html">JXG.Math.Poly.Polynomial</a> </li>
                                <li><a href="../classes/JXG.Math.Poly.Ring.html">JXG.Math.Poly.Ring</a> </li>
                                <li><a href="../classes/JXG.Math.Quadtree.html">JXG.Math.Quadtree</a> </li>
                                <li><a href="../classes/JXG.Math.Statistics.html">JXG.Math.Statistics</a> </li>
                                <li><a href="../classes/JXG.Math.Symbolic.html">JXG.Math.Symbolic</a> </li>
                                <li><a href="../classes/JXG.NoRenderer.html">JXG.NoRenderer</a> </li>
                                <li><a href="../classes/JXG.Options.html">JXG.Options</a> </li>
                                <li><a href="../classes/JXG.Point.html">JXG.Point</a> </li>
                                <li><a href="../classes/JXG.Polygon.html">JXG.Polygon</a> </li>
                                <li><a href="../classes/JXG.SVGRenderer.html">JXG.SVGRenderer</a> </li>
                                <li><a href="../classes/JXG.Text.html">JXG.Text</a> </li>
                                <li><a href="../classes/JXG.Ticks.html">JXG.Ticks</a> </li>
                                <li><a href="../classes/JXG.Transformation.html">JXG.Transformation</a> </li>
                                <li><a href="../classes/JXG.Turtle.html">JXG.Turtle</a> </li>
                                <li><a href="../classes/JXG.Util.Base64.html">JXG.Util.Base64</a> </li>
                                <li><a href="../classes/JXG.Util.Unzip.html">JXG.Util.Unzip</a> </li>
                                <li><a href="../classes/JXG.VMLRenderer.html">JXG.VMLRenderer</a> </li>
                                <li><a href="../classes/Line.html">Line</a> </li>
                                <li><a href="../classes/Locus.html">Locus</a> </li>
                                <li><a href="../classes/MajorArc.html">MajorArc</a> </li>
                                <li><a href="../classes/Midpoint.html">Midpoint</a> </li>
                                <li><a href="../classes/MinorArc.html">MinorArc</a> </li>
                                <li><a href="../classes/MinorSector.html">MinorSector</a> </li>
                                <li><a href="../classes/Mirrorpoint.html">Mirrorpoint</a> </li>
                                <li><a href="../classes/NonReflexAngle.html">NonReflexAngle</a> </li>
                                <li><a href="../classes/Normal.html">Normal</a> </li>
                                <li><a href="../classes/Orthogonalprojection.html">Orthogonalprojection</a> </li>
                                <li><a href="../classes/OtherIntersection.html">OtherIntersection</a> </li>
                                <li><a href="../classes/Parabola.html">Parabola</a> </li>
                                <li><a href="../classes/Parallel.html">Parallel</a> </li>
                                <li><a href="../classes/Parallelpoint.html">Parallelpoint</a> </li>
                                <li><a href="../classes/Perpendicular.html">Perpendicular</a> </li>
                                <li><a href="../classes/PerpendicularPoint.html">PerpendicularPoint</a> </li>
                                <li><a href="../classes/PerpendicularSegment.html">PerpendicularSegment</a> </li>
                                <li><a href="../classes/Point.html">Point</a> </li>
                                <li><a href="../classes/PolarLine.html">PolarLine</a> </li>
                                <li><a href="../classes/PolePoint.html">PolePoint</a> </li>
                                <li><a href="../classes/Polygon.html">Polygon</a> </li>
                                <li><a href="../classes/RadicalAxis.html">RadicalAxis</a> </li>
                                <li><a href="../classes/Reflection.html">Reflection</a> </li>
                                <li><a href="../classes/ReflexAngle.html">ReflexAngle</a> </li>
                                <li><a href="../classes/registerReader.html">registerReader</a> </li>
                                <li><a href="../classes/RegularPolygon.html">RegularPolygon</a> </li>
                                <li><a href="../classes/Riemannsum.html">Riemannsum</a> </li>
                                <li><a href="../classes/Sector.html">Sector</a> </li>
                                <li><a href="../classes/Segment.html">Segment</a> </li>
                                <li><a href="../classes/Semicircle.html">Semicircle</a> </li>
                                <li><a href="../classes/Slider.html">Slider</a> </li>
                                <li><a href="../classes/Slopetriangle.html">Slopetriangle</a> </li>
                                <li><a href="../classes/Spline.html">Spline</a> </li>
                                <li><a href="../classes/Stepfunction.html">Stepfunction</a> </li>
                                <li><a href="../classes/Tangent.html">Tangent</a> </li>
                                <li><a href="../classes/Tapemeasure.html">Tapemeasure</a> </li>
                                <li><a href="../classes/Text.html">Text</a> </li>
                                <li><a href="../classes/Ticks.html">Ticks</a> </li>
                                <li><a href="../classes/Tracecurve.html">Tracecurve</a> </li>
                                <li><a href="../classes/Transformation.html">Transformation</a> </li>
                                <li><a href="../classes/Turtle.html">Turtle</a> </li>
                            </ul>
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="../modules/JXG.html">JXG</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: src/base/text.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/*
    Copyright 2008-2015
        Matthias Ehmann,
        Michael Gerhaeuser,
        Carsten Miller,
        Bianca Valentin,
        Alfred Wassermann,
        Peter Wilfahrt

    This file is part of JSXGraph.

    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.

    You can redistribute it and/or modify it under the terms of the

      * GNU Lesser General Public License as published by
        the Free Software Foundation, either version 3 of the License, or
        (at your option) any later version
      OR
      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT

    JSXGraph is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License and
    the MIT License along with JSXGraph. If not, see &lt;http://www.gnu.org/licenses/&gt;
    and &lt;http://opensource.org/licenses/MIT/&gt;.
 */


/*global JXG: true, define: true, window: true*/
/*jslint nomen: true, plusplus: true*/

/* depends:
 jxg
 base/constants
 base/coords
 base/element
 parser/geonext
 math/statistics
 utils/env
 utils/type
 */

/**
 * @fileoverview In this file the Text element is defined.
 */

define([
    &#x27;jxg&#x27;, &#x27;base/constants&#x27;, &#x27;base/coords&#x27;, &#x27;base/element&#x27;, &#x27;parser/geonext&#x27;, &#x27;math/statistics&#x27;,
    &#x27;utils/env&#x27;, &#x27;utils/type&#x27;, &#x27;math/math&#x27;, &#x27;base/coordselement&#x27;
], function (JXG, Const, Coords, GeometryElement, GeonextParser, Statistics, Env, Type, Mat, CoordsElement) {

    &quot;use strict&quot;;

    var priv = {
            HTMLSliderInputEventHandler: function () {
                this._val = parseFloat(this.rendNodeRange.value);
                this.rendNodeOut.value = this.rendNodeRange.value;
                this.board.update();
            }
        };

    /**
     * Construct and handle texts.
     * Creates a new text object. Do not use this constructor to create a text. Use {@link JXG.Board#create} with
     * type {@link Text} instead.
     *
     * The coordinates can be relative to the coordinates of an element
     * given in {@link JXG.Options#text.anchor}.
     *
     * MathJax, HTML and GEONExT syntax can be handled.
     *
     * @class JXG.Text
     * @extends JXG.CoordsElement
     * @param {string|JXG.Board} board The board the new text is drawn on.
     * @param {Array} coordinates An array with the user coordinates of the text.
     * @param {Object} attributes An object containing visual properties and optional a name and a id.
     * @param {string|function} content A string or a function returning a string.
     *
     */
    JXG.Text = function (board, coords, attributes, content) {
        this.constructor(board, attributes, Const.OBJECT_TYPE_TEXT, Const.OBJECT_CLASS_TEXT);

        /**
         * Anchor element which define the origin for the relative coordinates.
         * If defined the coordinates of the text are relative coordinates.
         * 
         * @property element
         * @type {JXG.CoordsElement}
         * @private
         */
        this.element = this.board.select(attributes.anchor);
        this.coordsConstructor(coords, this.visProp.islabel);

        /**
         * 
         * @property content
         * @type {String}
         * @private
         */
        this.content = &#x27;&#x27;;

        /**
         * 
         * @property plaintext
         * @type {String}
         * @private
         */
        this.plaintext = &#x27;&#x27;;
        this.plaintextOld = null;
        
        /**
         * 
         * @property orgText
         * @type {String}
         * @private
         */
        this.orgText = &#x27;&#x27;;

        this.needsSizeUpdate = false;
        
        /**
         * @property hiddenByParent
         * @type Boolean
         * @default false
         * @private
         */
        this.hiddenByParent = false;

        /**
         * Size of the text in screen view coordinates, i.e. pixel: [w, h].
         *
         * @property size
         * @type Array
         */
        this.size = [1.0, 1.0];
        this.id = this.board.setId(this, &#x27;T&#x27;);

        // Set text before drawing
        this._setUpdateText(content);
        this.updateText();

        this.board.renderer.drawText(this);
        this.board.finalizeAdding(this);

        if (typeof this.content === &#x27;string&#x27;) {
            this.notifyParents(this.content);
        }
        this.elType = &#x27;text&#x27;;

        this.methodMap = Type.deepCopy(this.methodMap, {
            setText: &#x27;setTextJessieCode&#x27;,
            // free: &#x27;free&#x27;,
            move: &#x27;setCoords&#x27;
        });
    };

    JXG.Text.prototype = new GeometryElement();
    Type.copyPrototypeMethods(JXG.Text, CoordsElement, &#x27;coordsConstructor&#x27;);

    JXG.extend(JXG.Text.prototype, /** @lends JXG.Text.prototype */ {
        /**
         * Test if the the screen coordinates (x,y) are in a small stripe
         * at the left side or at the right side of the text.
         * Sensitivity is set in this.board.options.precision.hasPoint.
         * If dragarea is set to &#x27;all&#x27; (default), tests if the the screen
         * coordinates (x,y) are in within the text boundary.
         * 
         * @method hasPoint
         * @private
         * @param {Number} x
         * @param {Number} y
         * @return {Boolean}
         */
        hasPoint: function (x, y) {
            var lft, rt, top, bot,
                r = this.board.options.precision.hasPoint;

            if (this.transformations.length &gt; 0) {
                /**
                 * Transform the mouse/touch coordinates
                 * back to the original position of the text.
                 */
                lft = Mat.matVecMult(Mat.inverse(this.board.renderer.joinTransforms(this, this.transformations)), [1, x, y]);
                x = lft[1];
                y = lft[2];
            }

            if (this.visProp.anchorx === &#x27;right&#x27;) {
                lft = this.coords.scrCoords[1] - this.size[0];
            } else if (this.visProp.anchorx === &#x27;middle&#x27;) {
                lft = this.coords.scrCoords[1] - 0.5 * this.size[0];
            } else {
                lft = this.coords.scrCoords[1];
            }
            rt = lft + this.size[0];

            if (this.visProp.anchory === &#x27;top&#x27;) {
                bot = this.coords.scrCoords[2] + this.size[1];
            } else if (this.visProp.anchory === &#x27;middle&#x27;) {
                bot = this.coords.scrCoords[2] + 0.5 * this.size[1];
            } else {
                bot = this.coords.scrCoords[2];
            }
            top = bot - this.size[1];

            if (this.visProp.dragarea === &#x27;all&#x27;) {
                return x &gt;= lft - r &amp;&amp; x &lt; rt + r &amp;&amp; y &gt;= top - r  &amp;&amp; y &lt;= bot + r;
            }

            return (y &gt;= top - r &amp;&amp; y &lt;= bot + r) &amp;&amp;
                ((x &gt;= lft - r  &amp;&amp; x &lt;= lft + 2 * r) ||
                (x &gt;= rt - 2 * r &amp;&amp; x &lt;= rt + r));
        },

        /**
         * This sets the updateText function of this element that depending on the type of text content passed.
         * Used by {@link JXG.Text#_setText} and {@link JXG.Text} constructor.
         * 
         * @method _setUpdateText
         * @param {String|Function|Number} text
         * @return {JXG.Text} Reference to the text object.
         * @chainable
         * @private
         */
        _setUpdateText: function (text) {
            var updateText;

            this.orgText = text;
            if (typeof text === &#x27;function&#x27;) {
                this.updateText = function () {
                    if (this.visProp.parse &amp;&amp; !this.visProp.usemathjax) {
                        this.plaintext = this.replaceSub(this.replaceSup(this.convertGeonext2CSS(text())));
                    } else {
                        this.plaintext = text();
                    }
                };
            } else if (Type.isString(text) &amp;&amp; !this.visProp.parse) {
                this.updateText = function () {
                    this.plaintext = text;
                };
            } else {
                if (Type.isNumber(text)) {
                    this.content = text.toFixed(this.visProp.digits);
                } else {
                    if (this.visProp.useasciimathml) {
                        // Convert via ASCIIMathML
                        this.content = &quot;&#x27;&#x60;&quot; + text + &quot;&#x60;&#x27;&quot;;
                    } else if (this.visProp.usemathjax) {
                        this.content = &quot;&#x27;&quot; + text + &quot;&#x27;&quot;;
                    } else {
                        // Converts GEONExT syntax into JavaScript string
                        // Short math is allowed
                        this.content = this.generateTerm(text, true);
                    }
                }
                updateText = this.board.jc.snippet(this.content, true, &#x27;&#x27;, false);
                this.updateText = function () {
                    this.plaintext = updateText();
                };
            }
            return this;
        },

        /**
         * Defines new content. This is used by {@link JXG.Text#setTextJessieCode} and {@link JXG.Text#setText}. This is required because
         * JessieCode needs to filter all Texts inserted into the DOM and thus has to replace setText by setTextJessieCode.
         * 
         * @method _setText
         * @param {String|Function|Number} text
         * @return {JXG.Text} Reference to the text object.
         * @chainable
         * @private
         */
        _setText: function (text) {
            this._setUpdateText(text);

            // First evaluation of the string.
            // We need this for display=&#x27;internal&#x27; and Canvas
            this.updateText();
            this.prepareUpdate().update().updateRenderer();

            // We do not call updateSize for the infobox to speed up rendering
            if (!this.board.infobox || this.id !== this.board.infobox.id) {
                this.updateSize();    // updateSize() is called at least once.
            }

            return this;
        },

        /**
         * Defines new content but converts &amp;lt; and &amp;gt; to HTML entities before updating the DOM.
         * 
         * @method setTextJessieCode
         * @param {String|function} text
         * @return {JXG.Text} Reference to the text object.
         * @chainable
         */
        setTextJessieCode: function (text) {
            var s;

            this.visProp.castext = text;

            if (typeof text === &#x27;function&#x27;) {
                s = function () {
                    return Type.sanitizeHTML(text());
                };
            } else {
                if (Type.isNumber(text)) {
                    s = text;
                } else {
                    s = Type.sanitizeHTML(text);
                }
            }

            return this._setText(s);
        },

        /**
         * Defines new content.
         * 
         * @method setText
         * @param {String|function} text
         * @return {JXG.Text} Reference to the text object.
         * @chainable
         */
        setText: function (text) {
            return this._setText(text);
        },

        /**
         * Recompute the width and the height of the text box.
         * Update array &#x60;this.size&#x60; with pixel values.
         * The result may differ from browser to browser
         * by some pixels.
         * In canvas an old IEs we use a very crude estimation of the dimensions of
         * the textbox.
         * In JSXGraph this.size is necessary for applying rotations in IE and
         * for aligning text.
         * 
         * @method updateSize
         * @return {JXG.Text} Reference to the text object.
         * @chainable
         */
        updateSize: function () {
            var tmp, s, that, node;

            if (!Env.isBrowser || this.board.renderer.type === &#x27;no&#x27;) {
                return this;
            }

            node = this.rendNode;

            /**
             * offsetWidth and offsetHeight seem to be supported for internal vml elements by IE10+ in IE8 mode.
             */
            if (this.visProp.display === &#x27;html&#x27; || this.board.renderer.type === &#x27;vml&#x27;) {
                if (JXG.exists(node.offsetWidth)) {
                    s = [node.offsetWidth, node.offsetHeight];
                    if (s[0] === 0 &amp;&amp; s[1] === 0) { // Some browsers need some time to set offsetWidth and offsetHeight
                        that = this;
                        window.setTimeout(function () {
                            that.size = [node.offsetWidth, node.offsetHeight];
                        }, 0);
                    } else {
                        this.size = s;
                    }
                } else {
                    this.size = this.crudeSizeEstimate();
                }
            } else if (this.visProp.display === &#x27;internal&#x27;) {
                if (this.board.renderer.type === &#x27;svg&#x27;) {
                    try {
                        tmp = node.getBBox();
                        this.size = [tmp.width, tmp.height];
                    } catch (e) {}
                } else if (this.board.renderer.type === &#x27;canvas&#x27;) {
                    this.size = this.crudeSizeEstimate();
                }
            }

            return this;
        },

        /**
         * A very crude estimation of the dimensions of the textbox in case nothing else is available.
         * 
         * @method crudeSizeEstimate
         * @return {Array}
         * @private
         */
        crudeSizeEstimate: function () {
            return [parseFloat(this.visProp.fontsize) * this.plaintext.length * 0.45, parseFloat(this.visProp.fontsize) * 0.9];
        },

        /**
         * Decode unicode entities into characters.
         * 
         * @method utf8_decode
         * @param {String} string
         * @return {String}
         */
        utf8_decode : function (string) {
            return string.replace(/&amp;#x(\w+);/g, function (m, p1) {
                return String.fromCharCode(parseInt(p1, 16));
            });
        },

        /**
         * Replace _{} by &amp;lt;sub&amp;gt;
         * 
         * @method replaceSub
         * @param {String} te String containing _{}.
         * @return {String} Given string with _{} replaced by &amp;lt;sub&amp;gt;.
         * @private
         */
        replaceSub: function (te) {
            if (!te.indexOf) {
                return te;
            }

            var j,
                i = te.indexOf(&#x27;_{&#x27;);

            // the regexp in here are not used for filtering but to provide some kind of sugar for label creation,
            // i.e. replacing _{...} with &lt;sub&gt;...&lt;/sub&gt;. What is passed would get out anyway.
            /*jslint regexp: true*/

            while (i &gt;= 0) {
                te = te.substr(0, i) + te.substr(i).replace(/_\{/, &#x27;&lt;sub&gt;&#x27;);
                j = te.substr(i).indexOf(&#x27;}&#x27;);
                if (j &gt;= 0) {
                    te = te.substr(0, j) + te.substr(j).replace(/\}/, &#x27;&lt;/sub&gt;&#x27;);
                }
                i = te.indexOf(&#x27;_{&#x27;);
            }

            i = te.indexOf(&#x27;_&#x27;);
            while (i &gt;= 0) {
                te = te.substr(0, i) + te.substr(i).replace(/_(.?)/, &#x27;&lt;sub&gt;$1&lt;/sub&gt;&#x27;);
                i = te.indexOf(&#x27;_&#x27;);
            }

            return te;
        },

        /**
         * Replace ^{} by &amp;lt;sup&amp;gt;
         * 
         * @method replaceSup
         * @param {String} te String containing ^{}.
         * @return {String} Given string with ^{} replaced by &amp;lt;sup&amp;gt;.
         * @private
         */
        replaceSup: function (te) {
            if (!te.indexOf) {
                return te;
            }

            var j,
                i = te.indexOf(&#x27;^{&#x27;);

            // the regexp in here are not used for filtering but to provide some kind of sugar for label creation,
            // i.e. replacing ^{...} with &lt;sup&gt;...&lt;/sup&gt;. What is passed would get out anyway.
            /*jslint regexp: true*/

            while (i &gt;= 0) {
                te = te.substr(0, i) + te.substr(i).replace(/\^\{/, &#x27;&lt;sup&gt;&#x27;);
                j = te.substr(i).indexOf(&#x27;}&#x27;);
                if (j &gt;= 0) {
                    te = te.substr(0, j) + te.substr(j).replace(/\}/, &#x27;&lt;/sup&gt;&#x27;);
                }
                i = te.indexOf(&#x27;^{&#x27;);
            }

            i = te.indexOf(&#x27;^&#x27;);
            while (i &gt;= 0) {
                te = te.substr(0, i) + te.substr(i).replace(/\^(.?)/, &#x27;&lt;sup&gt;$1&lt;/sup&gt;&#x27;);
                i = te.indexOf(&#x27;^&#x27;);
            }

            return te;
        },

        /**
         * Return the width of the text element.
         * 
         * @method getSize
         * @return {Array} [width, height] in pixel
         */
        getSize: function () {
            return this.size;
        },

        /**
         * Move the text to new coordinates.
         * 
         * @method setCoords
         * @param {number} x
         * @param {number} y
         * @return {JXG.Text} reference to the text object.
         * @chainable
         */
        setCoords: function (x, y) {
            var coordsAnchor, dx, dy;
            if (Type.isArray(x) &amp;&amp; x.length &gt; 1) {
                y = x[1];
                x = x[0];
            }

            if (this.visProp.islabel &amp;&amp; Type.exists(this.element)) {
                coordsAnchor = this.element.getLabelAnchor();
                dx = (x - coordsAnchor.usrCoords[1]) * this.board.unitX;
                dy = -(y - coordsAnchor.usrCoords[2]) * this.board.unitY;

                this.relativeCoords.setCoordinates(Const.COORDS_BY_SCREEN, [dx, dy]);
            } else {
                /*
                this.X = function () {
                    return x;
                };

                this.Y = function () {
                    return y;
                };
                */
                this.coords.setCoordinates(Const.COORDS_BY_USER, [x, y]);
            }

            // this should be a local update, otherwise there might be problems
            // with the tick update routine resulting in orphaned tick labels
            this.prepareUpdate().update().updateRenderer();

            return this;
        },

        // Documented in GeometryElement
        update: function (fromParent) {
            if (!this.needsUpdate) {
                return this;
            }

            this.updateCoords(fromParent);
            this.updateText();

            if (this.visProp.display === &#x27;internal&#x27;) {
                this.plaintext = this.utf8_decode(this.plaintext);
            }

            this.checkForSizeUpdate();
            if (this.needsSizeUpdate) {
                this.updateSize();
            }

            return this;
        },

        /**
         * Used to avoid updateSize() calls.
         * Called in &#x60;JXG.Text.update&#x60;.
         * If true it means that &#x60;this.update&#x60; has been called.
         * More tests for size changes are in &#x60;JXG.Renderer.updateTextStyle&#x60;. The latter tests
         * are one update off. But this should pose not too many problems, since
         * it affects fontSize and cssClass changes.
         *
         * @method checkForSizeUpdate
         * @return {JXG.Text} reference to the text object.
         * @chainable
         * @private
         */
        checkForSizeUpdate: function () {
            if (this.board.infobox &amp;&amp; this.id === this.board.infobox.id) {
                this.needsSizeUpdate = false;
            } else {
                // For some magic reason it is more efficient on the iPad to
                // call updateSize() for EVERY text element EVERY time.
                this.needsSizeUpdate = (this.plaintextOld !== this.plaintext);

                if (this.needsSizeUpdate) {
                    this.plaintextOld = this.plaintext;
                }
            }
            return this;

        },

        // Documented in GeometryElement
        updateRenderer: function () {
            return this.updateRendererGeneric(&#x27;updateText&#x27;);
        },

        /**
         * Converts shortened math syntax into correct syntax:  3x instead of 3*x or
         * (a+b)(3+1) instead of (a+b)*(3+1).
         *
         * @method expandShortMath
         * @private
         * @param{String} expr Math term
         * @return {String} expanded String
         */
        expandShortMath: function(expr) {
            var re = /([\)0-9\.])\s*([\(a-zA-Z_])/g;
            return expr.replace(re, &#x27;$1*$2&#x27;);
        },

        /**
         * Converts the GEONExT syntax of the &lt;value&gt; terms into JavaScript.
         * Also, all Objects whose name appears in the term are searched and
         * the text is added as child to these objects.
         *
         * @method generateTerm
         * @param{String} contentStr String to be parsed
         * @param{Boolean} [expand] Optional flag if shortened math syntax is allowed (e.g. 3x instead of 3*x).
         * @private
         * @see JXG.GeonextParser.geonext2JS.
         * @return {String} Plaintext String
         */
        generateTerm: function (contentStr, expand) {
            var res, term, i, j,
                plaintext = &#x27;&quot;&quot;&#x27;;

            // revert possible jc replacement
            contentStr = contentStr || &#x27;&#x27;;
            contentStr = contentStr.replace(/\r/g, &#x27;&#x27;);
            contentStr = contentStr.replace(/\n/g, &#x27;&#x27;);
            contentStr = contentStr.replace(/&quot;/g, &#x27;\&#x27;&#x27;);
            contentStr = contentStr.replace(/&#x27;/g, &quot;\\&#x27;&quot;);

            contentStr = contentStr.replace(/&amp;amp;arc;/g, &#x27;&amp;ang;&#x27;);
            contentStr = contentStr.replace(/&lt;arc\s*\/&gt;/g, &#x27;&amp;ang;&#x27;);
            contentStr = contentStr.replace(/&amp;lt;arc\s*\/&amp;gt;/g, &#x27;&amp;ang;&#x27;);
            contentStr = contentStr.replace(/&amp;lt;sqrt\s*\/&amp;gt;/g, &#x27;&amp;radic;&#x27;);

            contentStr = contentStr.replace(/&amp;lt;value&amp;gt;/g, &#x27;&lt;value&gt;&#x27;);
            contentStr = contentStr.replace(/&amp;lt;\/value&amp;gt;/g, &#x27;&lt;/value&gt;&#x27;);

            // Convert GEONExT syntax into  JavaScript syntax
            i = contentStr.indexOf(&#x27;&lt;value&gt;&#x27;);
            j = contentStr.indexOf(&#x27;&lt;/value&gt;&#x27;);
            if (i &gt;= 0) {
                while (i &gt;= 0) {
                    plaintext += &#x27; + &quot;&#x27; + this.replaceSub(this.replaceSup(contentStr.slice(0, i))) + &#x27;&quot;&#x27;;
                    term = contentStr.slice(i + 7, j);
                    term = term.replace(/\s+/g, &#x27;&#x27;); // Remove all whitespace
                    if (expand === true) {
                        term = this.expandShortMath(term);
                    }
                    res = GeonextParser.geonext2JS(term, this.board);
                    res = res.replace(/\\&quot;/g, &quot;&#x27;&quot;);
                    res = res.replace(/\\&#x27;/g, &quot;&#x27;&quot;);

                    // GEONExT-Hack: apply rounding once only.
                    if (res.indexOf(&#x27;toFixed&#x27;) &lt; 0) {
                        // output of a value tag
                        if (Type.isNumber((Type.bind(this.board.jc.snippet(res, true, &#x27;&#x27;, false), this))())) {
                            // may also be a string
                            plaintext += &#x27;+(&#x27; + res + &#x27;).toFixed(&#x27; + (this.visProp.digits) + &#x27;)&#x27;;
                        } else {
                            plaintext += &#x27;+(&#x27; + res + &#x27;)&#x27;;
                        }
                    } else {
                        plaintext += &#x27;+(&#x27; + res + &#x27;)&#x27;;
                    }

                    contentStr = contentStr.slice(j + 8);
                    i = contentStr.indexOf(&#x27;&lt;value&gt;&#x27;);
                    j = contentStr.indexOf(&#x27;&lt;/value&gt;&#x27;);
                }
            }

            plaintext += &#x27; + &quot;&#x27; + this.replaceSub(this.replaceSup(contentStr)) + &#x27;&quot;&#x27;;
            plaintext = this.convertGeonext2CSS(plaintext);

            // This should replace &amp;amp;pi; by &amp;pi;
            plaintext = plaintext.replace(/&amp;amp;/g, &#x27;&amp;&#x27;);
            plaintext = plaintext.replace(/&quot;/g, &quot;&#x27;&quot;);

            return plaintext;
        },

        /**
         * Converts the GEONExT tags &lt;overline&gt; and &lt;arrow&gt; to
         * HTML span tags with proper CSS formating.
         * 
         * @method convertGeonext2CSS
         * @return {String} Converted HTML text
         * @private
         * @see JXG.Text.generateTerm @see JXG.Text._setText
         */
        convertGeonext2CSS: function (s) {
            if (typeof s === &#x27;string&#x27;) {
                s = s.replace(/&lt;overline&gt;/g, &#x27;&lt;span style=text-decoration:overline&gt;&#x27;);
                s = s.replace(/&amp;lt;overline&amp;gt;/g, &#x27;&lt;span style=text-decoration:overline&gt;&#x27;);
                s = s.replace(/&lt;\/overline&gt;/g, &#x27;&lt;/span&gt;&#x27;);
                s = s.replace(/&amp;lt;\/overline&amp;gt;/g, &#x27;&lt;/span&gt;&#x27;);
                s = s.replace(/&lt;arrow&gt;/g, &#x27;&lt;span style=text-decoration:overline&gt;&#x27;);
                s = s.replace(/&amp;lt;arrow&amp;gt;/g, &#x27;&lt;span style=text-decoration:overline&gt;&#x27;);
                s = s.replace(/&lt;\/arrow&gt;/g, &#x27;&lt;/span&gt;&#x27;);
                s = s.replace(/&amp;lt;\/arrow&amp;gt;/g, &#x27;&lt;/span&gt;&#x27;);
            }

            return s;
        },

        /**
         * Finds dependencies in a given term and notifies the parents by adding the
         * dependent object to the found objects child elements.
         * 
         * @method notifyParents
         * @param {String} content String containing dependencies for the given object.
         * @private
         * @return {JXG.Text} reference to the text object.
         * @chainable
         */
        notifyParents: function (content) {
            var search,
                res = null;

            // revert possible jc replacement
            content = content.replace(/&amp;lt;value&amp;gt;/g, &#x27;&lt;value&gt;&#x27;);
            content = content.replace(/&amp;lt;\/value&amp;gt;/g, &#x27;&lt;/value&gt;&#x27;);

            do {
                search = /&lt;value&gt;([\w\s\*\/\^\-\+\(\)\[\],&lt;&gt;=!]+)&lt;\/value&gt;/;
                res = search.exec(content);

                if (res !== null) {
                    GeonextParser.findDependencies(this, res[1], this.board);
                    content = content.substr(res.index);
                    content = content.replace(search, &#x27;&#x27;);
                }
            } while (res !== null);

            return this;
        },

        // documented in element.js
        getParents: function () {
            var p = [this.Z(), this.X(), this.Y(), this.orgText];

            if (this.parents.length !== 0) {
                p = this.parents;
            }

            return p;
        },

        // documented in element.js
        bounds: function () {
            var c = this.coords.usrCoords;

            if (this.visProp.islabel || this.board.unitY === 0 || this.board.unitX === 0) {
                return [0, 0, 0, 0];
            } else {
                return [c[1], c[2] + this.size[1] / this.board.unitY, c[1] + this.size[0] / this.board.unitX, c[2]];
            }
        }
    });

    /**
     * Construct and handle texts.
     *
     * The coordinates can be relative to the coordinates of an element
     * given in {@link JXG.Options#text.anchor}.
     *
     * MathJaX, HTML and GEONExT syntax can be handled.
     * @pseudo
     * @class Text
     * @extends JXG.Text
     * @constructor
     * @type JXG.Text
     *
     * @param {number,function_number,function_number,function_String,function} z_,x,y,str Parent elements for text elements.
     *   &lt;p&gt;
     *   Parent elements can be two or three elements of type number, a string containing a GEONE&lt;sub&gt;x&lt;/sub&gt;T
     *   constraint, or a function which takes no parameter and returns a number. Every parent element determines one coordinate. If a coordinate is
     *   given by a number, the number determines the initial position of a free text. If given by a string or a function that coordinate will be constrained
     *   that means the user won&#x27;t be able to change the texts&#x27;s position directly by mouse because it will be calculated automatically depending on the string
     *   or the function&#x27;s return value. If two parent elements are given the coordinates will be interpreted as 2D affine Euclidean coordinates, if three such
     *   parent elements are given they will be interpreted as homogeneous coordinates.
     *   &lt;p&gt;
     *   The text to be displayed may be given as string or as function returning a string.
     *
     * There is the attribute &#x27;display&#x27; which takes the values &#x27;html&#x27; or &#x27;internal&#x27;. In case of &#x27;html&#x27; a HTML division tag is created to display
     * the text. In this case it is also possible to use ASCIIMathML. Incase of &#x27;internal&#x27;, a SVG or VML text element is used to display the text.
     * @see JXG.Text
     * @example
     * 
     *      // Create a fixed text at position [0,1].
     *      var t1 = board.create(&#x27;text&#x27;,[0,1,&quot;Hello World&quot;]);
     * &lt;div id=&quot;896013aa-f24e-4e83-ad50-7bc7df23f6b7&quot; style=&quot;width: 300px; height: 300px;&quot;&gt;&lt;/div&gt;
     * &lt;script type=&quot;text/javascript&quot;&gt;
     * (function(){
     *   var board = JXG.JSXGraph.initBoard(&#x27;896013aa-f24e-4e83-ad50-7bc7df23f6b7&#x27;, {boundingbox: [-3, 6, 5, -3], axis: true, showcopyright: false, shownavigation: false});
     *   var t1 = board.create(&#x27;text&#x27;,[0,1,&quot;Hello World&quot;]);
     * })();
     * &lt;/script&gt;
     * 
     * @example
     * 
     *      // Create a variable text at a variable position.
     *      var s = board.create(&#x27;slider&#x27;,[[0,4],[3,4],[-2,0,2]]);
     *      var txt = board.create(&#x27;text&#x27;,
     *                        [function(x){ return s.Value();}, 1,
     *                         function(){return &quot;The value of s is&quot;+s.Value().toFixed(2);}
     *                        ]
     *                     );
     * &lt;div id=&quot;5441da79-a48d-48e8-9e53-75594c384a1c&quot; style=&quot;width: 300px; height: 300px;&quot;&gt;&lt;/div&gt;
     * &lt;script type=&quot;text/javascript&quot;&gt;
     * (function(){
     *   var board = JXG.JSXGraph.initBoard(&#x27;5441da79-a48d-48e8-9e53-75594c384a1c&#x27;, {boundingbox: [-3, 6, 5, -3], axis: true, showcopyright: false, shownavigation: false});
     *   var s = board.create(&#x27;slider&#x27;,[[0,4],[3,4],[-2,0,2]]);
     *   var t2 = board.create(&#x27;text&#x27;,[function(x){ return s.Value();}, 1, function(){return &quot;The value of s is &quot;+s.Value().toFixed(2);}]);
     * })();
     * &lt;/script&gt;
     * 
     * @example
     * 
     *      // Create a text bound to the point A
     *      var p = board.create(&#x27;point&#x27;,[0, 1]),
     *      t = board.create(&#x27;text&#x27;,[0, -1,&quot;Hello World&quot;], {anchor: p});
     * 
     * &lt;div id=&quot;ff5a64b2-2b9a-11e5-8dd9-901b0e1b8723&quot; style=&quot;width: 300px; height: 300px;&quot;&gt;&lt;/div&gt;
     * &lt;script type=&quot;text/javascript&quot;&gt;
     * (function() {
     *  var board = JXG.JSXGraph.initBoard(&#x27;ff5a64b2-2b9a-11e5-8dd9-901b0e1b8723&#x27;,
     *   {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});
     *   var p = board.create(&#x27;point&#x27;,[0, 1]),
     *      t = board.create(&#x27;text&#x27;,[0, -1,&quot;Hello World&quot;], {anchor: p});
     * })();
     * &lt;/script&gt;
     *
     */
    JXG.createText = function (board, parents, attributes) {
        var t,
            attr = Type.copyAttributes(attributes, board.options, &#x27;text&#x27;),
            coords = parents.slice(0, -1),
            content = parents[parents.length - 1];

        // downwards compatibility
        attr.anchor = attr.parent || attr.anchor;
        t = CoordsElement.create(JXG.Text, board, coords, attr, content);

        if (!t) {
            throw new Error(&quot;JSXGraph: Can&#x27;t create text with parent types &#x27;&quot; +
                    (typeof parents[0]) + &quot;&#x27; and &#x27;&quot; + (typeof parents[1]) + &quot;&#x27;.&quot; +
                    &quot;\nPossible parent types: [x,y], [z,x,y], [element,transformation]&quot;);
        }

        if (Type.evaluate(attr.rotate) !== 0 &amp;&amp; attr.display === &#x27;internal&#x27;) {
            t.addRotation(Type.evaluate(attr.rotate));
        }

        return t;
    };

    JXG.registerElement(&#x27;text&#x27;, JXG.createText);

    /**
     * [[x,y], [w px, h px], [range]
     */
    JXG.createHTMLSlider = function (board, parents, attributes) {
        var t, par,
            attr = Type.copyAttributes(attributes, board.options, &#x27;htmlslider&#x27;);

        if (parents.length !== 2 || parents[0].length !== 2 || parents[1].length !== 3) {
            throw new Error(&quot;JSXGraph: Can&#x27;t create htmlslider with parent types &#x27;&quot; +
                (typeof parents[0]) + &quot;&#x27; and &#x27;&quot; + (typeof parents[1]) + &quot;&#x27;.&quot; +
                &quot;\nPossible parents are: [[x,y], [min, start, max]]&quot;);
        }

        // backwards compatibility
        attr.anchor = attr.parent || attr.anchor;
        attr.fixed = attr.fixed || true;

        par = [parents[0][0], parents[0][1],
            &#x27;&lt;form style=&quot;display:inline&quot;&gt;&#x27; +
            &#x27;&lt;input type=&quot;range&quot; /&gt;&lt;span&gt;&lt;/span&gt;&lt;input type=&quot;text&quot; /&gt;&#x27; +
            &#x27;&lt;/form&gt;&#x27;];

        t = JXG.createText(board, par, attr);
        t.type = Type.OBJECT_TYPE_HTMLSLIDER;

        t.rendNodeForm = t.rendNode.childNodes[0];
        t.rendNodeForm.id = t.rendNode.id + &#x27;_form&#x27;;

        t.rendNodeRange = t.rendNodeForm.childNodes[0];
        t.rendNodeRange.id = t.rendNode.id + &#x27;_range&#x27;;
        t.rendNodeRange.min = parents[1][0];
        t.rendNodeRange.max = parents[1][2];
        t.rendNodeRange.step = attr.step;
        t.rendNodeRange.value = parents[1][1];

        t.rendNodeLabel = t.rendNodeForm.childNodes[1];
        t.rendNodeLabel.id = t.rendNode.id + &#x27;_label&#x27;;

        if (attr.withlabel) {
            t.rendNodeLabel.innerHTML = t.name + &#x27;=&#x27;;
        }

        t.rendNodeOut = t.rendNodeForm.childNodes[2];
        t.rendNodeOut.id = t.rendNode.id + &#x27;_out&#x27;;
        t.rendNodeOut.value = parents[1][1];

        t.rendNodeRange.style.width = attr.widthrange + &#x27;px&#x27;;
        t.rendNodeRange.style.verticalAlign = &#x27;middle&#x27;;
        t.rendNodeOut.style.width = attr.widthout + &#x27;px&#x27;;

        t._val = parents[1][1];

        if (JXG.supportsVML()) {
            /*
            * OnChange event is used for IE browsers
            * The range element is supported since IE10
            */
            Env.addEvent(t.rendNodeForm, &#x27;change&#x27;, priv.HTMLSliderInputEventHandler, t);
        } else {
            /*
            * OnInput event is used for non-IE browsers
            */
            Env.addEvent(t.rendNodeForm, &#x27;input&#x27;, priv.HTMLSliderInputEventHandler, t);
        }

        t.Value = function () {
            return this._val;
        };

        return t;
    };

    JXG.registerElement(&#x27;htmlslider&#x27;, JXG.createHTMLSlider);

    return {
        Text: JXG.Text,
        createText: JXG.createText,
        createHTMLSlider: JXG.createHTMLSlider
    };
});

    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>

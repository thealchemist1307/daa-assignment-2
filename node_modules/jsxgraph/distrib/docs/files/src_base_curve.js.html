<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src/base/curve.js - JSXGraph</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="../assets/js/jsxgraphcore.js"></script>
    <link rel="stylesheet" href="../assets/css/jsxgraph.css">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../assets/css/logo_blue.png" title="JSXGraph" width="117" height="52"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.99.4</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/Angle.html">Angle</a> </li>
                                <li><a href="../classes/Arc.html">Arc</a> </li>
                                <li><a href="../classes/Arrow.html">Arrow</a> </li>
                                <li><a href="../classes/Arrowparallel.html">Arrowparallel</a> </li>
                                <li><a href="../classes/Axis.html">Axis</a> </li>
                                <li><a href="../classes/Bisector.html">Bisector</a> </li>
                                <li><a href="../classes/Bisectorlines.html">Bisectorlines</a> </li>
                                <li><a href="../classes/Button.html">Button</a> </li>
                                <li><a href="../classes/Checkbox.html">Checkbox</a> </li>
                                <li><a href="../classes/Circle.html">Circle</a> </li>
                                <li><a href="../classes/Circumcenter.html">Circumcenter</a> </li>
                                <li><a href="../classes/Circumcircle.html">Circumcircle</a> </li>
                                <li><a href="../classes/CircumcircleArc.html">CircumcircleArc</a> </li>
                                <li><a href="../classes/CircumcircleSector.html">CircumcircleSector</a> </li>
                                <li><a href="../classes/Conic.html">Conic</a> </li>
                                <li><a href="../classes/Curve.html">Curve</a> </li>
                                <li><a href="../classes/Ellipse.html">Ellipse</a> </li>
                                <li><a href="../classes/EventEmitter.html">EventEmitter</a> </li>
                                <li><a href="../classes/Functiongraph.html">Functiongraph</a> </li>
                                <li><a href="../classes/Glider.html">Glider</a> </li>
                                <li><a href="../classes/Grid.html">Grid</a> </li>
                                <li><a href="../classes/Group.html">Group</a> </li>
                                <li><a href="../classes/Hatch.html">Hatch</a> </li>
                                <li><a href="../classes/Hyperbola.html">Hyperbola</a> </li>
                                <li><a href="../classes/Image.html">Image</a> </li>
                                <li><a href="../classes/Incenter.html">Incenter</a> </li>
                                <li><a href="../classes/Incircle.html">Incircle</a> </li>
                                <li><a href="../classes/Inequality.html">Inequality</a> </li>
                                <li><a href="../classes/Input.html">Input</a> </li>
                                <li><a href="../classes/Integral.html">Integral</a> </li>
                                <li><a href="../classes/Intersection.html">Intersection</a> </li>
                                <li><a href="../classes/JXG.html">JXG</a> </li>
                                <li><a href="../classes/JXG.AbstractRenderer.html">JXG.AbstractRenderer</a> </li>
                                <li><a href="../classes/JXG.Board.html">JXG.Board</a> </li>
                                <li><a href="../classes/JXG.C.html">JXG.C</a> </li>
                                <li><a href="../classes/JXG.CanvasRenderer.html">JXG.CanvasRenderer</a> </li>
                                <li><a href="../classes/JXG.Chart.html">JXG.Chart</a> </li>
                                <li><a href="../classes/JXG.Circle.html">JXG.Circle</a> </li>
                                <li><a href="../classes/JXG.Complex.html">JXG.Complex</a> </li>
                                <li><a href="../classes/JXG.Composition.html">JXG.Composition</a> </li>
                                <li><a href="../classes/JXG.Coords.html">JXG.Coords</a> </li>
                                <li><a href="../classes/JXG.CoordsElement.html">JXG.CoordsElement</a> </li>
                                <li><a href="../classes/JXG.Curve.html">JXG.Curve</a> </li>
                                <li><a href="../classes/JXG.GeometryElement.html">JXG.GeometryElement</a> </li>
                                <li><a href="../classes/JXG.Group.html">JXG.Group</a> </li>
                                <li><a href="../classes/JXG.Image.html">JXG.Image</a> </li>
                                <li><a href="../classes/JXG.JSXGraph.html">JXG.JSXGraph</a> </li>
                                <li><a href="../classes/JXG.Line.html">JXG.Line</a> </li>
                                <li><a href="../classes/JXG.Math.html">JXG.Math</a> </li>
                                <li><a href="../classes/JXG.Math.Geometry.html">JXG.Math.Geometry</a> </li>
                                <li><a href="../classes/JXG.Math.Numerics.html">JXG.Math.Numerics</a> </li>
                                <li><a href="../classes/JXG.Math.Poly.html">JXG.Math.Poly</a> </li>
                                <li><a href="../classes/JXG.Math.Poly.Monomial.html">JXG.Math.Poly.Monomial</a> </li>
                                <li><a href="../classes/JXG.Math.Poly.Polynomial.html">JXG.Math.Poly.Polynomial</a> </li>
                                <li><a href="../classes/JXG.Math.Poly.Ring.html">JXG.Math.Poly.Ring</a> </li>
                                <li><a href="../classes/JXG.Math.Quadtree.html">JXG.Math.Quadtree</a> </li>
                                <li><a href="../classes/JXG.Math.Statistics.html">JXG.Math.Statistics</a> </li>
                                <li><a href="../classes/JXG.Math.Symbolic.html">JXG.Math.Symbolic</a> </li>
                                <li><a href="../classes/JXG.NoRenderer.html">JXG.NoRenderer</a> </li>
                                <li><a href="../classes/JXG.Options.html">JXG.Options</a> </li>
                                <li><a href="../classes/JXG.Point.html">JXG.Point</a> </li>
                                <li><a href="../classes/JXG.Polygon.html">JXG.Polygon</a> </li>
                                <li><a href="../classes/JXG.SVGRenderer.html">JXG.SVGRenderer</a> </li>
                                <li><a href="../classes/JXG.Text.html">JXG.Text</a> </li>
                                <li><a href="../classes/JXG.Ticks.html">JXG.Ticks</a> </li>
                                <li><a href="../classes/JXG.Transformation.html">JXG.Transformation</a> </li>
                                <li><a href="../classes/JXG.Turtle.html">JXG.Turtle</a> </li>
                                <li><a href="../classes/JXG.Util.Base64.html">JXG.Util.Base64</a> </li>
                                <li><a href="../classes/JXG.Util.Unzip.html">JXG.Util.Unzip</a> </li>
                                <li><a href="../classes/JXG.VMLRenderer.html">JXG.VMLRenderer</a> </li>
                                <li><a href="../classes/Line.html">Line</a> </li>
                                <li><a href="../classes/Locus.html">Locus</a> </li>
                                <li><a href="../classes/MajorArc.html">MajorArc</a> </li>
                                <li><a href="../classes/Midpoint.html">Midpoint</a> </li>
                                <li><a href="../classes/MinorArc.html">MinorArc</a> </li>
                                <li><a href="../classes/MinorSector.html">MinorSector</a> </li>
                                <li><a href="../classes/Mirrorpoint.html">Mirrorpoint</a> </li>
                                <li><a href="../classes/NonReflexAngle.html">NonReflexAngle</a> </li>
                                <li><a href="../classes/Normal.html">Normal</a> </li>
                                <li><a href="../classes/Orthogonalprojection.html">Orthogonalprojection</a> </li>
                                <li><a href="../classes/OtherIntersection.html">OtherIntersection</a> </li>
                                <li><a href="../classes/Parabola.html">Parabola</a> </li>
                                <li><a href="../classes/Parallel.html">Parallel</a> </li>
                                <li><a href="../classes/Parallelpoint.html">Parallelpoint</a> </li>
                                <li><a href="../classes/Perpendicular.html">Perpendicular</a> </li>
                                <li><a href="../classes/PerpendicularPoint.html">PerpendicularPoint</a> </li>
                                <li><a href="../classes/PerpendicularSegment.html">PerpendicularSegment</a> </li>
                                <li><a href="../classes/Point.html">Point</a> </li>
                                <li><a href="../classes/PolarLine.html">PolarLine</a> </li>
                                <li><a href="../classes/PolePoint.html">PolePoint</a> </li>
                                <li><a href="../classes/Polygon.html">Polygon</a> </li>
                                <li><a href="../classes/RadicalAxis.html">RadicalAxis</a> </li>
                                <li><a href="../classes/Reflection.html">Reflection</a> </li>
                                <li><a href="../classes/ReflexAngle.html">ReflexAngle</a> </li>
                                <li><a href="../classes/registerReader.html">registerReader</a> </li>
                                <li><a href="../classes/RegularPolygon.html">RegularPolygon</a> </li>
                                <li><a href="../classes/Riemannsum.html">Riemannsum</a> </li>
                                <li><a href="../classes/Sector.html">Sector</a> </li>
                                <li><a href="../classes/Segment.html">Segment</a> </li>
                                <li><a href="../classes/Semicircle.html">Semicircle</a> </li>
                                <li><a href="../classes/Slider.html">Slider</a> </li>
                                <li><a href="../classes/Slopetriangle.html">Slopetriangle</a> </li>
                                <li><a href="../classes/Spline.html">Spline</a> </li>
                                <li><a href="../classes/Stepfunction.html">Stepfunction</a> </li>
                                <li><a href="../classes/Tangent.html">Tangent</a> </li>
                                <li><a href="../classes/Tapemeasure.html">Tapemeasure</a> </li>
                                <li><a href="../classes/Text.html">Text</a> </li>
                                <li><a href="../classes/Ticks.html">Ticks</a> </li>
                                <li><a href="../classes/Tracecurve.html">Tracecurve</a> </li>
                                <li><a href="../classes/Transformation.html">Transformation</a> </li>
                                <li><a href="../classes/Turtle.html">Turtle</a> </li>
                            </ul>
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="../modules/JXG.html">JXG</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: src/base/curve.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/*
    Copyright 2008-2015
        Matthias Ehmann,
        Michael Gerhaeuser,
        Carsten Miller,
        Bianca Valentin,
        Alfred Wassermann,
        Peter Wilfahrt

    This file is part of JSXGraph.

    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.

    You can redistribute it and/or modify it under the terms of the

      * GNU Lesser General Public License as published by
        the Free Software Foundation, either version 3 of the License, or
        (at your option) any later version
      OR
      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT

    JSXGraph is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License and
    the MIT License along with JSXGraph. If not, see &lt;http://www.gnu.org/licenses/&gt;
    and &lt;http://opensource.org/licenses/MIT/&gt;.
 */


/*global JXG: true, define: true*/
/*jslint nomen: true, plusplus: true*/

/* depends:
 jxg
 base/constants
 base/coords
 base/element
 math/math
 math/geometry
 math/statistics
 math/numerics
 parser/geonext
 utils/type
  elements:
   transform
 */

/*
 * @fileoverview In this file the geometry element Curve is defined.
 */

define([
    &#x27;jxg&#x27;, &#x27;base/constants&#x27;, &#x27;base/coords&#x27;, &#x27;base/element&#x27;, &#x27;math/math&#x27;, &#x27;math/statistics&#x27;, &#x27;math/numerics&#x27;,
    &#x27;math/geometry&#x27;, &#x27;parser/geonext&#x27;, &#x27;utils/type&#x27;, &#x27;base/transformation&#x27;, &#x27;math/qdt&#x27;
], function (JXG, Const, Coords, GeometryElement, Mat, Statistics, Numerics, Geometry, GeonextParser, Type, Transform, QDT) {

    &quot;use strict&quot;;

    /**
     *
     * Creates a new curve object. Do not use this constructor to create a curve. Use {@link JXG.Board#create} with
     * Curves are the common object for function graphs, parametric curves, polar curves, and data plots.
     * Use type {@link Curve}, or {@link Functiongraph} instead.
     *
     * @class JXG.Curve
     * @extends JXG.GeometryElement
     * @param {String|JXG.Board} board The board the new curve is drawn on.
     * @param {Array} parents defining terms An array with the functon terms or the data points of the curve.
     * @param {Object} attributes Defines the visual appearance of the curve.
     * @see JXG.Board#generateName
     * @see JXG.Board#addCurve
     */
    JXG.Curve = function (board, parents, attributes) {
        this.constructor(board, attributes, Const.OBJECT_TYPE_CURVE, Const.OBJECT_CLASS_CURVE);

        this.points = [];
        /**
         * Number of points on curves when plotted with &#x60;updateParametricCurveNaive&#x60;.
         * This value changes between the attribute values &#x60;numberPointsLow&#x60; and &#x60;numberPointsHigh&#x60;.
         * The first value is taken during drag events, the latter one is taken in the up event.
         * It is set in {@link JXG.Curve#updateCurve}.
         *
         * @property numberPoints
         * @type Number
         */
        this.numberPoints = this.visProp.numberpointshigh;

        this.bezierDegree = 1;

        this.dataX = null;
        this.dataY = null;

        /**
         * Stores a quad tree if it is required. The quad tree is generated in the curve
         * updates and can be used to speed up the hasPoint method.
         *
         * @property qdt
         * @type {JXG.Math.Quadtree}
         */
        this.qdt = null;

        if (Type.exists(parents[0])) {
            this.varname = parents[0];
        } else {
            this.varname = &#x27;x&#x27;;
        }

        // function graphs: &quot;x&quot;
        this.xterm = parents[1];
        // function graphs: e.g. &quot;x^2&quot;
        this.yterm = parents[2];

        // Converts GEONExT syntax into JavaScript syntax
        this.generateTerm(this.varname, this.xterm, this.yterm, parents[3], parents[4]);
        // First evaluation of the curve
        this.updateCurve();

        this.id = this.board.setId(this, &#x27;G&#x27;);
        this.board.renderer.drawCurve(this);

        this.board.finalizeAdding(this);

        this.createGradient();
        this.elType = &#x27;curve&#x27;;
        this.createLabel();

        if (typeof this.xterm === &#x27;string&#x27;) {
            this.notifyParents(this.xterm);
        }
        if (typeof this.yterm === &#x27;string&#x27;) {
            this.notifyParents(this.yterm);
        }

        this.methodMap = Type.deepCopy(this.methodMap, {
            generateTerm: &#x27;generateTerm&#x27;,
            setTerm: &#x27;generateTerm&#x27;
        });
    };

    JXG.Curve.prototype = new GeometryElement();

    JXG.extend(JXG.Curve.prototype, /** @lends JXG.Curve.prototype */ {

        /**
         * Gives the default value of the left bound for the curve.
         * May be overwritten in {@link JXG.Curve#generateTerm}.
         *
         * @method minX
         * @return {Number} Left bound for the curve.
         */
        minX: function () {
            var leftCoords;

            if (this.visProp.curvetype === &#x27;polar&#x27;) {
                return 0;
            }

            leftCoords = new Coords(Const.COORDS_BY_SCREEN, [0, 0], this.board, false);
            return leftCoords.usrCoords[1];
        },

        /**
         * Gives the default value of the right bound for the curve.
         * May be overwritten in {@link JXG.Curve#generateTerm}.
         *
         * @method maxX
         * @return {Number} Right bound for the curve.
         */
        maxX: function () {
            var rightCoords;

            if (this.visProp.curvetype === &#x27;polar&#x27;) {
                return 2 * Math.PI;
            }
            rightCoords = new Coords(Const.COORDS_BY_SCREEN, [this.board.canvasWidth, 0], this.board, false);

            return rightCoords.usrCoords[1];
        },

        /**
         * Treat the curve as curve with homogeneous coordinates.
         *
         * @method Z
         * @param {Number} t A number between 0.0 and 1.0.
         * @return {Number} Always 1.0
         */
        Z: function (t) {
            return 1;
        },

        /**
         * Checks whether (x,y) is near the curve.
         *
         * @method hasPoint
         * @param {Number} x Coordinate in x direction, screen coordinates.
         * @param {Number} y Coordinate in y direction, screen coordinates.
         * @param {Number} start Optional start index for search on data plots.
         * @return {Boolean} True if (x,y) is near the curve, False otherwise.
         */
        hasPoint: function (x, y, start) {
            var t, checkPoint, len, invMat, c,
                i, j, tX, tY, res, points, qdt,
                steps = this.visProp.numberpointslow,
                d = (this.maxX() - this.minX()) / steps,
                prec = this.board.options.precision.hasPoint / this.board.unitX,
                dist = Infinity,
                suspendUpdate = true;

            checkPoint = new Coords(Const.COORDS_BY_SCREEN, [x, y], this.board, false);
            x = checkPoint.usrCoords[1];
            y = checkPoint.usrCoords[2];

            if (this.transformations.length &gt; 0) {
                /*
                 * Transform the mouse/touch coordinates
                 * back to the original position of the curve.
                 */
                this.updateTransformMatrix();
                invMat = Mat.inverse(this.transformMat);
                c = Mat.matVecMult(invMat, [1, x, y]);
                x = c[1];
                y = c[2];
            }

            if (this.visProp.curvetype === &#x27;parameter&#x27; ||
                    this.visProp.curvetype === &#x27;polar&#x27;) {

                prec = prec * prec;

                // Brute force search for a point on the curve close to the mouse pointer
                for (i = 0, t = this.minX(); i &lt; steps; i++) {
                    tX = this.X(t, suspendUpdate);
                    tY = this.Y(t, suspendUpdate);

                    dist = (x - tX) * (x - tX) + (y - tY) * (y - tY);

                    if (dist &lt; prec) {
                        return true;
                    }

                    t += d;
                }
            } else if (this.visProp.curvetype === &#x27;plot&#x27; ||
                    this.visProp.curvetype === &#x27;functiongraph&#x27;) {

                if (!Type.exists(start) || start &lt; 0) {
                    start = 0;
                }

                if (Type.exists(this.qdt) &amp;&amp; this.visProp.useqdt &amp;&amp; this.bezierDegree !== 3) {
                    qdt = this.qdt.query(new Coords(Const.COORDS_BY_USER, [x, y], this.board));
                    points = qdt.points;
                    len = points.length;
                } else {
                    points = this.points;
                    len = this.numberPoints - 1;
                }

                for (i = start; i &lt; len; i++) {
                    res = [];
                    if (this.bezierDegree === 3) {
                        res.push(Geometry.projectCoordsToBeziersegment([1, x, y], this, i));
                    } else {
                        if (qdt) {
                            if (points[i].prev) {
                                res.push(Geometry.projectCoordsToSegment(
                                    [1, x, y],
                                    points[i].prev.usrCoords,
                                    points[i].usrCoords
                                ));
                            }

                            // If the next point in the array is the same as the current points
                            // next neighbor we don&#x27;t have to project it onto that segment because
                            // that will already be done in the next iteration of this loop.
                            if (points[i].next &amp;&amp; points[i + 1] !== points[i].next) {
                                res.push(Geometry.projectCoordsToSegment(
                                    [1, x, y],
                                    points[i].usrCoords,
                                    points[i].next.usrCoords
                                ));
                            }
                        } else {
                            res.push(Geometry.projectCoordsToSegment(
                                [1, x, y],
                                points[i].usrCoords,
                                points[i + 1].usrCoords
                            ));
                        }
                    }

                    for (j = 0; j &lt; res.length; j++) {
                        if (res[j][1] &gt;= 0 &amp;&amp; res[j][1] &lt;= 1 &amp;&amp;
                                Geometry.distance([1, x, y], res[j][0], 3) &lt;= prec) {
                            return true;
                        }
                    }
                }
                return false;
            }
            return (dist &lt; prec);
        },

        /**
         * Allocate points in the Coords array this.points
         *
         * @method allocatePoints
         * @private
         * @chainable
         */
        allocatePoints: function () {
            var i, len;

            len = this.numberPoints;

            if (this.points.length &lt; this.numberPoints) {
                for (i = this.points.length; i &lt; len; i++) {
                    this.points[i] = new Coords(Const.COORDS_BY_USER, [0, 0], this.board, false);
                }
            }
            return this;
        },

        /**
         * Computes for equidistant points on the x-axis the values of the function
         *
         * @method update
         * @return {JXG.Curve} Reference to the curve object.
         * @chainable
         * @see JXG.Curve#updateCurve
         */
        update: function () {
            if (this.needsUpdate) {
                if (this.visProp.trace) {
                    this.cloneToBackground(true);
                }
                this.updateCurve();
            }

            return this;
        },

        // Documented in GeometryElement
        updateRenderer: function () {
            var wasReal;

            if (this.needsUpdate &amp;&amp; this.visProp.visible) {
                wasReal = this.isReal;

                this.checkReal();

                if (this.isReal || wasReal) {
                    this.board.renderer.updateCurve(this);
                }

                if (this.isReal) {
                    if (wasReal !== this.isReal) {
                        this.board.renderer.show(this);
                        if (this.hasLabel &amp;&amp; this.label.visProp.visible) {
                            this.board.renderer.show(this.label);
                        }
                    }
                } else {
                    if (wasReal !== this.isReal) {
                        this.board.renderer.hide(this);
                        if (this.hasLabel &amp;&amp; this.label.visProp.visible) {
                            this.board.renderer.hide(this.label);
                        }
                    }
                }

                // Update the label if visible.
                if (this.hasLabel &amp;&amp; Type.exists(this.label.visProp) &amp;&amp; this.label.visProp.visible) {
                    this.label.update();
                    this.board.renderer.updateText(this.label);
                }
            }
            this.needsUpdate = false;
            return this;
        },

        /**
         * For dynamic dat aplots, &#x60;updateDataArray&#x60; can be used to compute new entries
         * for the arrays &#x60;JXG.Curve#dataX&#x60; and &#x60;JXG.Curve#dataY&#x60;. It
         * is used in {@link JXG.Curve#updateCurve}. Default is an empty method, can
         * be overwritten by the user.
         *
         * @method updateDataArray
         *
         * @example
         * In this example the filled curve which shows the intersection of two polygons
         * is plotted. The curve is defined by the coordinates in &#x60;dataX&#x60; and &#x60;dataY&#x60;.
         *
         *     var i,
         *         board = JXG.JSXGraph.initBoard(&#x27;box&#x27;, {boundingbox: [-8,8,8,-8], axis: true}),
         *         pts1 = [[-2, 3], [-4, -3], [2, 0], [4, 4]],
         *         pts2 = [[-2, -3], [-4, 1], [0, 4], [5, 1]];
         *
         *     // Clipping polygon
         *     var pol = board.create(&#x27;polygon&#x27;, pts1,
         *                 {hasInnerPoints: true,
         *                  borders: {names: [&#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;]},
         *                  name:&#x27;Polygon1&#x27;, withLabel: true, visible: true,
         *                  fillColor: &#x27;yellow&#x27;});
         *
         *     // Polygon to be clipped
         *     var pol2 = board.create(&#x27;polygon&#x27;, pts2,
         *                 {hasInnerPoints: false,
         *                  borders: {names: [&#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;]},
         *                  name:&#x27;Polygon2&#x27;, withLabel: true, visible: true
         *                  });
         *
         *     var curve = board.create(&#x27;curve&#x27;, [[],[]], {fillColor: &#x27;blue&#x27;, fillOpacity: 0.4});
         *     curve.updateDataArray = function() {
         *         var mat = JXG.Math.transpose(pol.intersect(pol2));
         *
         *         if (mat.length == 3) {
         *             this.dataX = mat[1];
         *             this.dataY = mat[2];
         *         } else {
         *             this.dataX = [];
         *             this.dataY = [];
         *         }
         *
         *     };
         *
         *     board.update();
         *
         * &lt;div id=&quot;13a51406-3b65-11e5-8dd9-901b0e1b8723&quot; style=&quot;width: 300px; height: 300px;&quot;&gt;&lt;/div&gt;
         * &lt;script type=&quot;text/javascript&quot;&gt;
         *     (function() {
         *         var board = JXG.JSXGraph.initBoard(&#x27;13a51406-3b65-11e5-8dd9-901b0e1b8723&#x27;,
         *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});
         *         var i,
         *             pts1 = [[-2, 3], [-4, -3], [2, 0], [4, 4]],
         *             pts2 = [[-2, -3], [-4, 1], [0, 4], [5, 1]];
         *         // Clipping polygon
         *         var pol = board.create(&#x27;polygon&#x27;, pts1,
         *                     {hasInnerPoints: true,
         *                      borders: {names: [&#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;]},
         *                      name:&#x27;Polygon1&#x27;, withLabel: true, visible: true,
         *                      fillColor: &#x27;yellow&#x27;});
         *         // Polygon to be clipped
         *         var pol2 = board.create(&#x27;polygon&#x27;, pts2,
         *                     {hasInnerPoints: false,
         *                      borders: {names: [&#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;]},
         *                      name:&#x27;Polygon2&#x27;, withLabel: true, visible: true
         *                      });
         *         var curve = board.create(&#x27;curve&#x27;, [[],[]], {fillColor: &#x27;blue&#x27;, fillOpacity: 0.4});
         *         curve.updateDataArray = function() {
         *             var mat = JXG.Math.transpose(pol.intersect(pol2));
         *             if (mat.length == 3) {
         *                 this.dataX = mat[1];
         *                 this.dataY = mat[2];
         *             } else {
         *                 this.dataX = [];
         *                 this.dataY = [];
         *             }
         *         };
         *         board.update();
         *     })();
         * &lt;/script&gt;
         */
        updateDataArray: function () {
            // this used to return this, but we shouldn&#x27;t rely on the user to implement it.
        },

        /**
         * Computes the path of coordinates defining the curve. For this various
         * methods are used, depending whether the curve is defined by a data array
         * of by function terms.
         * If the mousemove event triggers this update, we use only few
         * points. Otherwise, e.g. on mouseup, many points are used.
         *
         * @method updateCurve
         * @chainable
         * @return {JXG.Curve} Reference to the curve object.
         */
        updateCurve: function () {
            var len, mi, ma, x, y, i,
                //t1, t2, l1,
                suspendUpdate = false;

            this.updateTransformMatrix();
            this.updateDataArray();
            mi = this.minX();
            ma = this.maxX();

            // Discrete data points
            // x-coordinates are in an array
            if (Type.exists(this.dataX)) {
                this.numberPoints = this.dataX.length;
                len = this.numberPoints;

                // It is possible, that the array length has increased.
                this.allocatePoints();

                for (i = 0; i &lt; len; i++) {
                    x = i;

                    // y-coordinates are in an array
                    if (Type.exists(this.dataY)) {
                        y = i;
                        // The last parameter prevents rounding in usr2screen().
                        this.points[i].setCoordinates(Const.COORDS_BY_USER, [this.dataX[i], this.dataY[i]], false);
                    } else {
                        // discrete x data, continuous y data
                        y = this.X(x);
                        // The last parameter prevents rounding in usr2screen().
                        this.points[i].setCoordinates(Const.COORDS_BY_USER, [this.dataX[i], this.Y(y, suspendUpdate)], false);
                    }

                    this.updateTransform(this.points[i]);
                    suspendUpdate = true;
                }
            // continuous x data
            } else {
                if (this.visProp.doadvancedplot) {
                    this.updateParametricCurve(mi, ma, len);
                } else if (this.visProp.doadvancedplotold) {
                    this.updateParametricCurveOld(mi, ma, len);
                } else {
                    if (this.board.updateQuality === this.board.BOARD_QUALITY_HIGH) {
                        this.numberPoints = this.visProp.numberpointshigh;
                    } else {
                        this.numberPoints = this.visProp.numberpointslow;
                    }

                    // It is possible, that the array length has increased.
                    this.allocatePoints();
                    this.updateParametricCurveNaive(mi, ma, this.numberPoints);
                }
                len = this.numberPoints;

                if (this.visProp.useqdt &amp;&amp; this.board.updateQuality === this.board.BOARD_QUALITY_HIGH) {
                    this.qdt = new QDT(this.board.getBoundingBox());
                    for (i = 0; i &lt; this.points.length; i++) {
                        this.qdt.insert(this.points[i]);

                        if (i &gt; 0) {
                            this.points[i].prev = this.points[i - 1];
                        }

                        if (i &lt; len - 1) {
                            this.points[i].next = this.points[i + 1];
                        }
                    }
                }

                for (i = 0; i &lt; len; i++) {
                    this.updateTransform(this.points[i]);
                }
            }

            if (this.visProp.curvetype !== &#x27;plot&#x27; &amp;&amp; this.visProp.rdpsmoothing) {
                this.points = Numerics.RamerDouglasPeucker(this.points, 0.2);
                this.numberPoints = this.points.length;
            }

            return this;
        },

        /**
         * Update the transfomration matrices bound to this curve.
         *
         * @method updateTransformMatrix
         * @private
         * @return {JXG.Curve} Reference to the curve object.
         * @chainable
         */
        updateTransformMatrix: function () {
            var t, c, i,
                len = this.transformations.length;

            this.transformMat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]];

            for (i = 0; i &lt; len; i++) {
                t = this.transformations[i];
                t.update();
                this.transformMat = Mat.matMatMult(t.matrix, this.transformMat);
            }

            return this;
        },

        /**
         * Check if at least one point on the curve is finite and real and
         * sets the property &#x60;isReal&#x60;.
         *
         * @method checkReal
         * @private
         * @return {JXG.Curve} Reference to the curve object.
         * @chainable
         **/
        checkReal: function () {
            var b = false, i, p,
                len = this.numberPoints;

            for (i = 0; i &lt; len; i++) {
                p = this.points[i].usrCoords;
                if (!isNaN(p[1]) &amp;&amp; !isNaN(p[2]) &amp;&amp; Math.abs(p[0]) &gt; Mat.eps) {
                    b = true;
                    break;
                }
            }
            this.isReal = b;
            return this;
        },

        /**
         * Updates the data points of a parametric curve using a fixed set of equidistant points.
         * This version is used if {@link JXG.Curve#doadvancedplot} is &lt;tt&gt;false&lt;/tt&gt;.
         *
         * @method updateParametricCurveNaive
         * @param {Number} mi Left bound of curve
         * @param {Number} ma Right bound of curve
         * @param {Number} len Number of data points
         * @return {JXG.Curve} Reference to the curve object.
         * @chainable
         */
        updateParametricCurveNaive: function (mi, ma, len) {
            var i, t,
                suspendUpdate = false,
                stepSize = (ma - mi) / len;

            for (i = 0; i &lt; len; i++) {
                t = mi + i * stepSize;
                // The last parameter prevents rounding in usr2screen().
                this.points[i].setCoordinates(Const.COORDS_BY_USER, [this.X(t, suspendUpdate), this.Y(t, suspendUpdate)], false);
                suspendUpdate = true;
            }
            return this;
        },

        /**
         * Updates the data points of a parametric curve. This version is used if {@link JXG.Curve#doadvancedplot} is &lt;tt&gt;true&lt;/tt&gt;.
         * Since 0.99 this algorithm is deprecated. It still can be used if {@link JXG.Curve#doadvancedplotold} is &lt;tt&gt;true&lt;/tt&gt;.
         *
         * @method updateParametricCurveOld
         * @deprecated
         * @param {Number} mi Left bound of curve
         * @param {Number} ma Right bound of curve
         * @return {JXG.Curve} Reference to the curve object.
         * @chainable
         */
        updateParametricCurveOld: function (mi, ma) {
            var i, t, t0, d,
                x, y, x0, y0, top, depth,
                MAX_DEPTH, MAX_XDIST, MAX_YDIST,
                suspendUpdate = false,
                po = new Coords(Const.COORDS_BY_USER, [0, 0], this.board, false),
                dyadicStack = [],
                depthStack = [],
                pointStack = [],
                divisors = [],
                distOK = false,
                j = 0,
                distFromLine = function (p1, p2, p0) {
                    var lbda, d,
                        x0 = p0[1] - p1[1],
                        y0 = p0[2] - p1[2],
                        x1 = p2[0] - p1[1],
                        y1 = p2[1] - p1[2],
                        den = x1 * x1 + y1 * y1;

                    if (den &gt;= Mat.eps) {
                        lbda = (x0 * x1 + y0 * y1) / den;
                        if (lbda &gt; 0) {
                            if (lbda &lt;= 1) {
                                x0 -= lbda * x1;
                                y0 -= lbda * y1;
                            // lbda = 1.0;
                            } else {
                                x0 -= x1;
                                y0 -= y1;
                            }
                        }
                    }
                    d = x0 * x0 + y0 * y0;
                    return Math.sqrt(d);
                };

            JXG.deprecated(&#x27;Curve.updateParametricCurveOld()&#x27;);

            if (this.board.updateQuality === this.board.BOARD_QUALITY_LOW) {
                MAX_DEPTH = 15;
                MAX_XDIST = 10; // 10
                MAX_YDIST = 10; // 10
            } else {
                MAX_DEPTH = 21;
                MAX_XDIST = 0.7; // 0.7
                MAX_YDIST = 0.7; // 0.7
            }

            divisors[0] = ma - mi;
            for (i = 1; i &lt; MAX_DEPTH; i++) {
                divisors[i] = divisors[i - 1] * 0.5;
            }

            i = 1;
            dyadicStack[0] = 1;
            depthStack[0] = 0;

            t = mi;
            po.setCoordinates(Const.COORDS_BY_USER, [this.X(t, suspendUpdate), this.Y(t, suspendUpdate)], false);

            // Now, there was a first call to the functions defining the curve.
            // Defining elements like sliders have been evaluated.
            // Therefore, we can set suspendUpdate to false, so that these defining elements
            // need not be evaluated anymore for the rest of the plotting.
            suspendUpdate = true;
            x0 = po.scrCoords[1];
            y0 = po.scrCoords[2];
            t0 = t;

            t = ma;
            po.setCoordinates(Const.COORDS_BY_USER, [this.X(t, suspendUpdate), this.Y(t, suspendUpdate)], false);
            x = po.scrCoords[1];
            y = po.scrCoords[2];

            pointStack[0] = [x, y];

            top = 1;
            depth = 0;

            this.points = [];
            this.points[j++] = new Coords(Const.COORDS_BY_SCREEN, [x0, y0], this.board, false);

            do {
                distOK = this.isDistOK(x - x0, y - y0, MAX_XDIST, MAX_YDIST) || this.isSegmentOutside(x0, y0, x, y);
                while (depth &lt; MAX_DEPTH &amp;&amp; (!distOK || depth &lt; 6) &amp;&amp; (depth &lt;= 7 || this.isSegmentDefined(x0, y0, x, y))) {
                    // We jump out of the loop if
                    // * depth&gt;=MAX_DEPTH or
                    // * (depth&gt;=6 and distOK) or
                    // * (depth&gt;7 and segment is not defined)

                    dyadicStack[top] = i;
                    depthStack[top] = depth;
                    pointStack[top] = [x, y];
                    top += 1;

                    i = 2 * i - 1;
                    // Here, depth is increased and may reach MAX_DEPTH
                    depth++;
                    // In that case, t is undefined and we will see a jump in the curve.
                    t = mi + i * divisors[depth];

                    po.setCoordinates(Const.COORDS_BY_USER, [this.X(t, suspendUpdate), this.Y(t, suspendUpdate)], false, true);
                    x = po.scrCoords[1];
                    y = po.scrCoords[2];
                    distOK = this.isDistOK(x - x0, y - y0, MAX_XDIST, MAX_YDIST) || this.isSegmentOutside(x0, y0, x, y);
                }

                if (j &gt; 1) {
                    d = distFromLine(this.points[j - 2].scrCoords, [x, y], this.points[j - 1].scrCoords);
                    if (d &lt; 0.015) {
                        j -= 1;
                    }
                }

                this.points[j] = new Coords(Const.COORDS_BY_SCREEN, [x, y], this.board, false);
                j += 1;

                x0 = x;
                y0 = y;
                t0 = t;

                top -= 1;
                x = pointStack[top][0];
                y = pointStack[top][1];
                depth = depthStack[top] + 1;
                i = dyadicStack[top] * 2;

            } while (top &gt; 0 &amp;&amp; j &lt; 500000);

            this.numberPoints = this.points.length;

            return this;
        },

        /**
         * Crude and cheap test if the segment defined by the two points &lt;tt&gt;(x0, y0)&lt;/tt&gt; and &lt;tt&gt;(x1, y1)&lt;/tt&gt; is
         * outside the viewport of the board. All parameters have to be given in screen coordinates.
         *
         * @method isSegmentOutside
         * @private
         * @param {Number} x0
         * @param {Number} y0
         * @param {Number} x1
         * @param {Number} y1
         * @return {Boolean} &lt;tt&gt;true&lt;/tt&gt; if the given segment is outside the visible area.
         */
        isSegmentOutside: function (x0, y0, x1, y1) {
            return (y0 &lt; 0 &amp;&amp; y1 &lt; 0) || (y0 &gt; this.board.canvasHeight &amp;&amp; y1 &gt; this.board.canvasHeight) ||
                (x0 &lt; 0 &amp;&amp; x1 &lt; 0) || (x0 &gt; this.board.canvasWidth &amp;&amp; x1 &gt; this.board.canvasWidth);
        },

        /**
         * Compares the absolute value of &lt;tt&gt;dx&lt;/tt&gt; with &lt;tt&gt;MAXX&lt;/tt&gt; and the absolute value of &lt;tt&gt;dy&lt;/tt&gt;
         * with &lt;tt&gt;MAXY&lt;/tt&gt;.
         *
         * @method isDistOK
         * @private
         * @param {Number} dx
         * @param {Number} dy
         * @param {Number} MAXX
         * @param {Number} MAXY
         * @return {Boolean} &lt;tt&gt;true&lt;/tt&gt;, if &lt;tt&gt;|dx| &amp;lt; MAXX&lt;/tt&gt; and &lt;tt&gt;|dy| &amp;lt; MAXY&lt;/tt&gt;.
         */
        isDistOK: function (dx, dy, MAXX, MAXY) {
            return (Math.abs(dx) &lt; MAXX &amp;&amp; Math.abs(dy) &lt; MAXY) &amp;&amp; !isNaN(dx + dy);
        },

         /**
          * @method isSegmentDefined
          * @private
         */
        isSegmentDefined: function (x0, y0, x1, y1) {
            return !(isNaN(x0 + y0) &amp;&amp; isNaN(x1 + y1));
        },

        /**
         * Add a point to the curve plot. If the new point is too close to the previously inserted point,
         * it is skipped.
         * Used in {@link JXG.Curve._plotRecursive}.
         *
         * @method _insertPoint
         * @private
         * @param {JXG.Coords} pnt Coords to add to the list of points
         */
        _insertPoint: function (pnt) {
            var lastReal = !isNaN(this._lastCrds[1] + this._lastCrds[2]),     // The last point was real
                newReal = !isNaN(pnt.scrCoords[1] + pnt.scrCoords[2]),        // New point is real point
                cw = this.board.canvasWidth,
                ch = this.board.canvasHeight,
                off = 20;

            newReal = newReal &amp;&amp;
                        (pnt.scrCoords[1] &gt; -off &amp;&amp; pnt.scrCoords[2] &gt; -off &amp;&amp;
                         pnt.scrCoords[1] &lt; cw + off &amp;&amp; pnt.scrCoords[2] &lt; ch + off);

            /*
             * Prevents two consecutive NaNs or points wich are too close
             */
            if ((!newReal &amp;&amp; lastReal) ||
                    (newReal &amp;&amp; (!lastReal ||
                        Math.abs(pnt.scrCoords[1] - this._lastCrds[1]) &gt; 0.7 ||
                        Math.abs(pnt.scrCoords[2] - this._lastCrds[2]) &gt; 0.7))) {
                this.points.push(pnt);
                this._lastCrds = pnt.copy(&#x27;scrCoords&#x27;);
            }
        },

        /**
         * Investigate a function term at the bounds of intervals where
         * the function is not defined, e.g. log(x) at x = 0.
         *
         * c is between a and b
         *
         * @method _borderCase
         * @private
         * @param {Array} a Screen coordinates of the left interval bound
         * @param {Array} b Screen coordinates of the right interval bound
         * @param {Array} c Screen coordinates of the bisection point at (ta + tb) / 2
         * @param {Number} ta Parameter which evaluates to a, i.e. [1, X(ta), Y(ta)] = a in screen coordinates
         * @param {Number} tb Parameter which evaluates to b, i.e. [1, X(tb), Y(tb)] = b in screen coordinates
         * @param {Number} tc (ta + tb) / 2 = tc. Parameter which evaluates to b, i.e. [1, X(tc), Y(tc)] = c in screen coordinates
         * @param {Number} depth Actual recursion depth. The recursion stops if depth is equal to 0.
         * @return {JXG.Boolean} true if the point is inserted and the recursion should stop, false otherwise.
         */
        _borderCase: function (a, b, c, ta, tb, tc, depth) {
            var t, pnt, p, p_good = null,
                i, j, maxit = 5,
                maxdepth = 70,
                is_undef = false;

            if (depth &lt; this.smoothLevel) {
                pnt = new Coords(Const.COORDS_BY_USER, [0, 0], this.board, false);

                if (isNaN(a[1] + a[2]) &amp;&amp; !isNaN(c[1] + c[2] + b[1] + b[2])) {
                    // a is outside of the definition interval, c and b are inside

                    for (i = 0; i &lt; maxdepth; ++i) {
                        j = 0;

                        // Bisect a and c until the new point is inside of the definition interval
                        do {
                            t = 0.5 * (ta + tc);
                            pnt.setCoordinates(Const.COORDS_BY_USER, [this.X(t, true), this.Y(t, true)], false);
                            p = pnt.scrCoords;
                            is_undef = isNaN(p[1] + p[2]);

                            if (is_undef) {
                                ta = t;
                            }
                            ++j;
                        } while (is_undef &amp;&amp; j &lt; maxit);

                        // If bisection was successful, remember this point
                        if (j &lt; maxit) {
                            tc = t;
                            p_good = p.slice();
                        } else {
                            break;
                        }
                    }
                } else if (isNaN(b[1] + b[2]) &amp;&amp; !isNaN(c[1] + c[2] + a[1] + a[2])) {
                    // b is outside of the definition interval, a and c are inside
                    for (i = 0; i &lt; maxdepth; ++i) {
                        j = 0;
                        do {
                            t = 0.5 * (tc + tb);
                            pnt.setCoordinates(Const.COORDS_BY_USER, [this.X(t, true), this.Y(t, true)], false);
                            p = pnt.scrCoords;
                            is_undef = isNaN(p[1] + p[2]);

                            if (is_undef) {
                                tb = t;
                            }
                            ++j;
                        } while (is_undef &amp;&amp; j &lt; maxit);
                        if (j &lt; maxit) {
                            tc = t;
                            p_good = p.slice();
                        } else {
                            break;
                        }
                    }
                }

                if (p_good !== null) {
                    this._insertPoint(new Coords(Const.COORDS_BY_SCREEN, p_good.slice(1), this.board, false));
                    return true;
                }
            }
            return false;
        },

        /**
         * Compute distances in screen coordinates between the points ab,
         * ac, cb, and cd, where d = (a + b)/2.
         * cd is used for the smoothness test, ab, ac, cb are used to detect jumps, cusps and poles.
         *
         * @method _triangleDists
         * @private
         * @param {Array} a Screen coordinates of the left interval bound
         * @param {Array} b Screen coordinates of the right interval bound
         * @param {Array} c Screen coordinates of the bisection point at (ta + tb) / 2
         * @return {Array} array of distances in screen coordinates between: ab, ac, cb, and cd.
         */
        _triangleDists: function (a, b, c) {
            var d, d_ab, d_ac, d_cb, d_cd;

            d = [a[0] * b[0], (a[1] + b[1]) * 0.5, (a[2] + b[2]) * 0.5];

            d_ab = Geometry.distance(a, b, 3);
            d_ac = Geometry.distance(a, c, 3);
            d_cb = Geometry.distance(c, b, 3);
            d_cd = Geometry.distance(c, d, 3);

            return [d_ab, d_ac, d_cb, d_cd];
        },

        /**
         * Test if the function is undefined on an interval:
         * If the interval borders a and b are undefined, 20 random values
         * are tested if they are undefined, too.
         * Only if all values are undefined, we declare the function to be undefined in this interval.
         *
         * @method _isUndefined
         * @private
         * @param {Array} a Screen coordinates of the left interval bound
         * @param {Number} ta Parameter which evaluates to a, i.e. [1, X(ta), Y(ta)] = a in screen coordinates
         * @param {Array} b Screen coordinates of the right interval bound
         * @param {Number} tb Parameter which evaluates to b, i.e. [1, X(tb), Y(tb)] = b in screen coordinates
         */
        _isUndefined: function (a, ta, b, tb) {
            var t, i, pnt;

            if (!isNaN(a[1] + a[2]) || !isNaN(b[1] + b[2])) {
                return false;
            }

            pnt = new Coords(Const.COORDS_BY_USER, [0, 0], this.board, false);

            for (i = 0; i &lt; 20; ++i) {
                t = ta + Math.random() * (tb - ta);
                pnt.setCoordinates(Const.COORDS_BY_USER, [this.X(t, true), this.Y(t, true)], false);
                if (!isNaN(pnt.scrCoords[0] + pnt.scrCoords[1] + pnt.scrCoords[2])) {
                    return false;
                }
            }

            return true;
        },

        /**
         * Determines if a segment is outside of the visible canvas (plus a certain border).
         *
         * @method _isOutside
         * @private
         * @param  {Number}  a  First point of the segement
         * @param  {Number}  ta Parameter of the curve for first point
         * @param  {Number}  b  Second point of the segment
         * @param  {Number}  tb Parameter of the curve for second point
         * @return {Boolean}   True if segment is visible.
         */
        _isOutside: function (a, ta, b, tb) {
            var off = 10,
                cw = this.board.canvasWidth,
                ch = this.board.canvasHeight;

            return !!((a[1] &lt; -off &amp;&amp; b[1] &lt; -off) ||
            (a[2] &lt; -off &amp;&amp; b[2] &lt; -off) ||
            (a[1] &gt; cw + off &amp;&amp; b[1] &gt; cw + off) ||
            (a[2] &gt; ch + off &amp;&amp; b[2] &gt; ch + off));
        },

        /**
         * Recursive interval bisection algorithm for curve plotting.
         * Used in {@link JXG.Curve.updateParametricCurve}.
         *
         * @method _plotRecursive
         * @private
         * @param {Array} a Screen coordinates of the left interval bound
         * @param {Number} ta Parameter which evaluates to a, i.e. [1, X(ta), Y(ta)] = a in screen coordinates
         * @param {Array} b Screen coordinates of the right interval bound
         * @param {Number} tb Parameter which evaluates to b, i.e. [1, X(tb), Y(tb)] = b in screen coordinates
         * @param {Number} depth Actual recursion depth. The recursion stops if depth is equal to 0.
         * @param {Number} delta If the distance of the bisection point at (ta + tb) / 2 from the point (a + b) / 2 is less then delta,
         *                 the segment [a,b] is regarded as straight line.
         * @return {JXG.Curve} Reference to the curve object.
         * @chainable
         */
        _plotRecursive: function (a, ta, b, tb, depth, delta) {
            var tc, c,
                ds, mindepth = 0,
                isSmooth, isJump, isCusp,
                cusp_threshold = 0.5,
                pnt = new Coords(Const.COORDS_BY_USER, [0, 0], this.board, false);

            if (this.numberPoints &gt; 65536) {
                return;
            }

            // Test if the function is undefined on an interval
            if (depth &lt; this.nanLevel &amp;&amp; this._isUndefined(a, ta, b, tb)) {
                return this;
            }

            if (depth &lt; this.nanLevel &amp;&amp; this._isOutside(a, ta, b, tb)) {
                return this;
            }

            tc = 0.5 * (ta  + tb);
            pnt.setCoordinates(Const.COORDS_BY_USER, [this.X(tc, true), this.Y(tc, true)], false);
            c = pnt.scrCoords;

            if (this._borderCase(a, b, c, ta, tb, tc, depth)) {
                return this;
            }

            ds = this._triangleDists(a, b, c);           // returns [d_ab, d_ac, d_cb, d_cd]
            isSmooth = (depth &lt; this.smoothLevel) &amp;&amp; (ds[3] &lt; delta);

            isJump = (depth &lt; this.jumpLevel) &amp;&amp;
                        ((ds[2] &gt; 0.99 * ds[0]) || (ds[1] &gt; 0.99 * ds[0]) ||
                        ds[0] === Infinity || ds[1] === Infinity || ds[2] === Infinity);
            isCusp = (depth &lt; this.smoothLevel + 2) &amp;&amp; (ds[0] &lt; cusp_threshold * (ds[1] + ds[2]));

            if (isCusp) {
                mindepth = 0;
                isSmooth = false;
            }

            --depth;

            if (isJump) {
                this._insertPoint(new Coords(Const.COORDS_BY_SCREEN, [NaN, NaN], this.board, false));
            } else if (depth &lt;= mindepth || isSmooth) {
                this._insertPoint(pnt);
            } else {
                this._plotRecursive(a, ta, c, tc, depth, delta);
                this._insertPoint(pnt);
                this._plotRecursive(c, tc, b, tb, depth, delta);
            }

            return this;
        },

        /**
         * Updates the data points of a parametric curve.
         * This version is used if {@link JXG.Curve#doadvancedplot} is &lt;tt&gt;true&lt;/tt&gt;.
         *
         * @method updateParametricCurve
         * @param {Number} mi Left bound of curve
         * @param {Number} ma Right bound of curve
         * @return {JXG.Curve} Reference to the curve object.
         * @chainable
         */
        updateParametricCurve: function (mi, ma) {
            var ta, tb, a, b,
                suspendUpdate = false,
                pa = new Coords(Const.COORDS_BY_USER, [0, 0], this.board, false),
                pb = new Coords(Const.COORDS_BY_USER, [0, 0], this.board, false),
                depth, delta;
//var stime = new Date();
            if (this.board.updateQuality === this.board.BOARD_QUALITY_LOW) {
                depth = 12;
                delta = 3;

                delta = 2;
                this.smoothLevel = depth - 5;
                this.jumpLevel = 5;
            } else {
                depth = 17;
                delta = 0.9;

                delta = 2;
                this.smoothLevel = depth - 7; // 9
                this.jumpLevel = 3;
            }
            this.nanLevel = depth - 4;

            this.points = [];
            this._lastCrds = [0, NaN, NaN];   // Used in _insertPoint

            ta = mi;
            pa.setCoordinates(Const.COORDS_BY_USER, [this.X(ta, suspendUpdate), this.Y(ta, suspendUpdate)], false);
            a = pa.copy(&#x27;scrCoords&#x27;);
            suspendUpdate = true;

            tb = ma;
            pb.setCoordinates(Const.COORDS_BY_USER, [this.X(tb, suspendUpdate), this.Y(tb, suspendUpdate)], false);
            b = pb.copy(&#x27;scrCoords&#x27;);

            this.points.push(pa);
            this._plotRecursive(a, ta, b, tb, depth, delta);
            this.points.push(pb);
//console.log(&quot;NUmber points&quot;, this.points.length, this.board.updateQuality, this.board.BOARD_QUALITY_LOW);

            this.numberPoints = this.points.length;
//var etime = new Date();
//console.log(this.name, this.numberPoints, etime.getTime() - stime.getTime(), this.board.updateQuality===this.board.BOARD_QUALITY_HIGH);

            return this;
        },

        /**
         * Applies the transformations of the curve to the given point &lt;tt&gt;p&lt;/tt&gt;.
         * Before using it, {@link JXG.Curve#updateTransformMatrix} has to be called.
         *
         * @method updateTransform
         * @param {JXG.Point} p
         * @return {JXG.Point} The given point.
         */
        updateTransform: function (p) {
            var c,
                len = this.transformations.length;

            if (len &gt; 0) {
                c = Mat.matVecMult(this.transformMat, p.usrCoords);
                p.setCoordinates(Const.COORDS_BY_USER, [c[1], c[2]], false, true);
            }

            return p;
        },

        /**
         * Add transformations to this curve.
         *
         * @method addTransform
         * @param {JXG.Transformation|Array} transform Either one {@link JXG.Transformation} or an array of {@link JXG.Transformation}s.
         * @return {JXG.Curve} Reference to the curve object.
         * @chainable
         */
        addTransform: function (transform) {
            var i,
                list = Type.isArray(transform) ? transform : [transform],
                len = list.length;

            for (i = 0; i &lt; len; i++) {
                this.transformations.push(list[i]);
            }

            return this;
        },

        /**
         * Generate the method curve.X() in case curve.dataX is an array
         * and generate the method curve.Y() in case curve.dataY is an array.
         *
         * @method interpolationFunctionFromArray
         * @private
         * @param {String} which Either &#x27;X&#x27; or &#x27;Y&#x27;
         * @return {Function}
         **/
        interpolationFunctionFromArray: function (which) {
            var data = &#x27;data&#x27; + which;

            return function (t, suspendedUpdate) {
                var i, j, f1, f2, z, t0, t1,
                    arr = this[data],
                    len = arr.length,
                    f = [];

                if (isNaN(t)) {
                    return NaN;
                }

                if (t &lt; 0) {
                    if (Type.isFunction(arr[0])) {
                        return arr[0]();
                    }

                    return arr[0];
                }

                if (this.bezierDegree === 3) {
                    len /= 3;
                    if (t &gt;= len) {
                        if (Type.isFunction(arr[arr.length - 1])) {
                            return arr[arr.length - 1]();
                        }

                        return arr[arr.length - 1];
                    }

                    i = Math.floor(t) * 3;
                    t0 = t % 1;
                    t1 = 1 - t0;

                    for (j = 0; j &lt; 4; j++) {
                        if (Type.isFunction(arr[i + j])) {
                            f[j] = arr[i + j]();
                        } else {
                            f[j] = arr[i + j];
                        }
                    }

                    return t1 * t1 * (t1 * f[0] + 3 * t0 * f[1]) + (3 * t1 * f[2] + t0 * f[3]) * t0 * t0;
                }

                if (t &gt; len - 2) {
                    i = len - 2;
                } else {
                    i = parseInt(Math.floor(t), 10);
                }

                if (i === t) {
                    if (Type.isFunction(arr[i])) {
                        return arr[i]();
                    }
                    return arr[i];
                }

                for (j = 0; j &lt; 2; j++) {
                    if (Type.isFunction(arr[i + j])) {
                        f[j] = arr[i + j]();
                    } else {
                        f[j] = arr[i + j];
                    }
                }
                return f[0] + (f[1] - f[0]) * (t - i);
            };
        },

         /**
          *
          * Converts the GEONExT syntax of the defining function term into JavaScript.
          * New methods X() and Y() for the Curve object are generated, further
          * new methods for minX() and maxX().
          * @see JXG.GeonextParser.geonext2JS.
          *
          * @method generateTerm
          * @param  {String} varname Name of the parameter, e.g. &#x27;t&#x27; or &#x27;x&#x27;
          * @param  {Array|String|Function} xterm   [description]
          * @param  {Array|String|Function} yterm   [description]
          * @param  {String|Function} mi      [description]
          * @param  {String|Function} ma      [description]
          * @return {JXG.Curve} Reference to the curve object.
          * @chainable
          */
        generateTerm: function (varname, xterm, yterm, mi, ma) {
            var fx, fy;

            // Generate the methods X() and Y()
            if (Type.isArray(xterm)) {
                // Discrete data
                this.dataX = xterm;

                this.numberPoints = this.dataX.length;
                this.X = this.interpolationFunctionFromArray(&#x27;X&#x27;);
                this.visProp.curvetype = &#x27;plot&#x27;;
                this.isDraggable = true;
            } else {
                // Continuous data
                this.X = Type.createFunction(xterm, this.board, varname);
                if (Type.isString(xterm)) {
                    this.visProp.curvetype = &#x27;functiongraph&#x27;;
                } else if (Type.isFunction(xterm) || Type.isNumber(xterm)) {
                    this.visProp.curvetype = &#x27;parameter&#x27;;
                }

                this.isDraggable = true;
            }

            if (Type.isArray(yterm)) {
                this.dataY = yterm;
                this.Y = this.interpolationFunctionFromArray(&#x27;Y&#x27;);
            } else {
                this.Y = Type.createFunction(yterm, this.board, varname);
            }

            /*
             * Polar form
             * Input data is function xterm() and offset coordinates yterm
             */
            if (Type.isFunction(xterm) &amp;&amp; Type.isArray(yterm)) {
                // Xoffset, Yoffset
                fx = Type.createFunction(yterm[0], this.board, &#x27;&#x27;);
                fy = Type.createFunction(yterm[1], this.board, &#x27;&#x27;);

                this.X = function (phi) {
                    return xterm(phi) * Math.cos(phi) + fx();
                };

                this.Y = function (phi) {
                    return xterm(phi) * Math.sin(phi) + fy();
                };

                this.visProp.curvetype = &#x27;polar&#x27;;
            }

            // Set the bounds lower bound
            if (Type.exists(mi)) {
                this.minX = Type.createFunction(mi, this.board, &#x27;&#x27;);
            }
            if (Type.exists(ma)) {
                this.maxX = Type.createFunction(ma, this.board, &#x27;&#x27;);
            }

            return this;
        },

        /**
         * Finds dependencies in a given term and notifies the parents by adding the
         * dependent object to the found objects child elements.
         *
         * @method notifyParents
         * @param {String} contentStr String containing dependencies for the given object.
         * @return {JXG.Curve} Reference to the curve object.
         * @chainable
         */
        notifyParents: function (contentStr) {
            var fstr, dep,
                isJessieCode = false;

            // Read dependencies found by the JessieCode parser
            for (fstr in {&#x27;xterm&#x27;: 1, &#x27;yterm&#x27;: 1}) {
                if (this.hasOwnProperty(fstr) &amp;&amp; this[fstr].origin) {
                    isJessieCode = true;
                    for (dep in this[fstr].origin.deps) {
                        if (this[fstr].origin.deps.hasOwnProperty(dep)) {
                            this[fstr].origin.deps[dep].addChild(this);
                        }
                    }
                }
            }

            if (!isJessieCode) {
                GeonextParser.findDependencies(this, contentStr, this.board);
            }

            return this;
        },

        // documented in geometry element
        getLabelAnchor: function () {
            var c, x, y,
                ax = 0.05 * this.board.canvasWidth,
                ay = 0.05 * this.board.canvasHeight,
                bx = 0.95 * this.board.canvasWidth,
                by = 0.95 * this.board.canvasHeight;

            switch (this.visProp.label.position) {
            case &#x27;ulft&#x27;:
                x = ax;
                y = ay;
                break;
            case &#x27;llft&#x27;:
                x = ax;
                y = by;
                break;
            case &#x27;rt&#x27;:
                x = bx;
                y = 0.5 * by;
                break;
            case &#x27;lrt&#x27;:
                x = bx;
                y = by;
                break;
            case &#x27;urt&#x27;:
                x = bx;
                y = ay;
                break;
            case &#x27;top&#x27;:
                x = 0.5 * bx;
                y = ay;
                break;
            case &#x27;bot&#x27;:
                x = 0.5 * bx;
                y = by;
                break;
            default:
                // includes case &#x27;lft&#x27;
                x = ax;
                y = 0.5 * by;
            }

            c = new Coords(Const.COORDS_BY_SCREEN, [x, y], this.board, false);
            return Geometry.projectCoordsToCurve(c.usrCoords[1], c.usrCoords[2], 0, this, this.board)[0];
        },

        // documented in geometry element
        cloneToBackground: function () {
            var er,
                copy = {
                    id: this.id + &#x27;T&#x27; + this.numTraces,
                    elementClass: Const.OBJECT_CLASS_CURVE,

                    points: this.points.slice(0),
                    bezierDegree: this.bezierDegree,
                    numberPoints: this.numberPoints,
                    board: this.board,
                    visProp: Type.deepCopy(this.visProp, this.visProp.traceattributes, true)
                };

            copy.visProp.layer = this.board.options.layer.trace;
            copy.visProp.curvetype = this.visProp.curvetype;
            this.numTraces++;

            Type.clearVisPropOld(copy);

            er = this.board.renderer.enhancedRendering;
            this.board.renderer.enhancedRendering = true;
            this.board.renderer.drawCurve(copy);
            this.board.renderer.enhancedRendering = er;
            this.traces[copy.id] = copy.rendNode;

            return this;
        },

        // already documented in GeometryElement
        bounds: function () {
            var minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity,
                l = this.points.length, i;

            if (this.bezierDegree === 3) {
                // Add methods X(), Y()
                for (i = 0; i &lt; l; i++) {
                    this.points[i].X = Type.bind(function() { return this.usrCoords[1]; }, this.points[i]);
                    this.points[i].Y = Type.bind(function() { return this.usrCoords[2]; }, this.points[i]);
                }
                var bezier = Numerics.bezier(this.points);
                var up = bezier[3]();
                minX = Numerics.fminbr(function(t) { return bezier[0](t); }, [0, up]);
                maxX = Numerics.fminbr(function(t) { return -bezier[0](t); }, [0, up]);
                minY = Numerics.fminbr(function(t) { return bezier[1](t); }, [0, up]);
                maxY = Numerics.fminbr(function(t) { return -bezier[1](t); }, [0, up]);

                minX = bezier[0](minX);
                maxX = bezier[0](maxX);
                minY = bezier[1](minY);
                maxY = bezier[1](maxY);
                return [minX, maxY, maxX, minY];
            }

            // Linear segments
            for (i = 0; i &lt; l; i++) {
                if (minX &gt; this.points[i].usrCoords[1]) {
                    minX = this.points[i].usrCoords[1];
                }

                if (maxX &lt; this.points[i].usrCoords[1]) {
                    maxX = this.points[i].usrCoords[1];
                }

                if (minY &gt; this.points[i].usrCoords[2]) {
                    minY = this.points[i].usrCoords[2];
                }

                if (maxY &lt; this.points[i].usrCoords[2]) {
                    maxY = this.points[i].usrCoords[2];
                }
            }

            return [minX, maxY, maxX, minY];
        }
    });


    /**
     *
     * This element is used to provide a constructor for curve, which is just a wrapper for element {@link Curve}.
     * A curve is a mapping from R to R^2. t mapsto (x(t),y(t)). The graph is drawn for t in the interval [a,b].
     *
     * The following types of curves can be plotted:
     *
     *  * parametric curves: t mapsto (x(t),y(t)), where x() and y() are univariate functions.
     *  * polar curves: curves commonly written with polar equations like spirals and cardioids.
     *  * data plots: plot line segments through a given list of coordinates.
     *
     * @class Curve
     * @pseudo
     * @extends JXG.Curve
     * @constructor
     * @type JXG.Curve
     *
     * @param {function,number_function,number_function,number_function,number} x,y,a_,b_ Parent elements for Parametric Curves.
     *   &lt;p&gt;
     *   x describes the x-coordinate of the curve. It may be a function term in one variable, e.g. x(t).
     *   In case of x being of type number, x(t) is set to a constant function.
     *   In case x being of type function. This function evaluates at the values of the array.
     *   &lt;p&gt;
     *   y describes the y-coordinate of the curve. In case of a number, y(t) is set to the constant function
     *   returning this number.
     *
     *   Further parameters are an optional number or function for the left interval border a,
     *   and an optional number or function for the right interval border b.
     *
     *   Default values are a=-10 and b=10.
     * @param {array_array,function,number} x,y Parent elements for Data Plots.
     *  &lt;p&gt;
     *  x and y are arrays contining the x and y coordinates of the data points which are connected by
     *  line segments. The individual entries of x and y may also be functions.
     *  In case of x being an array the curve type is data plot, regardless of the second parameter and
     *  if additionally the second parameter y is a function term the data plot evaluates.
     * @param {function_array,function,number_function,number_function,number} r,offset_,a_,b_ Parent elements for Polar Curves.
     *  &lt;p&gt;
     *  The first parameter is a function term r(phi) describing the polar curve.
     *  &lt;p&gt;
     *  The second parameter is the offset of the curve. It has to be
     *  an array containing numbers or functions describing the offset. Default value is the origin [0,0].
     *  &lt;p&gt;
     *  Further parameters are an optional number or function for the left interval border a,
     *  and an optional number or function for the right interval border b.
     *  &lt;p&gt;
     *  Default values are a=-10 and b=10.
     * @see JXG.Curve
     * @example
     *
     *     // Parametric curve
     *     // Create a curve of the form (t-sin(t), 1-cos(t), i.e.
     *     // the cycloid curve.
     *     var graph = board.create(&#x27;curve&#x27;,
     *                        [function(t){ return t-Math.sin(t);},
     *                         function(t){ return 1-Math.cos(t);},
     *                         0, 2*Math.PI]
     *                     );
     *
     * &lt;div id=&quot;af9f818b-f3b6-4c4d-8c4c-e4a4078b726d&quot; style=&quot;width: 300px; height: 300px;&quot;&gt;&lt;/div&gt;
     * &lt;script type=&quot;text/javascript&quot;&gt;
     * (function(){
     *   var board = JXG.JSXGraph.initBoard(&#x27;af9f818b-f3b6-4c4d-8c4c-e4a4078b726d&#x27;, {boundingbox: [-1, 5, 7, -1], axis: true, showcopyright: false, shownavigation: false});
     *   var graph1 = board.create(&#x27;curve&#x27;, [function(t){ return t-Math.sin(t);},function(t){ return 1-Math.cos(t);},0, 2*Math.PI]);
     * })();
     * &lt;/script&gt;
     *
     * @example
     *
     *     // Data plots
     *     // Connect a set of points given by coordinates with dashed line segments.
     *     // The x- and y-coordinates of the points are given in two separate
     *     // arrays.
     *     var x = [0,1,2,3,4,5,6,7,8,9];
     *     var y = [9.2,1.3,7.2,-1.2,4.0,5.3,0.2,6.5,1.1,0.0];
     *     var graph = board.create(&#x27;curve&#x27;, [x,y], {dash:2});
     *
     * &lt;div id=&quot;7dcbb00e-b6ff-481d-b4a8-887f5d8c6a83&quot; style=&quot;width: 300px; height: 300px;&quot;&gt;&lt;/div&gt;
     * &lt;script type=&quot;text/javascript&quot;&gt;
     * (function(){
     *   var board = JXG.JSXGraph.initBoard(&#x27;7dcbb00e-b6ff-481d-b4a8-887f5d8c6a83&#x27;, {boundingbox: [-1,10,10,-1], axis: true, showcopyright: false, shownavigation: false});
     *   var x = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
     *   var y = [9.2, 1.3, 7.2, -1.2, 4.0, 5.3, 0.2, 6.5, 1.1, 0.0];
     *   var graph3 = board.create(&#x27;curve&#x27;, [x,y], {dash:2});
     * })();
     * &lt;/script&gt;
     *
     * @example
     *
     *     // Polar plot
     *     // Create a curve with the equation r(phi)= a*(1+phi), i.e.
     *     // a cardioid.
     *     var a = board.create(&#x27;slider&#x27;,[[0,2],[2,2],[0,1,2]]);
     *     var graph = board.create(&#x27;curve&#x27;,
     *                        [function(phi){ return a.Value()*(1-Math.cos(phi));},
     *                         [1,0],
     *                         0, 2*Math.PI]
     *                     );
     * &lt;div id=&quot;d0bc7a2a-8124-45ca-a6e7-142321a8f8c2&quot; style=&quot;width: 300px; height: 300px;&quot;&gt;&lt;/div&gt;
     * &lt;script type=&quot;text/javascript&quot;&gt;
     * (function(){
     *   var board = JXG.JSXGraph.initBoard(&#x27;d0bc7a2a-8124-45ca-a6e7-142321a8f8c2&#x27;, {boundingbox: [-3,3,3,-3], axis: true, showcopyright: false, shownavigation: false});
     *   var a = board.create(&#x27;slider&#x27;,[[0,2],[2,2],[0,1,2]]);
     *   var graph2 = board.create(&#x27;curve&#x27;, [function(phi){ return a.Value()*(1-Math.cos(phi));}, [1,0], 0, 2*Math.PI]);
     * })();
     * &lt;/script&gt;
     *
     * @example
     *
     *      // Draggable Bezier curve
     *      var col, p, c;
     *      col = &#x27;blue&#x27;;
     *      p = [];
     *      p.push(board.create(&#x27;point&#x27;,[-2, -1 ], {size: 5, strokeColor:col, fillColor:col}));
     *      p.push(board.create(&#x27;point&#x27;,[1, 2.5 ], {size: 5, strokeColor:col, fillColor:col}));
     *      p.push(board.create(&#x27;point&#x27;,[-1, -2.5 ], {size: 5, strokeColor:col, fillColor:col}));
     *      p.push(board.create(&#x27;point&#x27;,[2, -2], {size: 5, strokeColor:col, fillColor:col}));
     *
     *      c = board.create(&#x27;curve&#x27;, JXG.Math.Numerics.bezier(p),
     *              {strokeColor:&#x27;red&#x27;, name:&quot;curve&quot;, strokeWidth:5, fixed: false}); // Draggable curve
     *      c.addParents(p);
     * &lt;div id=&quot;7bcc6280-f6eb-433e-8281-c837c3387849&quot; style=&quot;width: 300px; height: 300px;&quot;&gt;&lt;/div&gt;
     * &lt;script type=&quot;text/javascript&quot;&gt;
     * (function(){
     *  var board, col, p, c;
     *  board = JXG.JSXGraph.initBoard(&#x27;7bcc6280-f6eb-433e-8281-c837c3387849&#x27;, {boundingbox: [-3,3,3,-3], axis: true, showcopyright: false, shownavigation: false});
     *  col = &#x27;blue&#x27;;
     *  p = [];
     *  p.push(board.create(&#x27;point&#x27;,[-2, -1 ], {size: 5, strokeColor:col, fillColor:col}));
     *  p.push(board.create(&#x27;point&#x27;,[1, 2.5 ], {size: 5, strokeColor:col, fillColor:col}));
     *  p.push(board.create(&#x27;point&#x27;,[-1, -2.5 ], {size: 5, strokeColor:col, fillColor:col}));
     *  p.push(board.create(&#x27;point&#x27;,[2, -2], {size: 5, strokeColor:col, fillColor:col}));
     *  c = board.create(&#x27;curve&#x27;, JXG.Math.Numerics.bezier(p),
     *              {strokeColor:&#x27;red&#x27;, name:&quot;curve&quot;, strokeWidth:5, fixed: false}); // Draggable curve
     *  c.addParents(p);
     * })();
     * &lt;/script&gt;
     *
     */
    JXG.createCurve = function (board, parents, attributes) {
        var attr = Type.copyAttributes(attributes, board.options, &#x27;curve&#x27;);
        return new JXG.Curve(board, [&#x27;x&#x27;].concat(parents), attr);
    };

    JXG.registerElement(&#x27;curve&#x27;, JXG.createCurve);

    /**
     * This element is used to provide a constructor for functiongraph, which is just a wrapper for element {@link Curve} with {@link JXG.Curve#X()}
     * set to x. The graph is drawn for x in the interval [a,b].
     * @pseudo
     * @class Functiongraph
     * @extends JXG.Curve
     * @constructor
     * @type JXG.Curve
     * @param {function_number,function_number,function} f,a_,b_ Parent
     * elements are a function term f(x) describing the function graph.
     * &lt;p&gt;
     * Further, an optional number or function for the left interval border a,
     * and an optional number or function for the right interval border b.
     * &lt;p&gt;
     * Default values are a=-10 and b=10.
     * @see JXG.Curve
     *
     * @example
     *     // Create a function graph for f(x) = 0.5*x*x-2*x
     *     var graph = board.create(&#x27;functiongraph&#x27;,
     *                        [function(x){ return 0.5*x*x-2*x;}, -2, 4]
     *                     );
     * &lt;div id=&quot;efd432b5-23a3-4846-ac5b-b471e668b437&quot; style=&quot;width: 300px; height: 300px;&quot;&gt;&lt;/div&gt;
     * &lt;script type=&quot;text/javascript&quot;&gt;
     * (function(){
     *   var board = JXG.JSXGraph.initBoard(&#x27;efd432b5-23a3-4846-ac5b-b471e668b437&#x27;, {boundingbox: [-3, 7, 5, -3], axis: true, showcopyright: false, shownavigation: false});
     *   var graph = board.create(&#x27;functiongraph&#x27;, [function(x){ return 0.5*x*x-2*x;}, -2, 4]);
     * })();
     * &lt;/script&gt;
     *
     * @example
     *     // Create a function graph for f(x) = 0.5*x*x-2*x with variable interval
     *     var s = board.create(&#x27;slider&#x27;,[[0,4],[3,4],[-2,4,5]]);
     *     var graph = board.create(&#x27;functiongraph&#x27;,
     *                        [function(x){ return 0.5*x*x-2*x;},
     *                         -2,
     *                         function(){return s.Value();}]
     *                     );
     * &lt;div id=&quot;4a203a84-bde5-4371-ad56-44619690bb50&quot; style=&quot;width: 300px; height: 300px;&quot;&gt;&lt;/div&gt;
     * &lt;script type=&quot;text/javascript&quot;&gt;
     * (function(){
     *   var board = JXG.JSXGraph.initBoard(&#x27;4a203a84-bde5-4371-ad56-44619690bb50&#x27;, {boundingbox: [-3, 7, 5, -3], axis: true, showcopyright: false, shownavigation: false});
     *   var s = board.create(&#x27;slider&#x27;,[[0,4],[3,4],[-2,4,5]]);
     *   var graph = board.create(&#x27;functiongraph&#x27;, [function(x){ return 0.5*x*x-2*x;}, -2, function(){return s.Value();}]);
     * })();
     * &lt;/script&gt;
     */
    JXG.createFunctiongraph = function (board, parents, attributes) {
        var attr,
            par = [&#x27;x&#x27;, &#x27;x&#x27;].concat(parents);

        attr = Type.copyAttributes(attributes, board.options, &#x27;curve&#x27;);
        attr.curvetype = &#x27;functiongraph&#x27;;
        return new JXG.Curve(board, par, attr);
    };

    JXG.registerElement(&#x27;functiongraph&#x27;, JXG.createFunctiongraph);
    JXG.registerElement(&#x27;plot&#x27;, JXG.createFunctiongraph);

    /**
     * Create a dynamic spline interpolated curve given by sample points p_1 to p_n.
     *
     * @class Spline
     * @constructor
     * @type JXG.Curve
     * @param {JXG.Board} board Reference to the board the spline is drawn on.
     * @param {Array} parents Array of points the spline interpolates
     * @param {Object} attributes Define color, width, ... of the spline
     */
    JXG.createSpline = function (board, parents, attributes) {
        var f;

        f = function () {
            var D, x = [], y = [];

            return function (t, suspended) {
                var i, j, c;

                if (!suspended) {
                    x = [];
                    y = [];

                    // given as [x[], y[]]
                    if (parents.length === 2 &amp;&amp; Type.isArray(parents[0]) &amp;&amp; Type.isArray(parents[1]) &amp;&amp; parents[0].length === parents[1].length) {
                        for (i = 0; i &lt; parents[0].length; i++) {
                            if (typeof parents[0][i] === &#x27;function&#x27;) {
                                x.push(parents[0][i]());
                            } else {
                                x.push(parents[0][i]);
                            }

                            if (typeof parents[1][i] === &#x27;function&#x27;) {
                                y.push(parents[1][i]());
                            } else {
                                y.push(parents[1][i]);
                            }
                        }
                    } else {
                        for (i = 0; i &lt; parents.length; i++) {
                            if (Type.isPoint(parents[i])) {
                                x.push(parents[i].X());
                                y.push(parents[i].Y());
                            // given as [[x1,y1], [x2, y2], ...]
                            } else if (Type.isArray(parents[i]) &amp;&amp; parents[i].length === 2) {
                                for (j = 0; j &lt; parents.length; j++) {
                                    if (typeof parents[j][0] === &#x27;function&#x27;) {
                                        x.push(parents[j][0]());
                                    } else {
                                        x.push(parents[j][0]);
                                    }

                                    if (typeof parents[j][1] === &#x27;function&#x27;) {
                                        y.push(parents[j][1]());
                                    } else {
                                        y.push(parents[j][1]);
                                    }
                                }
                            } else if (Type.isFunction(parents[i]) &amp;&amp; parents[i]().length === 2) {
                                c = parents[i]();
                                x.push(c[0]);
                                y.push(c[1]);
                            }
                        }
                    }

                    // The array D has only to be calculated when the position of one or more sample point
                    // changes. otherwise D is always the same for all points on the spline.
                    D = Numerics.splineDef(x, y);
                }
                return Numerics.splineEval(t, x, y, D);
            };
        };
        return board.create(&#x27;curve&#x27;, [&quot;x&quot;, f()], attributes);
    };

    /*
     * Register the element type spline at JSXGraph
     * @private
     */
    JXG.registerElement(&#x27;spline&#x27;, JXG.createSpline);

    /**
     * This element is used to provide a constructor for Riemann sums, which is realized as a special curve.
     * The returned element has the method Value() which returns the sum of the areas of the bars.
     *
     * @pseudo
     * @class Riemannsum
     * @extends JXG.Curve
     * @constructor
     * @type JXG.Curve
     * @param {function,array_number,function_string,function_function,number_function,number} f,n,type_,a_,b_ Parent elements of Riemannsum are a
     *  Either a function term f(x) describing the function graph which is filled by the Riemann bars, or
     *  an array consisting of two functions and the area between is filled by the Riemann bars.
     *  &lt;p&gt;
     *  n determines the number of bars, it is either a fixed number or a function.
     *  &lt;p&gt;
     *  type is a string or function returning one of the values:  &#x27;left&#x27;, &#x27;right&#x27;, &#x27;middle&#x27;, &#x27;lower&#x27;, &#x27;upper&#x27;, &#x27;random&#x27;, &#x27;simpson&#x27;, or &#x27;trapezodial&#x27;.
     *  Default value is &#x27;left&#x27;.
     *  &lt;p&gt;
     *  Further parameters are an optional number or function for the left interval border a,
     *  and an optional number or function for the right interval border b.
     *  &lt;p&gt;
     *  Default values are a=-10 and b=10.
     * @see JXG.Curve
     *
     * @example
     *
     *     // Create Riemann sums for f(x) = 0.5*x*x-2*x.
     *     var s = board.create(&#x27;slider&#x27;,[[0,4],[3,4],[0,4,10]],{snapWidth:1});
     *     var f = function(x) { return 0.5*x*x-2*x; };
     *     var r = board.create(&#x27;riemannsum&#x27;,
     *               [f, function(){return s.Value();}, &#x27;upper&#x27;, -2, 5],
     *               {fillOpacity:0.4}
     *               );
     *     var g = board.create(&#x27;functiongraph&#x27;,[f, -2, 5]);
     *     var t = board.create(&#x27;text&#x27;,[-1,-1, function(){ return &#x27;Sum=&#x27; + r.Value().toFixed(4); }]);
     * &lt;div id=&quot;940f40cc-2015-420d-9191-c5d83de988cf&quot; style=&quot;width: 300px; height: 300px;&quot;&gt;&lt;/div&gt;
     * &lt;script type=&quot;text/javascript&quot;&gt;
     * (function(){
     *   var board = JXG.JSXGraph.initBoard(&#x27;940f40cc-2015-420d-9191-c5d83de988cf&#x27;, {boundingbox: [-3, 7, 5, -3], axis: true, showcopyright: false, shownavigation: false});
     *   var f = function(x) { return 0.5*x*x-2*x; };
     *   var s = board.create(&#x27;slider&#x27;,[[0,4],[3,4],[0,4,10]],{snapWidth:1});
     *   var r = board.create(&#x27;riemannsum&#x27;, [f, function(){return s.Value();}, &#x27;upper&#x27;, -2, 5], {fillOpacity:0.4});
     *   var g = board.create(&#x27;functiongraph&#x27;, [f, -2, 5]);
     *   var t = board.create(&#x27;text&#x27;,[-1,-1, function(){ return &#x27;Sum=&#x27; + r.Value().toFixed(4); }]);
     * })();
     * &lt;/script&gt;
     *
     * @example
     *     // Riemann sum between two functions
     *     var s = board.create(&#x27;slider&#x27;,[[0,4],[3,4],[0,4,10]],{snapWidth:1});
     *     var g = function(x) { return 0.5*x*x-2*x; };
     *     var f = function(x) { return -x*(x-4); };
     *     var r = board.create(&#x27;riemannsum&#x27;,
     *               [[g,f], function(){return s.Value();}, &#x27;lower&#x27;, 0, 4],
     *               {fillOpacity:0.4}
     *               );
     *     var g = board.create(&#x27;functiongraph&#x27;,[f, -2, 5]);
     *     var t = board.create(&#x27;text&#x27;,[-1,-1, function(){ return &#x27;Sum=&#x27; + r.Value().toFixed(4); }]);
     * &lt;div id=&quot;f9a7ba38-b50f-4a32-a873-2f3bf9caee79&quot; style=&quot;width: 300px; height: 300px;&quot;&gt;&lt;/div&gt;
     * &lt;script type=&quot;text/javascript&quot;&gt;
     * (function(){
     *   var board = JXG.JSXGraph.initBoard(&#x27;f9a7ba38-b50f-4a32-a873-2f3bf9caee79&#x27;, {boundingbox: [-3, 7, 5, -3], axis: true, showcopyright: false, shownavigation: false});
     *   var s = board.create(&#x27;slider&#x27;,[[0,4],[3,4],[0,4,10]],{snapWidth:1});
     *   var g = function(x) { return 0.5*x*x-2*x; };
     *   var f = function(x) { return -x*(x-4); };
     *   var r = board.create(&#x27;riemannsum&#x27;,
     *               [[g,f], function(){return s.Value();}, &#x27;lower&#x27;, 0, 4],
     *               {fillOpacity:0.4}
     *               );
     *   var g = board.create(&#x27;functiongraph&#x27;,[f, -2, 5]);
     *   var t = board.create(&#x27;text&#x27;,[-1,-1, function(){ return &#x27;Sum=&#x27; + r.Value().toFixed(4); }]);
     * })();
     * &lt;/script&gt;
     */
    JXG.createRiemannsum = function (board, parents, attributes) {
        var n, type, f, par, c, attr;

        attr = Type.copyAttributes(attributes, board.options, &#x27;riemannsum&#x27;);
        attr.curvetype = &#x27;plot&#x27;;

        f = parents[0];
        n = Type.createFunction(parents[1], board, &#x27;&#x27;);

        if (!Type.exists(n)) {
            throw new Error(&quot;JSXGraph: JXG.createRiemannsum: argument &#x27;2&#x27; n has to be number or function.&quot; +
                &quot;\nPossible parent types: [function,n:number|function,type,start:number|function,end:number|function]&quot;);
        }

        type = Type.createFunction(parents[2], board, &#x27;&#x27;, false);
        if (!Type.exists(type)) {
            throw new Error(&quot;JSXGraph: JXG.createRiemannsum: argument 3 &#x27;type&#x27; has to be string or function.&quot; +
                &quot;\nPossible parent types: [function,n:number|function,type,start:number|function,end:number|function]&quot;);
        }

        par = [[0], [0]].concat(parents.slice(3));

        c = board.create(&#x27;curve&#x27;, par, attr);

        c.sum = 0.0;
        c.Value = function () {
            return this.sum;
        };

        c.updateDataArray = function () {
            var u = Numerics.riemann(f, n(), type(), this.minX(), this.maxX());
            this.dataX = u[0];
            this.dataY = u[1];

            // Update &quot;Riemann sum&quot;
            this.sum = u[2];
        };

        return c;
    };

    JXG.registerElement(&#x27;riemannsum&#x27;, JXG.createRiemannsum);

    /**
     * This element is used to provide a constructor for trace curve (simple locus curve),
     * which is realized as a special curve.
     *
     * @pseudo
     * @class Tracecurve
     * @extends JXG.Curve
     * @constructor
     * @type JXG.Curve
     * @param {Point,Point} Parent elements of Tracecurve are a
     *  glider point and a point whose locus is traced.
     * @see JXG.Curve
     * @example
     *     // Create trace curve.
     *     var c1 = board.create(&#x27;circle&#x27;,[[0, 0], [2, 0]]),
     *          p1 = board.create(&#x27;point&#x27;,[-3, 1]),
     *          g1 = board.create(&#x27;glider&#x27;,[2, 1, c1]),
     *          s1 = board.create(&#x27;segment&#x27;,[g1, p1]),
     *          p2 = board.create(&#x27;midpoint&#x27;,[s1]),
     *          curve = board.create(&#x27;tracecurve&#x27;, [g1, p2]);
     *
     * &lt;div id=&quot;5749fb7d-04fc-44d2-973e-45c1951e29ad&quot; style=&quot;width: 300px; height: 300px;&quot;&gt;&lt;/div&gt;
     * &lt;script type=&quot;text/javascript&quot;&gt;
     * (function(){
     *   var board = JXG.JSXGraph.initBoard(&#x27;5749fb7d-04fc-44d2-973e-45c1951e29ad&#x27;, {boundingbox: [-4, 4, 4, -4], axis: false, showcopyright: false, shownavigation: false});
     *   var c1 = board.create(&#x27;circle&#x27;,[[0, 0], [2, 0]]),
     *       p1 = board.create(&#x27;point&#x27;,[-3, 1]),
     *       g1 = board.create(&#x27;glider&#x27;,[2, 1, c1]),
     *       s1 = board.create(&#x27;segment&#x27;,[g1, p1]),
     *       p2 = board.create(&#x27;midpoint&#x27;,[s1]),
     *       curve = board.create(&#x27;tracecurve&#x27;, [g1, p2]);
     * })();
     * &lt;/script&gt;
     */
    JXG.createTracecurve = function (board, parents, attributes) {
        var c, glider, tracepoint, attr;

        if (parents.length !== 2) {
            throw new Error(&quot;JSXGraph: Can&#x27;t create trace curve with given parent&#x27;&quot; +
                &quot;\nPossible parent types: [glider, point]&quot;);
        }

        glider = board.select(parents[0]);
        tracepoint = board.select(parents[1]);

        if (glider.type !== Const.OBJECT_TYPE_GLIDER || !Type.isPoint(tracepoint)) {
            throw new Error(&quot;JSXGraph: Can&#x27;t create trace curve with parent types &#x27;&quot; +
                (typeof parents[0]) + &quot;&#x27; and &#x27;&quot; + (typeof parents[1]) + &quot;&#x27;.&quot; +
                &quot;\nPossible parent types: [glider, point]&quot;);
        }

        attr = Type.copyAttributes(attributes, board.options, &#x27;tracecurve&#x27;);
        attr.curvetype = &#x27;plot&#x27;;
        c = board.create(&#x27;curve&#x27;, [[0], [0]], attr);

        c.updateDataArray = function () {
            var i, step, t, el, pEl, x, y, v, from, savetrace,
                le = attr.numberpoints,
                savePos = glider.position,
                slideObj = glider.slideObject,
                mi = slideObj.minX(),
                ma = slideObj.maxX();

            // set step width
            step = (ma - mi) / le;
            this.dataX = [];
            this.dataY = [];

            /*
             * For gliders on circles and lines a closed curve is computed.
             * For gliders on curves the curve is not closed.
             */
            if (slideObj.elementClass !== Const.OBJECT_CLASS_CURVE) {
                le++;
            }

            // Loop over all steps
            for (i = 0; i &lt; le; i++) {
                t = mi + i * step;
                x = slideObj.X(t) / slideObj.Z(t);
                y = slideObj.Y(t) / slideObj.Z(t);

                // Position the glider
                glider.setPositionDirectly(Const.COORDS_BY_USER, [x, y]);
                from = false;

                // Update all elements from the glider up to the trace element
                for (el in this.board.objects) {
                    if (this.board.objects.hasOwnProperty(el)) {
                        pEl = this.board.objects[el];

                        if (pEl === glider) {
                            from = true;
                        }

                        if (from &amp;&amp; pEl.needsRegularUpdate) {
                            // Save the trace mode of the element
                            savetrace = pEl.visProp.trace;
                            pEl.visProp.trace = false;
                            pEl.needsUpdate = true;
                            pEl.update(true);

                            // Restore the trace mode
                            pEl.visProp.trace = savetrace;
                            if (pEl === tracepoint) {
                                break;
                            }
                        }
                    }
                }

                // Store the position of the trace point
                this.dataX[i] = tracepoint.X();
                this.dataY[i] = tracepoint.Y();
            }

            // Restore the original position of the glider
            glider.position = savePos;
            from = false;

            // Update all elements from the glider to the trace point
            for (el in this.board.objects) {
                if (this.board.objects.hasOwnProperty(el)) {
                    pEl = this.board.objects[el];
                    if (pEl === glider) {
                        from = true;
                    }

                    if (from &amp;&amp; pEl.needsRegularUpdate) {
                        savetrace = pEl.visProp.trace;
                        pEl.visProp.trace = false;
                        pEl.needsUpdate = true;
                        pEl.update(true);
                        pEl.visProp.trace = savetrace;

                        if (pEl === tracepoint) {
                            break;
                        }
                    }
                }
            }
        };

        return c;
    };

    JXG.registerElement(&#x27;tracecurve&#x27;, JXG.createTracecurve);

    /**
     * This element is used to provide a constructor for step function, which is realized as a special curve.
     *
     * In case the data points should be updated after creation time,
     * they can be accessed by &#x60;curve.xterm&#x60; and &#x60;curve.yterm&#x60;.
     *
     * @pseudo
     * @class Stepfunction
     * @extends JXG.Curve
     * @constructor
     * @type JXG.Curve
     * @param {Array,Array|Function} Parent elements of Stepfunction are two arrays containing the coordinates.
     * @see JXG.Curve
     * @example
     *
     *     // Create step function.
     *     var curve = board.create(&#x27;stepfunction&#x27;, [[0,1,2,3,4,5], [1,3,0,2,2,1]]);
     *
     * &lt;div id=&quot;32342ec9-ad17-4339-8a97-ff23dc34f51a&quot; style=&quot;width: 300px; height: 300px;&quot;&gt;&lt;/div&gt;
     * &lt;script type=&quot;text/javascript&quot;&gt;
     * (function(){
     *   var board = JXG.JSXGraph.initBoard(&#x27;32342ec9-ad17-4339-8a97-ff23dc34f51a&#x27;, {boundingbox: [-1, 5, 6, -2], axis: true, showcopyright: false, shownavigation: false});
     *   var curve = board.create(&#x27;stepfunction&#x27;, [[0,1,2,3,4,5], [1,3,0,2,2,1]]);
     * })();
     * &lt;/script&gt;
     */
    JXG.createStepfunction = function (board, parents, attributes) {
        var c, attr;
        if (parents.length !== 2) {
            throw new Error(&quot;JSXGraph: Can&#x27;t create step function with given parent&#x27;&quot; +
                &quot;\nPossible parent types: [array, array|function]&quot;);
        }

        attr = Type.copyAttributes(attributes, board.options, &#x27;stepfunction&#x27;);
        c = board.create(&#x27;curve&#x27;, parents, attr);
        c.updateDataArray = function () {
            var i, j = 0,
                len = this.xterm.length;

            this.dataX = [];
            this.dataY = [];

            if (len === 0) {
                return;
            }

            this.dataX[j] = this.xterm[0];
            this.dataY[j] = this.yterm[0];
            ++j;

            for (i = 1; i &lt; len; ++i) {
                this.dataX[j] = this.xterm[i];
                this.dataY[j] = this.dataY[j - 1];
                ++j;
                this.dataX[j] = this.xterm[i];
                this.dataY[j] = this.yterm[i];
                ++j;
            }
        };

        return c;
    };

    JXG.registerElement(&#x27;stepfunction&#x27;, JXG.createStepfunction);

    return {
        Curve: JXG.Curve,
        createCurve: JXG.createCurve,
        createFunctiongraph: JXG.createFunctiongraph,
        createPlot: JXG.createPlot,
        createSpline: JXG.createSpline,
        createRiemannsum: JXG.createRiemannsum,
        createTracecurve: JXG.createTracecurve,
        createStepfunction: JXG.createStepfunction
    };
});

    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src/reader/geonext.js - JSXGraph</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="../assets/js/jsxgraphcore.js"></script>
    <link rel="stylesheet" href="../assets/css/jsxgraph.css">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../assets/css/logo_blue.png" title="JSXGraph" width="117" height="52"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.99.4</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/Angle.html">Angle</a> </li>
                                <li><a href="../classes/Arc.html">Arc</a> </li>
                                <li><a href="../classes/Arrow.html">Arrow</a> </li>
                                <li><a href="../classes/Arrowparallel.html">Arrowparallel</a> </li>
                                <li><a href="../classes/Axis.html">Axis</a> </li>
                                <li><a href="../classes/Bisector.html">Bisector</a> </li>
                                <li><a href="../classes/Bisectorlines.html">Bisectorlines</a> </li>
                                <li><a href="../classes/Button.html">Button</a> </li>
                                <li><a href="../classes/Checkbox.html">Checkbox</a> </li>
                                <li><a href="../classes/Circle.html">Circle</a> </li>
                                <li><a href="../classes/Circumcenter.html">Circumcenter</a> </li>
                                <li><a href="../classes/Circumcircle.html">Circumcircle</a> </li>
                                <li><a href="../classes/CircumcircleArc.html">CircumcircleArc</a> </li>
                                <li><a href="../classes/CircumcircleSector.html">CircumcircleSector</a> </li>
                                <li><a href="../classes/Conic.html">Conic</a> </li>
                                <li><a href="../classes/Curve.html">Curve</a> </li>
                                <li><a href="../classes/Ellipse.html">Ellipse</a> </li>
                                <li><a href="../classes/EventEmitter.html">EventEmitter</a> </li>
                                <li><a href="../classes/Functiongraph.html">Functiongraph</a> </li>
                                <li><a href="../classes/Glider.html">Glider</a> </li>
                                <li><a href="../classes/Grid.html">Grid</a> </li>
                                <li><a href="../classes/Group.html">Group</a> </li>
                                <li><a href="../classes/Hatch.html">Hatch</a> </li>
                                <li><a href="../classes/Hyperbola.html">Hyperbola</a> </li>
                                <li><a href="../classes/Image.html">Image</a> </li>
                                <li><a href="../classes/Incenter.html">Incenter</a> </li>
                                <li><a href="../classes/Incircle.html">Incircle</a> </li>
                                <li><a href="../classes/Inequality.html">Inequality</a> </li>
                                <li><a href="../classes/Input.html">Input</a> </li>
                                <li><a href="../classes/Integral.html">Integral</a> </li>
                                <li><a href="../classes/Intersection.html">Intersection</a> </li>
                                <li><a href="../classes/JXG.html">JXG</a> </li>
                                <li><a href="../classes/JXG.AbstractRenderer.html">JXG.AbstractRenderer</a> </li>
                                <li><a href="../classes/JXG.Board.html">JXG.Board</a> </li>
                                <li><a href="../classes/JXG.C.html">JXG.C</a> </li>
                                <li><a href="../classes/JXG.CanvasRenderer.html">JXG.CanvasRenderer</a> </li>
                                <li><a href="../classes/JXG.Chart.html">JXG.Chart</a> </li>
                                <li><a href="../classes/JXG.Circle.html">JXG.Circle</a> </li>
                                <li><a href="../classes/JXG.Complex.html">JXG.Complex</a> </li>
                                <li><a href="../classes/JXG.Composition.html">JXG.Composition</a> </li>
                                <li><a href="../classes/JXG.Coords.html">JXG.Coords</a> </li>
                                <li><a href="../classes/JXG.CoordsElement.html">JXG.CoordsElement</a> </li>
                                <li><a href="../classes/JXG.Curve.html">JXG.Curve</a> </li>
                                <li><a href="../classes/JXG.GeometryElement.html">JXG.GeometryElement</a> </li>
                                <li><a href="../classes/JXG.Group.html">JXG.Group</a> </li>
                                <li><a href="../classes/JXG.Image.html">JXG.Image</a> </li>
                                <li><a href="../classes/JXG.JSXGraph.html">JXG.JSXGraph</a> </li>
                                <li><a href="../classes/JXG.Line.html">JXG.Line</a> </li>
                                <li><a href="../classes/JXG.Math.html">JXG.Math</a> </li>
                                <li><a href="../classes/JXG.Math.Geometry.html">JXG.Math.Geometry</a> </li>
                                <li><a href="../classes/JXG.Math.Numerics.html">JXG.Math.Numerics</a> </li>
                                <li><a href="../classes/JXG.Math.Poly.html">JXG.Math.Poly</a> </li>
                                <li><a href="../classes/JXG.Math.Poly.Monomial.html">JXG.Math.Poly.Monomial</a> </li>
                                <li><a href="../classes/JXG.Math.Poly.Polynomial.html">JXG.Math.Poly.Polynomial</a> </li>
                                <li><a href="../classes/JXG.Math.Poly.Ring.html">JXG.Math.Poly.Ring</a> </li>
                                <li><a href="../classes/JXG.Math.Quadtree.html">JXG.Math.Quadtree</a> </li>
                                <li><a href="../classes/JXG.Math.Statistics.html">JXG.Math.Statistics</a> </li>
                                <li><a href="../classes/JXG.Math.Symbolic.html">JXG.Math.Symbolic</a> </li>
                                <li><a href="../classes/JXG.NoRenderer.html">JXG.NoRenderer</a> </li>
                                <li><a href="../classes/JXG.Options.html">JXG.Options</a> </li>
                                <li><a href="../classes/JXG.Point.html">JXG.Point</a> </li>
                                <li><a href="../classes/JXG.Polygon.html">JXG.Polygon</a> </li>
                                <li><a href="../classes/JXG.SVGRenderer.html">JXG.SVGRenderer</a> </li>
                                <li><a href="../classes/JXG.Text.html">JXG.Text</a> </li>
                                <li><a href="../classes/JXG.Ticks.html">JXG.Ticks</a> </li>
                                <li><a href="../classes/JXG.Transformation.html">JXG.Transformation</a> </li>
                                <li><a href="../classes/JXG.Turtle.html">JXG.Turtle</a> </li>
                                <li><a href="../classes/JXG.Util.Base64.html">JXG.Util.Base64</a> </li>
                                <li><a href="../classes/JXG.Util.Unzip.html">JXG.Util.Unzip</a> </li>
                                <li><a href="../classes/JXG.VMLRenderer.html">JXG.VMLRenderer</a> </li>
                                <li><a href="../classes/Line.html">Line</a> </li>
                                <li><a href="../classes/Locus.html">Locus</a> </li>
                                <li><a href="../classes/MajorArc.html">MajorArc</a> </li>
                                <li><a href="../classes/Midpoint.html">Midpoint</a> </li>
                                <li><a href="../classes/MinorArc.html">MinorArc</a> </li>
                                <li><a href="../classes/MinorSector.html">MinorSector</a> </li>
                                <li><a href="../classes/Mirrorpoint.html">Mirrorpoint</a> </li>
                                <li><a href="../classes/NonReflexAngle.html">NonReflexAngle</a> </li>
                                <li><a href="../classes/Normal.html">Normal</a> </li>
                                <li><a href="../classes/Orthogonalprojection.html">Orthogonalprojection</a> </li>
                                <li><a href="../classes/OtherIntersection.html">OtherIntersection</a> </li>
                                <li><a href="../classes/Parabola.html">Parabola</a> </li>
                                <li><a href="../classes/Parallel.html">Parallel</a> </li>
                                <li><a href="../classes/Parallelpoint.html">Parallelpoint</a> </li>
                                <li><a href="../classes/Perpendicular.html">Perpendicular</a> </li>
                                <li><a href="../classes/PerpendicularPoint.html">PerpendicularPoint</a> </li>
                                <li><a href="../classes/PerpendicularSegment.html">PerpendicularSegment</a> </li>
                                <li><a href="../classes/Point.html">Point</a> </li>
                                <li><a href="../classes/PolarLine.html">PolarLine</a> </li>
                                <li><a href="../classes/PolePoint.html">PolePoint</a> </li>
                                <li><a href="../classes/Polygon.html">Polygon</a> </li>
                                <li><a href="../classes/RadicalAxis.html">RadicalAxis</a> </li>
                                <li><a href="../classes/Reflection.html">Reflection</a> </li>
                                <li><a href="../classes/ReflexAngle.html">ReflexAngle</a> </li>
                                <li><a href="../classes/registerReader.html">registerReader</a> </li>
                                <li><a href="../classes/RegularPolygon.html">RegularPolygon</a> </li>
                                <li><a href="../classes/Riemannsum.html">Riemannsum</a> </li>
                                <li><a href="../classes/Sector.html">Sector</a> </li>
                                <li><a href="../classes/Segment.html">Segment</a> </li>
                                <li><a href="../classes/Semicircle.html">Semicircle</a> </li>
                                <li><a href="../classes/Slider.html">Slider</a> </li>
                                <li><a href="../classes/Slopetriangle.html">Slopetriangle</a> </li>
                                <li><a href="../classes/Spline.html">Spline</a> </li>
                                <li><a href="../classes/Stepfunction.html">Stepfunction</a> </li>
                                <li><a href="../classes/Tangent.html">Tangent</a> </li>
                                <li><a href="../classes/Tapemeasure.html">Tapemeasure</a> </li>
                                <li><a href="../classes/Text.html">Text</a> </li>
                                <li><a href="../classes/Ticks.html">Ticks</a> </li>
                                <li><a href="../classes/Tracecurve.html">Tracecurve</a> </li>
                                <li><a href="../classes/Transformation.html">Transformation</a> </li>
                                <li><a href="../classes/Turtle.html">Turtle</a> </li>
                            </ul>
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="../modules/JXG.html">JXG</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: src/reader/geonext.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/*
    Copyright 2008-2013
        Matthias Ehmann,
        Michael Gerhaeuser,
        Carsten Miller,
        Bianca Valentin,
        Alfred Wassermann,
        Peter Wilfahrt

    This file is part of JSXGraph.

    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.

    You can redistribute it and/or modify it under the terms of the

      * GNU Lesser General Public License as published by
        the Free Software Foundation, either version 3 of the License, or
        (at your option) any later version
      OR
      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT

    JSXGraph is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License and
    the MIT License along with JSXGraph. If not, see &lt;http://www.gnu.org/licenses/&gt;
    and &lt;http://opensource.org/licenses/MIT/&gt;.
 */

/*global JXG: true, XMLSerializer: true, Image: true*/
/*jslint nomen: true, plusplus: true*/

/* depends:
 jxg
 base/constants
 base/group
 parser/geonext
 utils/type
 utils/color
 utils/zip
 utils/base64
 utils/xml
  elements:
   image
   transform
   point
   line
   circle
   glider
   intersection
   arrowparallel
   bisector
   circumcircle
   circumcenter
   midpoint
   reflection
   mirrorpoint
   perpendicularsegment
   parallelpoint
   perpendicularpoint
   sector
   segment
   polygon
   curve
   arrow
   arc
   angle
   text
   tracecurve
   grid
   axis
 */

(function () {

    &quot;use strict&quot;;

    JXG.GeonextReader = function (board, str) {
        var content;

        this.board = board;
        content = this.prepareString(str);
        this.tree = JXG.XML.parse(content);
    };

    JXG.extend(JXG.GeonextReader.prototype, /** @lends JXG.GeonextReader.prototype */ {
        changeOriginIds: function (board, id) {
            if ((id === &#x27;gOOe0&#x27;) || (id === &#x27;gXOe0&#x27;) || (id === &#x27;gYOe0&#x27;) || (id === &#x27;gXLe0&#x27;) || (id === &#x27;gYLe0&#x27;)) {
                return board.id + id;
            }

            return id;
        },

        /**
         * Retrieves data by TagName from an XML node.
         * @param {Object} node The Node that contains the data we want to get.
         * @param {String} tag The Name of the tag we are looking for.
         * @param {Number} [idx=0] getElementsByTagName returns an array; This parameter decides which element to use.
         * @param {Boolean} [fc=true] If True, the result will be the &lt;tt&gt;data&lt;/tt&gt; of &lt;tt&gt;firstChild&lt;/tt&gt; instead of the result node.
         * @return {Object|Array|String} The gathered data
         */
        gEBTN: function (node, tag, idx, fc) {
            var tmp = [];

            if (!JXG.exists(node || !node.getElementsByTagName)) {
                return node;
            }

            // Default values for optional parameters idx and fc
            if (!JXG.exists(fc)) {
                fc = true;
            }

            idx = idx || 0;

            if (node.getElementsByTagName) {
                tmp = node.getElementsByTagName(tag);
            }
            if (tmp.length &gt; 0) {
                tmp = tmp[idx];
                if (fc &amp;&amp; tmp.firstChild) {
                    tmp = tmp.firstChild.data;
                }
            }

            return tmp;
        },

        /**
         * Set color properties of a geonext element.
         * Set stroke, fill, lighting, label and draft color attributes.
         * @param {Object} gxtEl element of which attributes are to set
         * @param {Object} Data
         * @return {Object} Returns gxtEl
         */
        colorProperties: function (gxtEl, Data) {
            var rgbo,
                color = this.gEBTN(Data, &#x27;color&#x27;, 0, false);

            //gxtEl.strokewidth = Data.getElementsByTagName(&#x27;strokewidth&#x27;)[0].firstChild.data;
            // colorStroke = strokeColor etc. is here for downwards compatibility:
            // once upon a time we used to create elements in here using the &quot;new JXG.Element&quot; constructor mechanism
            // then we changed to board.create + setProperty afterwords
            // now i want to use the board.create method with an appropriate attributes object to avoid setProperty calls
            // and as gxtEl happens to be somewhat like an attributes object it&#x27;s  just slightly different so we adjust it
            // for downwards compatibility during the transformation of this reader we use both properties

            rgbo = JXG.rgba2rgbo(this.gEBTN(color, &#x27;stroke&#x27;));
            gxtEl.strokeColor = rgbo[0];
            gxtEl.strokeOpacity = rgbo[1];

            rgbo = JXG.rgba2rgbo(this.gEBTN(color, &#x27;lighting&#x27;));
            gxtEl.highlightStrokeColor = rgbo[0];
            gxtEl.highlightStrokeOpacity = rgbo[1];

            rgbo = JXG.rgba2rgbo(this.gEBTN(color, &#x27;fill&#x27;));
            gxtEl.fillColor = rgbo[0];
            gxtEl.fillOpacity = rgbo[1];

            gxtEl.highlightFillColor = gxtEl.fillColor;
            gxtEl.highlightFillOpacity = gxtEl.fillOpacity;

            rgbo = JXG.rgba2rgbo(this.gEBTN(color, &#x27;label&#x27;));
            gxtEl.labelColor = rgbo[0];
            gxtEl.withLabel = rgbo[1] &gt; 0;
            gxtEl.labelOpacity = rgbo[1];
            
            gxtEl.colorDraft = JXG.rgba2rgbo(this.gEBTN(color, &#x27;draft&#x27;))[0];

            // backwards compatibility
            gxtEl.colorStroke = gxtEl.strokeColor;
            gxtEl.colorFill = gxtEl.fillColor;
            gxtEl.colorLabel = gxtEl.labelColor;

            return gxtEl;
        },

        firstLevelProperties: function (gxtEl, Data) {
            var n, key, arr;

            if (!JXG.exists(Data) || !JXG.exists(Data.childNodes)) {
                return gxtEl;
            }

            arr = Data.childNodes;

            for (n = 0; n &lt; arr.length; n++) {
                if (JXG.exists(arr[n].firstChild) &amp;&amp; arr[n].nodeName !== &#x27;data&#x27; &amp;&amp; arr[n].nodeName !== &#x27;straight&#x27;) {
                    key = arr[n].nodeName;

                    if (key === &#x27;width&#x27;) {
                        key = &#x27;strokewidth&#x27;;
                    }
                    gxtEl[key] = arr[n].firstChild.data;
                }
            }

            return gxtEl;
        },

        /**
         * Set the defining properties of a geonext element.
         * Writing the nodeName to ident; setting the name attribute and defining the element id.
         * @param {Object} gxtEl element of which attributes are to set
         * @param {Object} Data
         */
        defProperties: function (gxtEl, Data) {
            // 3==TEXT_NODE, 8==COMMENT_NODE
            if (Data.nodeType === 3 || Data.nodeType === 8) {
                return null;
            }

            gxtEl.ident = Data.nodeName;

            if (gxtEl.ident === &quot;text&quot; || gxtEl.ident === &quot;intersection&quot; || gxtEl.ident === &quot;composition&quot;) {
                gxtEl.name = &#x27;&#x27;;
            } else {
                gxtEl.name = this.gEBTN(Data, &#x27;name&#x27;);
            }

            gxtEl.id = this.gEBTN(Data, &#x27;id&#x27;);

            return gxtEl;
        },

        visualProperties: function (gxtEl, Data) {
            gxtEl.visible = JXG.str2Bool(this.gEBTN(Data, &#x27;visible&#x27;));
            gxtEl.trace = JXG.str2Bool(this.gEBTN(Data, &#x27;trace&#x27;));

            return gxtEl;
        },

        /**
         * Transforms the Geonext properties to jsxgraph properties
         * @param {Object} gxtEl
         * @param {String} [type]
         * @return {Object} gxtEl
         */
        transformProperties: function (gxtEl, type) {
            var i,
                facemap = [
                    // 0-2
                    &#x27;cross&#x27;, &#x27;cross&#x27;, &#x27;cross&#x27;,
                    // 3-6
                    &#x27;circle&#x27;, &#x27;circle&#x27;, &#x27;circle&#x27;, &#x27;circle&#x27;,
                    // 7-9
                    &#x27;square&#x27;, &#x27;square&#x27;, &#x27;square&#x27;,
                    // 10-12
                    &#x27;plus&#x27;, &#x27;plus&#x27;, &#x27;plus&#x27;
                ],
                sizemap = [
                    // 0-2
                    2, 3, 4,
                    // 3-6
                    1, 2, 3, 4,
                    // 7-9
                    2, 3, 4,
                    // 10-12
                    2, 3, 4
                ],
                remove = [
                    &#x27;color&#x27;, &#x27;dash&#x27;, &#x27;style&#x27;, &#x27;style&#x27;, &#x27;ident&#x27;, &#x27;colordraft&#x27;, &#x27;colorstroke&#x27;, &#x27;colorfill&#x27;,
                    &#x27;colorlabel&#x27;, &#x27;active&#x27;, &#x27;area&#x27;, &#x27;showinfo&#x27;, &#x27;showcoord&#x27;, &#x27;fix&#x27;
                ];

            gxtEl.strokeWidth = gxtEl.strokewidth;
            gxtEl.face = facemap[parseInt(gxtEl.style, 10)] || &#x27;cross&#x27;;
            gxtEl.size = sizemap[parseInt(gxtEl.style, 10)] || 3;

            gxtEl.straightFirst = JXG.str2Bool(gxtEl.straightFirst);
            gxtEl.straightLast = JXG.str2Bool(gxtEl.straightLast);

            gxtEl.visible = JXG.str2Bool(gxtEl.visible);
            //gxtEl.withLabel = gxtEl.visible;           // withLabel is set in colorProperties()
            gxtEl.draft = JXG.str2Bool(gxtEl.draft);
            gxtEl.trace = JXG.str2Bool(gxtEl.trace);

            if (type === &#x27;point&#x27;) {
                // Fill properties are ignored by GEONExT
                gxtEl.fillColor = gxtEl.strokeColor;
                gxtEl.highlightFillColor = gxtEl.highlightStrokeColor;
                gxtEl.fillOpacity = gxtEl.strokeOpacity;
                gxtEl.highlightFillOpacity = gxtEl.highlightStrokeOpacity;
            }

            if (typeof gxtEl.label === &#x27;string&#x27;) {
                delete gxtEl.label;
            }
            gxtEl.label = gxtEl.label || {
                opacity: gxtEl.labelOpacity
            };

            // clean up
            for (i = 0; i &lt; remove.length; i++) {
                delete gxtEl[remove[i]];
            }

            return gxtEl;
        },

        readNodes: function (gxtEl, Data, nodeType, prefix) {
            var key, n,
                arr = this.gEBTN(Data, nodeType, 0, false).childNodes;

            for (n = 0; n &lt; arr.length; n++) {
                if (JXG.exists(arr[n].firstChild)) {
                    if (JXG.exists(prefix)) {
                        key = prefix + JXG.capitalize(arr[n].nodeName);
                    } else {
                        key = arr[n].nodeName;
                    }
                    gxtEl[key] = arr[n].firstChild.data;
                }
            }
            return gxtEl;
        },

        subtreeToString: function (root) {
            try {
                // firefox
                return (new XMLSerializer()).serializeToString(root);
            } catch (e) {
                // IE
                return root.xml;
            }
        },

        readImage: function (node) {
            var pic = &#x27;&#x27;,
                nod = node;

            if (JXG.exists(nod)) {
                pic = nod.data;
                while (JXG.exists(nod.nextSibling)) {
                    nod = nod.nextSibling;
                    pic += nod.data;
                }
            }
            return pic;
        },

        parseImage: function (board, fileNode, level, x, y, w, h, el) {
            var tag, id, picStr, tmpImg,
                im = null;

            if (fileNode === null) {
                return im;
            }

            // Background image
            if (JXG.exists(fileNode.getElementsByTagName(&#x27;src&#x27;)[0])) {
                tag = &#x27;src&#x27;;
            } else if (JXG.exists(fileNode.getElementsByTagName(&#x27;image&#x27;)[0]) &amp;&amp;
                    JXG.exists(this.gEBTN(fileNode, &#x27;image&#x27;))) {
                tag = &#x27;image&#x27;;
            } else {
                return im;
            }

            picStr = this.readImage(this.gEBTN(fileNode, tag, 0, false).firstChild);
            if (picStr !== &#x27;&#x27;) {
                picStr = &#x27;data:image/png;base64,&#x27; + picStr;

                // Background image
                if (tag === &#x27;src&#x27;) {
                    x = this.gEBTN(fileNode, &#x27;x&#x27;);
                    y = this.gEBTN(fileNode, &#x27;y&#x27;);
                    w = this.gEBTN(fileNode, &#x27;width&#x27;);
                    h = this.gEBTN(fileNode, &#x27;height&#x27;);
                    im = board.create(&#x27;image&#x27;, [picStr, [x, y], [w, h]], {
                        anchor: el,
                        layer: level
                    });

                    return im;
                }
                // Image bound to an element
                // Read the original dimensions, i.e. the ratio h/w with the help of a temporary image.
                // We have to wait until the image is loaded, therefore
                // we need &quot;onload&quot;.
                tmpImg = new Image();
                tmpImg.src = picStr;
                id = el.id + &#x27;_image&#x27;;
                tmpImg.onload = function () {
                    // Now, we can read the original dimensions of the image.
                    var xf, yf, wf, hf, im, tRot,
                        wOrg = this.width,
                        hOrg = this.height;

                    if (el.elementClass === JXG.OBJECT_CLASS_LINE) {
                        // A line containing an image, runs through the horizontal middle
                        // of the image.
                        xf = function () {
                            return el.point1.X();
                        };
                        wf = function () {
                            return el.point1.Dist(el.point2);
                        };
                        hf = function () {
                            return wf() * hOrg / wOrg;
                        };
                        yf = function () {
                            return el.point1.Y() - hf() * 0.5;
                        };

                        im = board.create(&#x27;image&#x27;, [picStr, [xf, yf], [wf, hf]], {
                            layer: level,
                            id: id,
                            anchor: el
                        });

                        tRot = board.create(&#x27;transform&#x27;, [
                            function () {
                                return Math.atan2(el.point2.Y() - el.point1.Y(), el.point2.X() - el.point1.X());
                            },
                            el.point1
                        ], {type: &#x27;rotate&#x27;});

                        tRot.bindTo(im);
                        el.image = im;
                    } else if (el.elementClass === JXG.OBJECT_CLASS_POINT) {
                        wf = function () {
                            return wOrg / board.unitX;
                        };
                        hf = function () {
                            return hOrg / board.unitY;
                        };
                        xf = function () {
                            return el.X() - wf() * 0.5;
                        };
                        yf = function () {
                            return el.Y() - hf() * 0.5;
                        };

                        im = board.create(&#x27;image&#x27;, [picStr, [xf, yf], [wf, hf]], {
                            layer: level,
                            id: id,
                            anchor: el
                        });
                        board.renderer.hide(el.label);
                        el.image = im;
                    } else if (el.elementClass === JXG.OBJECT_CLASS_CIRCLE) {
                        // A circle containing an image
                        wf = function () {
                            return 2.0 * el.Radius();
                        };
                        hf = function () {
                            return wf() * hOrg / wOrg;
                        };
                        xf = function () {
                            return el.center.X() - wf() * 0.5;
                        };
                        yf = function () {
                            return el.center.Y() - hf() * 0.5;
                        };

                        im = board.create(&#x27;image&#x27;, [picStr, [xf, yf], [wf, hf]], {
                            layer: level,
                            id: id,
                            anchor: el
                        });
                        el.image = im;
                    } else {
                        im = board.create(&#x27;image&#x27;, [picStr, [x, y], [w, h]], {
                            layer: level,
                            id: id,
                            anchor: el
                        });
                        el.image = im;
                    }
                };

                return im;
            }
        },

        readConditions: function (node) {
            var i, s, ob,
                conditions = &#x27;&#x27;;

            if (JXG.exists(node)) {
                for (i = 0; i &lt; node.getElementsByTagName(&#x27;data&#x27;).length; i++) {
                    ob = node.getElementsByTagName(&#x27;data&#x27;)[i];
                    s = this.subtreeToString(ob);
                    conditions += s;
                }
            }

            return conditions;
        },

        readViewPort: function (node) {
            var no,
                arr = [];

            no = this.gEBTN(node, &#x27;viewport&#x27;, 0, false);

            if (no) {
                arr[0] = parseFloat(this.gEBTN(no, &#x27;left&#x27;));
                arr[1] = parseFloat(this.gEBTN(no, &#x27;top&#x27;));
                arr[2] = parseFloat(this.gEBTN(no, &#x27;right&#x27;));
                arr[3] = parseFloat(this.gEBTN(no, &#x27;bottom&#x27;));
                return arr;
            }

            return [];
        },

        printDebugMessage: function (outputEl, gxtEl, nodetyp, success) {
            JXG.debug(&quot;* &quot; + success + &quot;:  &quot; + nodetyp + &quot; &quot; + gxtEl.name + &quot; &quot; + gxtEl.id);
        },

        readNode: function (elChildNodes, s, board) {
            var dataVertex, i, l, x, c, numberDefEls, el, p, inter, rgbo, tmp, v, Data, xmlNode,
                gxtEl = {};

            Data = elChildNodes[s];
            gxtEl = this.defProperties(gxtEl, Data);

            // Skip text nodes
            if (!JXG.exists(gxtEl)) {
                return;
            }

            this.printDebugMessage(&#x27;debug&#x27;, gxtEl, Data.nodeName.toLowerCase(), &#x27;READ:&#x27;);
            switch (Data.nodeName.toLowerCase()) {
            case &quot;point&quot;:
                gxtEl.strokewidth = 1; // Old file format
                gxtEl = this.colorProperties(gxtEl, Data);
                gxtEl = this.visualProperties(gxtEl, Data);
                gxtEl = this.firstLevelProperties(gxtEl, Data);
                gxtEl = this.readNodes(gxtEl, Data, &#x27;data&#x27;);
                gxtEl.fixed = JXG.str2Bool(this.gEBTN(Data, &#x27;fix&#x27;));
                gxtEl = this.transformProperties(gxtEl, &#x27;point&#x27;);

                //try {
                p = board.create(&#x27;point&#x27;, [parseFloat(gxtEl.x), parseFloat(gxtEl.y)], gxtEl);

                v = function () {
                    return p.visProp.visible;
                };
                el = this.parseImage(board, Data, board.options.layer.image, 0, 0, 0, 0, p);
                this.printDebugMessage(&#x27;debug&#x27;, gxtEl, Data.nodeName, &#x27;OK&#x27;);
                break;
            case &quot;line&quot;:
                gxtEl = this.colorProperties(gxtEl, Data);
                gxtEl = this.visualProperties(gxtEl, Data);
                gxtEl = this.firstLevelProperties(gxtEl, Data);
                gxtEl = this.readNodes(gxtEl, Data, &#x27;data&#x27;);
                gxtEl = this.readNodes(gxtEl, Data, &#x27;straight&#x27;, &#x27;straight&#x27;);
                gxtEl = this.transformProperties(gxtEl);

                gxtEl.first = this.changeOriginIds(board, gxtEl.first);
                gxtEl.last = this.changeOriginIds(board, gxtEl.last);

                l = board.create(&#x27;line&#x27;, [gxtEl.first, gxtEl.last], gxtEl);

                this.parseImage(board, Data, board.options.layer.image, 0, 0, 0, 0, l);
                this.printDebugMessage(&#x27;debug&#x27;, gxtEl, Data.nodeName, &#x27;OK&#x27;);
                break;
            case &quot;circle&quot;:
                gxtEl = this.colorProperties(gxtEl, Data);
                gxtEl = this.visualProperties(gxtEl, Data);
                gxtEl = this.firstLevelProperties(gxtEl, Data);

                tmp = this.gEBTN(Data, &#x27;data&#x27;, 0, false);
                gxtEl.center = this.changeOriginIds(board, this.gEBTN(tmp, &#x27;midpoint&#x27;));

                if (tmp.getElementsByTagName(&#x27;radius&#x27;).length &gt; 0) {
                    gxtEl.radius = this.changeOriginIds(board, this.gEBTN(tmp, &#x27;radius&#x27;));
                } else if (tmp.getElementsByTagName(&#x27;radiusvalue&#x27;).length &gt; 0) {
                    gxtEl.radius = this.gEBTN(tmp, &#x27;radiusvalue&#x27;);
                }
                gxtEl = this.transformProperties(gxtEl);
                c = board.create(&#x27;circle&#x27;, [gxtEl.center, gxtEl.radius], gxtEl);

                this.parseImage(board, Data, board.options.layer.image, 0, 0, 0, 0, c);
                this.printDebugMessage(&#x27;debug&#x27;, gxtEl, Data.nodeName, &#x27;OK&#x27;);
                break;
            case &quot;slider&quot;:
                gxtEl.strokewidth = 1; // Old file format
                gxtEl = this.colorProperties(gxtEl, Data);
                gxtEl = this.visualProperties(gxtEl, Data);
                gxtEl = this.firstLevelProperties(gxtEl, Data);

                gxtEl = this.readNodes(gxtEl, Data, &#x27;data&#x27;);
                gxtEl.fixed = JXG.str2Bool(this.gEBTN(Data, &#x27;fix&#x27;));
                gxtEl = this.readNodes(gxtEl, Data, &#x27;animate&#x27;, &#x27;animate&#x27;);
                gxtEl = this.transformProperties(gxtEl, &#x27;point&#x27;);
                try {
                    gxtEl.parent = this.changeOriginIds(board, gxtEl.parent);
                    gxtEl.isGeonext = true;
                    
                    p = board.create(&#x27;glider&#x27;, [parseFloat(gxtEl.x), parseFloat(gxtEl.y), gxtEl.parent], gxtEl);
                    p.onPolygon = JXG.exists(gxtEl.onpolygon) &amp;&amp; JXG.str2Bool(gxtEl.onpolygon);

                    this.parseImage(board, Data, board.options.layer.point, 0, 0, 0, 0, p);

                    this.printDebugMessage(&#x27;debug&#x27;, gxtEl, Data.nodeName, &#x27;OK&#x27;);
                } catch (e) {
                    JXG.debug(&quot;* Err:  Slider &quot; + gxtEl.name + &quot; &quot; + gxtEl.id + &#x27;: &#x27; + gxtEl.parent);
                }
                break;
            case &quot;cas&quot;:
                gxtEl = this.colorProperties(gxtEl, Data);
                gxtEl = this.visualProperties(gxtEl, Data);
                gxtEl = this.firstLevelProperties(gxtEl, Data);
                gxtEl.fixed = JXG.str2Bool(Data.getElementsByTagName(&#x27;fix&#x27;)[0].firstChild.data);
                gxtEl = this.readNodes(gxtEl, Data, &#x27;data&#x27;);
                gxtEl = this.transformProperties(gxtEl, &#x27;point&#x27;);

                p = board.create(&#x27;point&#x27;, [gxtEl.x, gxtEl.y], gxtEl);
                this.parseImage(board, Data, board.options.layer.point, 0, 0, 0, 0, p);
                this.printDebugMessage(&#x27;debug&#x27;, gxtEl, Data.nodeName, &#x27;OK&#x27;);
                break;
            case &quot;intersection&quot;:
                gxtEl.strokewidth = 1; // Old file format
                gxtEl = this.readNodes(gxtEl, Data, &#x27;data&#x27;);
                xmlNode = Data.getElementsByTagName(&#x27;first&#x27;)[1];

                gxtEl.outFirst = {};
                gxtEl.outFirst = this.colorProperties(gxtEl.outFirst, xmlNode);
                gxtEl.outFirst = this.visualProperties(gxtEl.outFirst, xmlNode);
                gxtEl.outFirst = this.firstLevelProperties(gxtEl.outFirst, xmlNode);
                gxtEl.outFirst.fixed = JXG.str2Bool(xmlNode.getElementsByTagName(&#x27;fix&#x27;)[0].firstChild.data);
                gxtEl.outFirst = this.transformProperties(gxtEl.outFirst, &#x27;point&#x27;);
                gxtEl.first = this.changeOriginIds(board, gxtEl.first);
                gxtEl.last = this.changeOriginIds(board, gxtEl.last);

                if ((board.select(gxtEl.first).elementClass === JXG.OBJECT_CLASS_LINE) &amp;&amp;
                        (board.select(gxtEl.last).elementClass === JXG.OBJECT_CLASS_LINE)) {
                    inter = board.create(&#x27;intersection&#x27;, [board.objects[gxtEl.first], board.objects[gxtEl.last], 0], gxtEl.outFirst);
                    /* for some reason this if is required */
                    if (gxtEl.outFirst.visible === &quot;false&quot;) {
                        inter.hideElement();
                    }
                } else {
                    xmlNode = Data.getElementsByTagName(&#x27;last&#x27;)[1];
                    if (JXG.exists(xmlNode)) {
                        gxtEl.outLast = {};
                        gxtEl.outLast = this.colorProperties(gxtEl.outLast, xmlNode);
                        gxtEl.outLast = this.visualProperties(gxtEl.outLast, xmlNode);
                        gxtEl.outLast = this.firstLevelProperties(gxtEl.outLast, xmlNode);
                        gxtEl.outLast.fixed = JXG.str2Bool(xmlNode.getElementsByTagName(&#x27;fix&#x27;)[0].firstChild.data);
                        gxtEl.outLast = this.transformProperties(gxtEl.outLast, &#x27;point&#x27;);

                        inter = board.create(&#x27;intersection&#x27;, [board.objects[gxtEl.first], board.objects[gxtEl.last], 0], gxtEl.outFirst);
                        inter = board.create(&#x27;intersection&#x27;, [board.objects[gxtEl.first], board.objects[gxtEl.last], 1], gxtEl.outLast);
                    }
                }
                this.printDebugMessage(&#x27;debug&#x27;, gxtEl, Data.nodeName, &#x27;OK&#x27;);
                break;
            case &quot;composition&quot;:
                gxtEl = this.readNodes(gxtEl, Data, &#x27;data&#x27;);
                gxtEl = this.firstLevelProperties(gxtEl, Data);
                gxtEl.defEl = [];
                numberDefEls = 0;
                xmlNode = Data.getElementsByTagName(&#x27;data&#x27;)[0].getElementsByTagName(&#x27;input&#x27;);
                for (i = 0; i &lt; xmlNode.length; i++) {
                    gxtEl.defEl[i] = xmlNode[i].firstChild.data;
                    numberDefEls = i + 1;
                }

                // every composition produces at least one element and the data for this element is stored
                // in gxtEl.out. if additional elements are created their data is read in the according case.
                xmlNode = Data.getElementsByTagName(&#x27;output&#x27;)[0];
                gxtEl.out = {};
                gxtEl.out = this.colorProperties(gxtEl.out, xmlNode);
                gxtEl.out = this.visualProperties(gxtEl.out, xmlNode);
                gxtEl.out = this.firstLevelProperties(gxtEl.out, xmlNode);
                gxtEl.out = this.transformProperties(gxtEl.out);

                gxtEl.defEl[0] = this.changeOriginIds(board, gxtEl.defEl[0]);
                gxtEl.defEl[1] = this.changeOriginIds(board, gxtEl.defEl[1]);
                gxtEl.defEl[2] = this.changeOriginIds(board, gxtEl.defEl[2]);

                switch (gxtEl.type) {
                // ARROW_PARALLEL
                case &quot;210070&quot;:
                    gxtEl.out.fixed = this.gEBTN(xmlNode, &#x27;fix&#x27;);

                    xmlNode = Data.getElementsByTagName(&#x27;output&#x27;)[1];
                    gxtEl.outPoint = {};
                    gxtEl.outPoint = this.defProperties(gxtEl.outPoint, xmlNode);
                    gxtEl.outPoint = this.colorProperties(gxtEl.outPoint, xmlNode);
                    gxtEl.outPoint = this.visualProperties(gxtEl.outPoint, xmlNode);
                    gxtEl.outPoint = this.firstLevelProperties(gxtEl.outPoint, xmlNode);
                    gxtEl.outPoint = this.transformProperties(gxtEl.outPoint);

                    // construct this by hand, because arrowparallel uses projective geometry now
                    p =  board.create(&#x27;parallelpoint&#x27;, [gxtEl.defEl[1], gxtEl.defEl[0]], gxtEl.outPoint);
                    gxtEl.out.firstArrow = false;
                    gxtEl.out.lastArrow = true;
                    el = board.create(&#x27;segment&#x27;, [gxtEl.defEl[0], p], gxtEl.out);
                    el.parallelpoint = p;
                    break;

                // BISECTOR
                case &quot;210080&quot;:
                    gxtEl.out.straightFirst = false;
                    board.create(&#x27;bisector&#x27;, [gxtEl.defEl[0], gxtEl.defEl[1], gxtEl.defEl[2]], gxtEl.out);
                    break;

                // CIRCUMCIRCLE
                case &quot;210090&quot;:
                    xmlNode = Data.getElementsByTagName(&#x27;output&#x27;)[1];
                    gxtEl.outCircle = {};
                    gxtEl.outCircle = this.defProperties(gxtEl.outCircle, xmlNode);
                    gxtEl.outCircle = this.colorProperties(gxtEl.outCircle, xmlNode);
                    gxtEl.outCircle = this.visualProperties(gxtEl.outCircle, xmlNode);
                    gxtEl.outCircle = this.firstLevelProperties(gxtEl.outCircle, xmlNode);
                    gxtEl.outCircle = this.transformProperties(gxtEl.outCircle);
                    gxtEl.outCircle.point = gxtEl.out;
                    board.create(&#x27;circumcircle&#x27;, [gxtEl.defEl[0], gxtEl.defEl[1], gxtEl.defEl[2]], gxtEl.outCircle);
                    break;

                // CIRCUMCIRCLE_CENTER
                case &quot;210100&quot;:
                    board.create(&#x27;circumcenter&#x27;, [gxtEl.defEl[0], gxtEl.defEl[1], gxtEl.defEl[2]], gxtEl.out);
                    break;

                // MIDPOINT
                case &quot;210110&quot;:
                    board.create(&#x27;midpoint&#x27;, gxtEl.defEl.slice(0, numberDefEls), gxtEl.out);
                    break;

                // MIRRORLINE
                case &quot;210120&quot;:
                    board.create(&#x27;reflection&#x27;, [gxtEl.defEl[1], gxtEl.defEl[0]], gxtEl.out);
                    break;

                // MIRROR_POINT
                case &quot;210125&quot;:
                    board.create(&#x27;mirrorpoint&#x27;, [gxtEl.defEl[0], gxtEl.defEl[1]], gxtEl.out);
                    break;

                // NORMAL
                case &quot;210130&quot;:
                    //board.create(&#x27;normal&#x27;, [gxtEl.defEl[1], gxtEl.defEl[0]], gxtEl.out);
                    board.create(&#x27;perpendicularsegment&#x27;, [gxtEl.defEl[0], gxtEl.defEl[1]], gxtEl.out);
                    break;

                // PARALLEL
                case &quot;210140&quot;:
                    p =  board.create(&#x27;parallelpoint&#x27;, [gxtEl.defEl[1], gxtEl.defEl[0]], {
                        withLabel: false,
                        visible: false,
                        name: &#x27;&#x27;,
                        fixed: true
                    });

                    // GEONExT uses its own parallel construction to make the order
                    // of intersection points compatible.
                    // el = board.create(&#x27;parallel&#x27;, [gxtEl.defEl[1], gxtEl.defEl[0]], gxtEl.out);
                    el = board.create(&#x27;line&#x27;, [gxtEl.defEl[0], p], gxtEl.out);
                    el.parallelpoint = p;
                    break;

                // PARALLELOGRAM_POINT
                case &quot;210150&quot;:
                    board.create(&#x27;parallelpoint&#x27;, gxtEl.defEl.slice(0, numberDefEls), gxtEl.out);
                    break;

                // PERPENDICULAR
                case &quot;210160&quot;:
                    // output[0] was already read and is stored in gxtEl.out
                    gxtEl.out.fixed = this.gEBTN(xmlNode, &#x27;fix&#x27;);

                    xmlNode = Data.getElementsByTagName(&#x27;output&#x27;)[1];
                    gxtEl.outLine = {};
                    gxtEl.outLine = this.defProperties(gxtEl.outLine, xmlNode);
                    gxtEl.outLine = this.colorProperties(gxtEl.outLine, xmlNode);
                    gxtEl.outLine = this.visualProperties(gxtEl.outLine, xmlNode);
                    gxtEl.outLine = this.firstLevelProperties(gxtEl.outLine, xmlNode);
                    gxtEl.outLine = this.readNodes(gxtEl.outLine, xmlNode, &#x27;straight&#x27;, &#x27;straight&#x27;);
                    gxtEl.outLine = this.transformProperties(gxtEl.outLine);
                    gxtEl.outLine.point = gxtEl.out;

                    board.create(&#x27;perpendicularsegment&#x27;, [gxtEl.defEl[1], gxtEl.defEl[0]], gxtEl.outLine);
                    break;

                // PERPENDICULAR_POINT
                case &quot;210170&quot;:
                    board.create(&#x27;perpendicularpoint&#x27;, [gxtEl.defEl[1], gxtEl.defEl[0]], gxtEl.out);
                    break;

                // ROTATION
                case &quot;210180&quot;:
                    throw new Error(&#x27;JSXGraph: Element ROTATION not yet implemented.&#x27;);

                // SECTOR
                case &quot;210190&quot;:
                    // sectors usually provide more than one output element but JSXGraph is not fully compatible
                    // to GEONExT sector elements. GEONExT sectors consist of two lines, a point, and a sector,
                    // JSXGraph uses a curve to display the sector incl. the borders, and
                    // a point and two lines.
                    // Gliders on sectors also run through the borders.
                    gxtEl.out = this.defProperties(gxtEl.out, xmlNode);
                    gxtEl.out.firstArrow = JXG.str2Bool(this.gEBTN(xmlNode, &#x27;firstarrow&#x27;));
                    gxtEl.out.lastArrow = JXG.str2Bool(this.gEBTN(xmlNode, &#x27;lastarrow&#x27;));

                    xmlNode = [];
                    c = [];

                    for (i = 0; i &lt; 4; i++) {
                        xmlNode[i] = Data.getElementsByTagName(&#x27;output&#x27;)[i];
                        gxtEl.out = {};
                        gxtEl.out = this.defProperties(gxtEl.out, xmlNode[i]);
                        gxtEl.out = this.colorProperties(gxtEl.out, xmlNode[i]);
                        gxtEl.out = this.visualProperties(gxtEl.out, xmlNode[i]);
                        gxtEl.out = this.firstLevelProperties(gxtEl.out, xmlNode[i]);
                        gxtEl.out = this.transformProperties(gxtEl.out);
                        c[i] = gxtEl.out;
                    }

                    // i === 0
                    el = board.create(&#x27;sector&#x27;, gxtEl.defEl, c[0]);

                    // i === 1
                    p = board.create(&#x27;point&#x27;, [
                        function () {
                            var p1 = board.select(gxtEl.defEl[1]),
                                p2 = board.select(gxtEl.defEl[2]);

                            return p1.X() + (p2.X() - p1.X()) * el.Radius / p1.Dist(p2);
                        },
                        function () {
                            var p1 = board.select(gxtEl.defEl[1]),
                                p2 = board.select(gxtEl.defEl[2]);

                            return p1.Y() + (p2.Y() - p1.Y()) * el.Radius / p1.Dist(p2);
                        }
                    ], c[1]);

                    // i === 2
                    el = board.create(&#x27;segment&#x27;, [gxtEl.defEl[0], gxtEl.defEl[1]], c[2]);

                    // i === 3
                    el = board.create(&#x27;segment&#x27;, [gxtEl.defEl[1], p], c[3]);
                    break;
                default:
                    throw new Error(&#x27;JSXGraph: GEONExT -- element &#x27; + gxtEl.type + &#x27; not implemented.&#x27;);
                }
                this.printDebugMessage(&#x27;debug&#x27;, gxtEl, Data.nodeName, &#x27;OK&#x27;);
                break;
            case &quot;polygon&quot;:
                gxtEl = this.colorProperties(gxtEl, Data);
                gxtEl = this.firstLevelProperties(gxtEl, Data);
                dataVertex = [];

                // In Geonext file format the first vertex is equal to the last vertex:
                for (i = 0; i &lt; Data.getElementsByTagName(&#x27;data&#x27;)[0].getElementsByTagName(&#x27;vertex&#x27;).length - 1; i++) {
                    dataVertex[i] = Data.getElementsByTagName(&#x27;data&#x27;)[0].getElementsByTagName(&#x27;vertex&#x27;)[i].firstChild.data;
                    dataVertex[i] = this.changeOriginIds(board, dataVertex[i]);
                }
                gxtEl.border = [];
                gxtEl.borders = {
                    ids: [],
                    names: []
                };
                for (i = 0; i &lt; Data.getElementsByTagName(&#x27;border&#x27;).length; i++) {
                    gxtEl.border[i] = {};
                    xmlNode = Data.getElementsByTagName(&#x27;border&#x27;)[i];
                    gxtEl.border[i].id = xmlNode.getElementsByTagName(&#x27;id&#x27;)[0].firstChild.data;
                    gxtEl.borders.ids.push(gxtEl.border[i].id);
                    gxtEl.border[i].name = xmlNode.getElementsByTagName(&#x27;name&#x27;)[0].firstChild.data;
                    gxtEl.borders.names.push(gxtEl.border[i].name);

                    gxtEl.border[i].straightFirst = JXG.str2Bool(xmlNode.getElementsByTagName(&#x27;straight&#x27;)[0].getElementsByTagName(&#x27;first&#x27;)[0].firstChild.data);
                    gxtEl.border[i].straightLast = JXG.str2Bool(xmlNode.getElementsByTagName(&#x27;straight&#x27;)[0].getElementsByTagName(&#x27;last&#x27;)[0].firstChild.data);
                    try {
                        gxtEl.border[i].strokeWidth = xmlNode.getElementsByTagName(&#x27;strokewidth&#x27;)[0].firstChild.data;
                    } catch (ex) {
                        gxtEl.border[i].strokeWidth = xmlNode.getElementsByTagName(&#x27;width&#x27;)[0].firstChild.data;
                    }
                    try {
                        gxtEl.border[i].dash = JXG.str2Bool(xmlNode.getElementsByTagName(&#x27;dash&#x27;)[0].firstChild.data);
                    } catch (exc) {}

                    gxtEl.border[i].visible = JXG.str2Bool(xmlNode.getElementsByTagName(&#x27;visible&#x27;)[0].firstChild.data);
                    gxtEl.border[i].draft = JXG.str2Bool(xmlNode.getElementsByTagName(&#x27;draft&#x27;)[0].firstChild.data);
                    gxtEl.border[i].trace = JXG.str2Bool(xmlNode.getElementsByTagName(&#x27;trace&#x27;)[0].firstChild.data);

                    xmlNode = Data.getElementsByTagName(&#x27;border&#x27;)[i].getElementsByTagName(&#x27;color&#x27;)[0];
                    rgbo = JXG.rgba2rgbo(xmlNode.getElementsByTagName(&#x27;stroke&#x27;)[0].firstChild.data);
                    gxtEl.border[i].strokeColor = rgbo[0];
                    gxtEl.border[i].strokeOpacity = rgbo[1];

                    rgbo = JXG.rgba2rgbo(xmlNode.getElementsByTagName(&#x27;lighting&#x27;)[0].firstChild.data);
                    gxtEl.border[i].highlightStrokeColor = rgbo[0];
                    gxtEl.border[i].highlightStrokeOpacity = rgbo[1];

                    rgbo = JXG.rgba2rgbo(xmlNode.getElementsByTagName(&#x27;fill&#x27;)[0].firstChild.data);
                    gxtEl.border[i].fillColor = rgbo[0];
                    gxtEl.border[i].fillOpacity = rgbo[1];

                    gxtEl.border[i].highlightFillColor = gxtEl.border[i].fillColor;
                    gxtEl.border[i].highlightFillOpacity = gxtEl.border[i].fillOpacity;

                    gxtEl.border[i].labelColor = xmlNode.getElementsByTagName(&#x27;label&#x27;)[0].firstChild.data;
                    gxtEl.border[i].colorDraft = xmlNode.getElementsByTagName(&#x27;draft&#x27;)[0].firstChild.data;
                }
                gxtEl = this.transformProperties(gxtEl);
                p = board.create(&#x27;polygon&#x27;, dataVertex, gxtEl);

                // to emulate the geonext behaviour on invisible polygons
                // A.W.: Why do we need this?
                /*
                 if (!gxtEl.visible) {
                 p.setAttribute({
                 fillColor: &#x27;none&#x27;,
                 highlightFillColor: &#x27;none&#x27;
                 });
                 }
                 */
                for (i = 0; i &lt; p.borders.length; i++) {
                    p.borders[i].setAttribute(gxtEl.border[i]);
                }

                this.printDebugMessage(&#x27;debug&#x27;, gxtEl, Data.nodeName, &#x27;OK&#x27;);
                break;
            case &quot;graph&quot;:
                gxtEl = this.colorProperties(gxtEl, Data);
                gxtEl = this.firstLevelProperties(gxtEl, Data);
                gxtEl.funct = Data.getElementsByTagName(&#x27;data&#x27;)[0].getElementsByTagName(&#x27;function&#x27;)[0].firstChild.data;
                gxtEl.funct = board.jc.snippet(gxtEl.funct, true, &#x27;x&#x27;, true);

                c = board.create(&#x27;plot&#x27;, [gxtEl.funct], {
                    id: gxtEl.id,
                    name: gxtEl.name,
                    strokeColor: gxtEl.strokeColor,
                    strokeWidth: gxtEl.strokeWidth,
                    fillColor: &#x27;none&#x27;,
                    highlightFillColor: &#x27;none&#x27;,
                    highlightStrokeColor: gxtEl.highlightStrokeColor,
                    visible: JXG.str2Bool(gxtEl.visible)
                });

                this.printDebugMessage(&#x27;debug&#x27;, gxtEl, Data.nodeName, &#x27;OK&#x27;);
                break;
            case &quot;arrow&quot;:
                gxtEl = this.colorProperties(gxtEl, Data);
                gxtEl = this.visualProperties(gxtEl, Data);
                gxtEl = this.firstLevelProperties(gxtEl, Data);
                gxtEl = this.readNodes(gxtEl, Data, &#x27;data&#x27;);
                gxtEl = this.readNodes(gxtEl, Data, &#x27;straight&#x27;, &#x27;straight&#x27;);

                gxtEl = this.transformProperties(gxtEl);
                gxtEl.first = this.changeOriginIds(board, gxtEl.first);
                gxtEl.last = this.changeOriginIds(board, gxtEl.last);

                l = board.create(&#x27;arrow&#x27;, [gxtEl.first, gxtEl.last], gxtEl);

                this.printDebugMessage(&#x27;debug&#x27;, l, Data.nodeName, &#x27;OK&#x27;);
                break;
            case &quot;arc&quot;:
                gxtEl = this.colorProperties(gxtEl, Data);
                gxtEl = this.visualProperties(gxtEl, Data);
                gxtEl = this.firstLevelProperties(gxtEl, Data);
                gxtEl = this.readNodes(gxtEl, Data, &#x27;data&#x27;);

                // It seems that JSXGraph and GEONExT use opposite directions.
                gxtEl.firstArrow = JXG.str2Bool(Data.getElementsByTagName(&#x27;lastarrow&#x27;)[0].firstChild.data);
                gxtEl.lastArrow = JXG.str2Bool(Data.getElementsByTagName(&#x27;firstarrow&#x27;)[0].firstChild.data);

                gxtEl = this.transformProperties(gxtEl);

                gxtEl.center = this.changeOriginIds(board, gxtEl.midpoint);
                gxtEl.angle = this.changeOriginIds(board, gxtEl.angle);
                gxtEl.radius = this.changeOriginIds(board, gxtEl.radius);

                c = board.create(&#x27;arc&#x27;, [gxtEl.center, gxtEl.radius, gxtEl.angle], gxtEl);

                this.printDebugMessage(&#x27;debug&#x27;, c, Data.nodeName, &#x27;OK&#x27;);
                break;
            case &quot;angle&quot;:
                gxtEl = this.colorProperties(gxtEl, Data);
                gxtEl = this.visualProperties(gxtEl, Data);
                gxtEl = this.firstLevelProperties(gxtEl, Data);
                gxtEl = this.readNodes(gxtEl, Data, &#x27;data&#x27;);
                gxtEl = this.transformProperties(gxtEl);
                gxtEl.radius *= 1.0;

                c = board.create(&#x27;angle&#x27;, [gxtEl.first, gxtEl.middle, gxtEl.last], gxtEl);
                this.printDebugMessage(&#x27;debug&#x27;, gxtEl, Data.nodeName, &#x27;OK&#x27;);
                break;
            case &quot;text&quot;:
                if (gxtEl.id.match(/oldVersion/)) {
                    break;
                }
                gxtEl = this.colorProperties(gxtEl, Data);
                gxtEl = this.visualProperties(gxtEl, Data);
                gxtEl = this.firstLevelProperties(gxtEl, Data);

                gxtEl = this.readNodes(gxtEl, Data, &#x27;data&#x27;);
                try {
                    gxtEl.mpStr = this.subtreeToString(Data.getElementsByTagName(&#x27;data&#x27;)[0].getElementsByTagName(&#x27;mp&#x27;)[0]);
                    gxtEl.mpStr = gxtEl.mpStr.replace(/&lt;\/?mp&gt;/g, &#x27;&#x27;);
                } catch (ex1) {
                    gxtEl.mpStr = this.subtreeToString(Data.getElementsByTagName(&#x27;data&#x27;)[0].getElementsByTagName(&#x27;content&#x27;)[0]);
                    gxtEl.mpStr = gxtEl.mpStr.replace(/&lt;\/?content&gt;/g, &#x27;&#x27;);
                }
                gxtEl.fixed = false;
                try {
                    if (Data.getElementsByTagName(&#x27;data&#x27;)[0].getElementsByTagName(&#x27;parent&#x27;)[0].firstChild) {
                        gxtEl.parent = Data.getElementsByTagName(&#x27;data&#x27;)[0].getElementsByTagName(&#x27;parent&#x27;)[0].firstChild.data;
                        gxtEl.fixed = true;
                    }
                } catch (ex2) {}

                try {
                    gxtEl.condition = Data.getElementsByTagName(&#x27;condition&#x27;)[0].firstChild.data;
                } catch (ex3) {
                    gxtEl.condition = &quot;&quot;;
                }
                gxtEl.content = Data.getElementsByTagName(&#x27;content&#x27;)[0].firstChild.data;
                try {
                    gxtEl.fixed = Data.getElementsByTagName(&#x27;fix&#x27;)[0].firstChild.data;
                } catch (ex4) {
                    gxtEl.fixed = false;
                }
                // not used: gxtEl.digits = Data.getElementsByTagName(&#x27;cs&#x27;)[0].firstChild.data;
                try {
                    gxtEl.autodigits = Data.getElementsByTagName(&#x27;digits&#x27;)[0].firstChild.data;
                } catch (ex5) {
                    gxtEl.autodigits = 2;
                }
                gxtEl.parent = this.changeOriginIds(board, gxtEl.parent);

                c = board.create(&#x27;text&#x27;, [parseFloat(gxtEl.x), parseFloat(gxtEl.y), gxtEl.mpStr], {
                    anchor: gxtEl.parent,
                    id: gxtEl.id,
                    name: gxtEl.name,
                    digits: gxtEl.autodigits,
                    isLabel: false,
                    strokeColor: gxtEl.colorLabel,
                    fixed: gxtEl.fixed,
                    visible: JXG.str2Bool(gxtEl.visible)
                });
                break;
            case &#x27;parametercurve&#x27;:
                gxtEl = this.colorProperties(gxtEl, Data);
                gxtEl = this.visualProperties(gxtEl, Data);
                gxtEl = this.firstLevelProperties(gxtEl, Data);
                gxtEl = this.transformProperties(gxtEl);
                gxtEl.functionx = Data.getElementsByTagName(&#x27;functionx&#x27;)[0].firstChild.data;
                gxtEl.functiony = Data.getElementsByTagName(&#x27;functiony&#x27;)[0].firstChild.data;
                gxtEl.min = Data.getElementsByTagName(&#x27;min&#x27;)[0].firstChild.data;
                gxtEl.max = Data.getElementsByTagName(&#x27;max&#x27;)[0].firstChild.data;
                gxtEl.fillColor = &#x27;none&#x27;;
                gxtEl.highlightFillColor = &#x27;none&#x27;;

                // intentional
                /*jslint evil:true*/
                board.create(&#x27;curve&#x27;, [
                    board.jc.snippet(gxtEl.functionx, true, &#x27;t&#x27;, true),
                    board.jc.snippet(gxtEl.functiony, true, &#x27;t&#x27;, true),
                    board.jc.snippet(gxtEl.min, true, &#x27;&#x27;, true),
                    board.jc.snippet(gxtEl.max, true, &#x27;&#x27;, true)
                ], gxtEl);
                /*jslint evil:false*/
                this.printDebugMessage(&#x27;debug&#x27;, gxtEl, Data.nodeName, &#x27;OK&#x27;);
                break;
            case &#x27;tracecurve&#x27;:
                gxtEl.tracepoint = Data.getElementsByTagName(&#x27;tracepoint&#x27;)[0].firstChild.data;
                gxtEl.traceslider = Data.getElementsByTagName(&#x27;traceslider&#x27;)[0].firstChild.data;
                board.create(&#x27;tracecurve&#x27;, [gxtEl.traceslider, gxtEl.tracepoint], gxtEl);
                this.printDebugMessage(&#x27;debug&#x27;, gxtEl, Data.nodeName, &#x27;OK&#x27;);
                break;
            case &#x27;group&#x27;:
                gxtEl = this.colorProperties(gxtEl, Data);
                gxtEl = this.firstLevelProperties(gxtEl, Data);
                gxtEl.members = [];

                for (i = 0; i &lt; Data.getElementsByTagName(&#x27;data&#x27;)[0].getElementsByTagName(&#x27;member&#x27;).length; i++) {
                    gxtEl.members[i] = Data.getElementsByTagName(&#x27;data&#x27;)[0].getElementsByTagName(&#x27;member&#x27;)[i].firstChild.data;
                    gxtEl.members[i] = this.changeOriginIds(board, gxtEl.members[i]);
                }

                c = new JXG.Group(board, gxtEl.id, gxtEl.name, gxtEl.members);
                this.printDebugMessage(&#x27;debug&#x27;, gxtEl, Data.nodeName, &#x27;OK&#x27;);
                break;
            default:
                JXG.debug(&quot;* Err: &quot; + Data.nodeName + &quot; not yet implemented&quot;);
            }
        },

        /**
         * Reading the elements of a geonext file
         */
        read: function () {
            var xmlNode, elChildNodes, s, boardData, conditions, tmp,
                tree = this.tree,
                board = this.board,
                strTrue = &#x27;true&#x27;;

            // maybe this is not necessary as we already provide layer options for sectors and circles via JXG.Options but
            // maybe these have to be the same for geonext.
            board.options.layer.sector = board.options.layer.angle;
            board.options.layer.circle = board.options.layer.angle;

            board.options.line.label.position = &#x27;top&#x27;;

            boardData = this.gEBTN(tree, &#x27;board&#x27;, 0, false);
            conditions = this.readConditions(boardData.getElementsByTagName(&#x27;conditions&#x27;)[0]);

            // set the board background color
            s = this.gEBTN(boardData, &#x27;background&#x27;, 0, false);
            s = this.gEBTN(s, &#x27;color&#x27;, 0, true);
            tmp = JXG.rgba2rgbo(s);
            s = JXG.rgbParser(tmp[0]);
            board.containerObj.style.backgroundColor = &#x27;rgba(&#x27; + s[0] + &#x27;, &#x27; + s[1] + &#x27;, &#x27; + s[2] + &#x27;, &#x27; + tmp[1] + &#x27;)&#x27;;

            // resize board
            if (board.attr.takeSizeFromFile) {
                board.resizeContainer(this.gEBTN(boardData, &#x27;width&#x27;), this.gEBTN(boardData, &#x27;height&#x27;));
            }

            xmlNode = this.gEBTN(boardData, &#x27;coordinates&#x27;, 0, false);

            tmp = this.readViewPort(xmlNode);
            
            if (tmp.length === 4) {
                board.setBoundingBox(tmp, true);
            } else {
                // zoom level
                tmp = this.gEBTN(xmlNode, &#x27;zoom&#x27;, 0, false);
                board.zoomX = parseFloat(this.gEBTN(tmp, &#x27;x&#x27;));
                board.zoomY = parseFloat(this.gEBTN(tmp, &#x27;y&#x27;));

                // set the origin
                tmp = this.gEBTN(xmlNode, &#x27;origin&#x27;, 0, false);
                board.origin = {
                    usrCoords: [1, 0, 0],
                    scrCoords: [1, parseFloat(this.gEBTN(tmp, &#x27;x&#x27;)) * board.zoomX, parseFloat(this.gEBTN(tmp, &#x27;y&#x27;)) * board.zoomY]
                };

                // screen to user coordinates conversion
                tmp = this.gEBTN(xmlNode, &#x27;unit&#x27;, 0, false);
                board.unitX = parseFloat(this.gEBTN(tmp, &#x27;x&#x27;)) * board.zoomX;
                board.unitY = parseFloat(this.gEBTN(tmp, &#x27;y&#x27;)) * board.zoomY;
            }

            if (board.attr.takeSizeFromFile) {
                board.resizeContainer(this.gEBTN(boardData, &#x27;width&#x27;), this.gEBTN(boardData, &#x27;height&#x27;));
            }

            // check and set fontSize
            if (parseFloat(board.options.text.fontSize) &lt; 0) {
                board.options.text.fontSize = 12;
            }

            board.geonextCompatibilityMode = true;

            // jsxgraph chooses an id for the board but we don&#x27;t want to use it, we want to use
            // the id stored in the geonext file. if you know why this is required, please note it here.
            delete JXG.boards[board.id];

            board.id = this.gEBTN(boardData, &#x27;id&#x27;);

            JXG.boards[board.id] = board;

            // this creates some basic elements present in every geonext construction but not explicitly present in the file
            board.initGeonextBoard();

            // Update of properties during update() is not necessary in GEONExT files
            // But it maybe necessary if we construct with JavaScript afterwards
            board.renderer.enhancedRendering = true;

            // Read background image
            this.parseImage(board, this.gEBTN(boardData, &#x27;file&#x27;, 0, false), board.options.layer.image);

            board.options.point.snapToGrid = (this.gEBTN(this.gEBTN(boardData, &#x27;coordinates&#x27;, 0, false), &#x27;snap&#x27;) === strTrue);

            // If snapToGrid and snapToPoint are both true, point snapping is enabled
            if (board.options.point.snapToGrid &amp;&amp; this.gEBTN(this.gEBTN(boardData, &#x27;grid&#x27;, 1, false), &#x27;pointsnap&#x27;) === strTrue) {
                board.options.point.snapToGrid = false;
                board.options.point.snapToPoints = true;
                board.options.point.attractorDistance = 0.5;
            }

            xmlNode = this.gEBTN(boardData, &#x27;grid&#x27;, 1, false);
            tmp = this.gEBTN(xmlNode,  &#x27;x&#x27;);
            if (tmp) {
                board.options.grid.gridX = 1 / parseFloat(tmp);
                board.options.point.snapSizeX = 1 / parseFloat(tmp);
            }
            tmp = this.gEBTN(xmlNode,  &#x27;y&#x27;);
            if (tmp) {
                board.options.grid.gridY = 1 / parseFloat(tmp);
                board.options.point.snapSizeY = 1 / parseFloat(tmp);
            }

            board.options.grid.gridDash = JXG.str2Bool(this.gEBTN(xmlNode, &#x27;dash&#x27;));

            tmp = JXG.rgba2rgbo(this.gEBTN(xmlNode, &#x27;color&#x27;));
            board.options.grid.gridColor = tmp[0];
            board.options.grid.gridOpacity = tmp[1];

            xmlNode = this.gEBTN(boardData, &#x27;coordinates&#x27;, 0, false);
            if (this.gEBTN(xmlNode, &#x27;grid&#x27;) === strTrue) {
                board.create(&#x27;grid&#x27;, []);
            }

            if (this.gEBTN(xmlNode, &#x27;coord&#x27;) === strTrue) {
                // Hard coded default option
                board.options.axis.ticks.majorHeight = 10;

                // Hard coded default option
                board.options.axis.ticks.minorHeight = 4;
                board.create(&#x27;axis&#x27;, [[0, 0], [1, 0]]);
                board.create(&#x27;axis&#x27;, [[0, 0], [0, 1]]);
            }

            tmp = this.gEBTN(this.gEBTN(boardData, &#x27;background&#x27;, 0, false), &#x27;color&#x27;);
            if (tmp.length === 8) {
                tmp = &#x27;#&#x27; + tmp;
            }
            board.containerObj.style.backgroundColor = JXG.rgba2rgbo(tmp)[0];

            elChildNodes = tree.getElementsByTagName(&quot;elements&quot;)[0].childNodes;
            for (s = 0; s &lt; elChildNodes.length; s++) {
                this.readNode(elChildNodes, s, board);
            }
            board.addConditions(conditions);
        },

        decodeString: function (str) {
            var unz;

            if (str.indexOf(&quot;&lt;GEONEXT&gt;&quot;) &lt; 0) {
                unz = (new JXG.Util.Unzip(JXG.Util.Base64.decodeAsArray(str))).unzip();
                if (unz === &quot;&quot;) {
                    return str;
                }

                return unz;
            }

            return str;
        },

        prepareString: function (fileStr) {
            try {
                if (fileStr.indexOf(&#x27;GEONEXT&#x27;) &lt; 0) {
                    // Base64 decoding
                    fileStr = (this.decodeString(fileStr))[0][0];
                }
                // Hacks to enable not well formed XML. Will be redone in geonext2JS and Board.addConditions
                fileStr = this.fixXML(fileStr);
            } catch (exc2) {
                fileStr = &#x27;&#x27;;
            }
            return fileStr;
        },

        fixXML: function (str) {
            var arr = [&quot;active&quot;, &quot;angle&quot;, &quot;animate&quot;, &quot;animated&quot;, &quot;arc&quot;, &quot;area&quot;, &quot;arrow&quot;, &quot;author&quot;, &quot;autodigits&quot;, &quot;axis&quot;,
                    &quot;back&quot;, &quot;background&quot;, &quot;board&quot;, &quot;border&quot;, &quot;bottom&quot;, &quot;buttonsize&quot;, &quot;cas&quot;, &quot;circle&quot;, &quot;color&quot;,
                    &quot;comment&quot;, &quot;composition&quot;, &quot;condition&quot;, &quot;conditions&quot;, &quot;content&quot;, &quot;continuous&quot;, &quot;control&quot;, &quot;coord&quot;,
                    &quot;coordinates&quot;, &quot;cross&quot;, &quot;cs&quot;, &quot;dash&quot;, &quot;data&quot;, &quot;description&quot;, &quot;digits&quot;, &quot;direction&quot;, &quot;draft&quot;,
                    &quot;editable&quot;, &quot;elements&quot;, &quot;event&quot;, &quot;file&quot;, &quot;fill&quot;, &quot;first&quot;, &quot;firstarrow&quot;, &quot;fix&quot;, &quot;fontsize&quot;, &quot;free&quot;,
                    &quot;full&quot;, &quot;function&quot;, &quot;functionx&quot;, &quot;functiony&quot;, &quot;GEONEXT&quot;, &quot;graph&quot;, &quot;grid&quot;, &quot;group&quot;, &quot;height&quot;, &quot;id&quot;,
                    &quot;image&quot;, &quot;info&quot;, &quot;information&quot;, &quot;input&quot;, &quot;intersection&quot;, &quot;item&quot;, &quot;jsf&quot;, &quot;label&quot;, &quot;last&quot;,
                    &quot;lastarrow&quot;, &quot;left&quot;, &quot;lefttoolbar&quot;, &quot;lighting&quot;, &quot;line&quot;, &quot;loop&quot;, &quot;max&quot;, &quot;maximized&quot;, &quot;member&quot;,
                    &quot;middle&quot;, &quot;midpoint&quot;, &quot;min&quot;, &quot;modifier&quot;, &quot;modus&quot;, &quot;mp&quot;, &quot;mpx&quot;, &quot;multi&quot;, &quot;name&quot;, &quot;onpolygon&quot;,
                    &quot;order&quot;, &quot;origin&quot;, &quot;output&quot;, &quot;overline&quot;, &quot;parametercurve&quot;, &quot;parent&quot;, &quot;point&quot;, &quot;pointsnap&quot;,
                    &quot;polygon&quot;, &quot;position&quot;, &quot;radius&quot;, &quot;radiusnum&quot;, &quot;radiusvalue&quot;, &quot;right&quot;, &quot;section&quot;,
                    &quot;selectedlefttoolbar&quot;, &quot;showconstruction&quot;, &quot;showcoord&quot;, &quot;showinfo&quot;, &quot;showunit&quot;, &quot;showx&quot;, &quot;showy&quot;,
                    &quot;size&quot;, &quot;slider&quot;, &quot;snap&quot;, &quot;speed&quot;, &quot;src&quot;, &quot;start&quot;, &quot;stop&quot;, &quot;straight&quot;, &quot;stroke&quot;, &quot;strokewidth&quot;,
                    &quot;style&quot;, &quot;term&quot;, &quot;text&quot;, &quot;top&quot;, &quot;trace&quot;, &quot;tracecurve&quot;, &quot;tracepoint&quot;, &quot;traceslider&quot;, &quot;type&quot;, &quot;unit&quot;,
                    &quot;value&quot;, &quot;VERSION&quot;, &quot;vertex&quot;, &quot;viewport&quot;, &quot;visible&quot;, &quot;width&quot;, &quot;wot&quot;, &quot;x&quot;, &quot;xooy&quot;, &quot;xval&quot;, &quot;y&quot;,
                    &quot;yval&quot;, &quot;zoom&quot;],

                list = arr.join(&#x27;|&#x27;),
                regex = &#x27;&amp;lt;(/?(&#x27; + list + &#x27;))&amp;gt;&#x27;,
                expr = new RegExp(regex, &#x27;g&#x27;);

            // First, we convert all &lt; to &amp;lt; and &gt; to &amp;gt;
            str = JXG.escapeHTML(str);
            // Second, we convert all GEONExT tags of the form &amp;lt;tag&amp;gt; back to &lt;tag&gt;
            str = str.replace(expr, &#x27;&lt;$1&gt;&#x27;);

            // intentional
            /*jslint regexp:true*/
            str = str.replace(/(&lt;content&gt;.*)&lt;arc&gt;(.*&lt;\/content&gt;)/g, &#x27;$1&amp;lt;arc&amp;gt;$2&#x27;);
            str = str.replace(/(&lt;mp&gt;.*)&lt;arc&gt;(.*&lt;\/mpx&gt;)/g, &#x27;$1&amp;lt;arc&amp;gt;$2&#x27;);
            str = str.replace(/(&lt;mpx&gt;.*)&lt;arc&gt;(.*&lt;\/mpx&gt;)/g, &#x27;$1&amp;lt;arc&amp;gt;$2&#x27;);
            /*jslint regexp:false*/

            return str;
        }
    });

    JXG.registerReader(JXG.GeonextReader, [&#x27;gxt&#x27;, &#x27;geonext&#x27;]);
}());

    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
